(;; Most macros that are about modifying control flow and their helper
  functions are here.)

(;; This is false.)

(function false (l r) [mk# r #0])

(function true (l r) [mk# r #1])

(;; The following macro returns the first non-zero argument supplied to
  it leaving the rest unevaluated. If all the arguments are zero, then
  it returns (false).)

(function or (l r) (with return
  {(continuation loop (l sexpr)
      (if [emt? l]
        {return sexpr}
        {loop [@rst l] (`(let (or:temp (,[@fst l])) (if or:temp or:temp (, sexpr r)))r)}))
    [meta:reverse l r] (`(false)r)}))

(;; The following macro returns the first zero argument supplied to it
  leaving the rest unevaluated. If all the arguments are non-zero, then
  it returns (true).)

(function and (l r) (with return
  {(continuation loop (l sexpr)
      (if [emt? l]
        {return sexpr}
        {loop [@rst l] (`(let (and:temp (,[@fst l])) (if and:temp (, sexpr r) and:temp))r)}))
    [meta:reverse l r] (`(true)r)}))

(;; The following macro returns (false) if the single argument supplied to it
  is non-zero. Otherwise it returns (true).)

(function not (l r) (`(if (,[@fst l]) (false) (true))r))

(;; Reverses the given list. l is the list to be reversed. r is the buffer into
  which the reversed list will be put. Return value is the reversed list.)

(function meta:reverse (l r)
  (with return
    {(continuation _ (l reversed)
      (if [emt? l]
        {return reversed}
        {_ [@rst l] [lst [@fst l] reversed r]})) l emt}))

(;; Maps the given list using the given function. l is the list to be mapped. ctx
  is always passed as a second argument to the mapper. mapper is the two argument
  function that will be supplied a list item as its first argument and ctx as its
  second argument and will return an argument that will be put into the corresponding
  position of another list. r is the buffer into which the list being constructed
  will be put. Return value is the mapped list.)

(function meta:map (l mapper r)
  (with return
    {(continuation aux (in out)
      (if [emt? in]
        {return [meta:reverse out r]}
        {aux [@rst in] [lst [mapper [@fst in]] out r]})) l emt}))

(function meta:map2 (l ctx mapper r)
  (with return
    {(continuation aux (in out)
      (if [emt? in]
        {return [meta:reverse out r]}
        {aux [@rst in] [lst [mapper [@fst in] ctx] out r]})) l emt}))

(;; The following function implements variable binding by do the following
  transformation:
  
  (let (params args) ... expr0)
  ->
  (with let:return
    {(continuation let:aux (params ...)
      {let:return expr0}) vals ...}))

(function let (l r)
  (`(with let:return
    (,[llst (` jump r) (`(continuation let:aux (,[meta:map [@rst [meta:reverse l r]] @fst r])
      {let:return (,[@fst [meta:reverse l r]])}) r) [meta:map [@rst [meta:reverse l r]] @frst r] r])) r))

(;; The following function implements the switch expression by doing the
  following transformation:
  
  (switch eq0 val0 (vals exprs) ... expr0)
  ->
  (let (tempeq0 eq0) (tempval0 val0)
    (if [tempeq0 tempval0 vals1]
      exprs1
      (if [tempeq0 tempval0 vals2]
        exprs2
        ...
          (if [tempeq0 tempval0 valsN]
            exprsN
            expr0)))))

(function switch (l r)
  (`(let (switch:= (,[@fst l])) (switch:val (,[@frst l]))
    (,(with return
      {(continuation aux (remaining else-clause)
        (if [emt? remaining]
          {return else-clause}
          {aux [@rst remaining]
            (`(if (,[lst (` or r) [meta:map2 [@rst [meta:reverse [@fst remaining] r]] r
                (function _ (e r) [llllst (` invoke r) (` switch:= r) (` switch:val r) e emt r]) r] r])
              (,[@fst [meta:reverse [@fst remaining] r]]) ,else-clause) r)}))
        [@rst [meta:reverse [@rrst l] r]] [@fst [meta:reverse l r]]})))r))

(;; These macros provide exactly the same functionality as their equivalents
  in C.)

(function while (l r)
  (`(with while:return {(continuation while:aux (while:val)
    (if (,[@fst l])
      {while:aux (,[@frst l])}
      {while:return while:val})) (begin)})r))

(;; The following macro is roughly analogous to C's for-loop. The difference is
  that until loops until the condition is true rather than while it is true. The
  other difference is that this construct updates the loop control varable itself
  using the update expression - this is different from C where the update part
  of the loop header must do the mutations itself.)

(function until (l r)
  (`(with until:return {(continuation until:aux ((,[@ffst l]))
    (if (,[@frst l])
      {until:return (begin)}
      (begin (,[@frrrst l]) {until:aux (,[@frrst l])}))) (,[@frfst l])})r))

(;; The following function implements the following transformation:
  
  (fallthrough expr (labels exprs) ...)
  ->
  (begin (with labelN ... (begin (with label0
    expr) expr0) ... ) exprN))

(function fallthrough (l r) (with return
  {(continuation loop (acc exprs)
      (if [emt? exprs]
        {return acc}
        {loop (`(begin (with (,[@ffst exprs]) ,acc) (,[@frfst exprs]))r) [@rst exprs]}))
    [@fst l] [@rst l]}))

(;; The following function implements variable binding by do the following
  transformation:
  
  (loop cont (params args) ... expr0)
  ->
  (with loop:return
    {(continuation cont (params ...)
      {loop:return expr0}) vals ...}))

(function loop (l r)
  (let (bindings [meta:reverse [@rst [meta:reverse [@rst l] r]] r])
    (`(with loop:return
      (,[llst (` jump r) (`(continuation (,[@fst l]) (,[meta:map bindings @fst r])
        {loop:return (,[@fst [meta:reverse l r]])}) r) [meta:map bindings @frst r] r])) r)))

(;; The following function implements variable binding by do the following
  transformation:
  
  (define (name val) exprs ...)
  ->
  (with define:return
    {(continuation define:cont (name) (begin
      exprs ...
      {define:return (begin)})) val}))

(function define (l r)
  (`(with define:return
    {(continuation define:cont ((,[@ffst l]))
      (,[lst (` begin r)
        [meta:reverse [lst (`{define:return (begin)}r) [meta:reverse [@rst l] r] r] r] r])) (,[@frfst l])})r))

(;; The following function implements the following transformation:
  
  (default label expr1 expr2)
  ->
  (with label (begin expr1 {label expr2})))

(function default (l r) (`(with (,[@fst l]) (begin (,[@frst l]) {(,[@fst l]) (,[@frrst l])}))r))

(;; The following function implements an anonymous function using the following
    transformation:
    
    (\(params ...) body)
    ->
    (function \:self (params ...) body))

(function \ (l r) (`(function \:self (,[@fst l]) (,[@frst l]))r))

