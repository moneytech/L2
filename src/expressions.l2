(ignore A complete description for bindings that will be put into generated object files.)

  (function binding-aug (l r) [=# #56 r])

  (function bndg-name (l r) [property #0 #8 (\ r (` bndg-aug r)) (\ s r (` string r)) l r])

  (function bndg-offset (l r) [property #8 #8 (\ r (` bndg-aug r)) (\ s r [var r]) l r])

  (function bndg-size (l r) [property #16 #8 (\ r (` bndg-aug r)) (\ s r [var r]) l r])

  (function bndg-symbol (l r) [property #24 #8 (\ r (` bndg-aug r)) (\ s r (` expr r)) l r])

  (function bndg-expression (l r) [property #32 #8 (\ r (` bndg-aug r)) (\ s r (` expr r)) l r])

  (function bndg-context (l r) [property #40 #8 (\ r (` bndg-aug r)) (\ s r [var r]) l r])

  (function bndg-storage (l r) [property #48 #1 (\ r (` bndg-aug r)) (\ s r (` bndg-storage r)) l r])

  (function bndg-scope (l r) [property #49 #1 (\ r (` bndg-aug r)) (\ s r (` bndg-scope r)) l r])

  (function bndg-state (l r) [property #50 #1 (\ r (` bndg-aug r)) (\ s r (` bndg-state r)) l r])

(ignore Valid values for bndg-storage)

  (function absolute-storage (l r) [=## #0 (\ r (` bndg-storage r)) r])

  (function frame-relative-storage (l r) [=## #1 (\ r (` bndg-storage r)) r])

  (function top-relative-storage (l r) [=## #2 (\ r (` bndg-storage r)) r])

  (function nil-storage (l r) [=## #3 (\ r (` bndg-storage r)) r])

(ignore Valid values for bndg-scope)

  (function local-scope (l r) [=## #0 (\ r (` bndg-scope r)) r])

  (function global-scope (l r) [=## #1 (\ r (` bndg-scope r)) r])

(ignore Valid values for bndg-state)

  (function undefined-state (l r) [=## #0 (\ r (` bndg-state r)) r])

  (function defined-state (l r) [=## #1 (\ r (` bndg-state r)) r])

(ignore A complete representation for L2 expressions as they are found in L2 source files.)

  (function expression (l r) [=# #96 r])

  (function expr-type (l r) [property #0 #8 (\ r (` expr r)) (\ s r (` expr-type r)) l r])

  (function expr-fragment (l r) [property #8 #8 (\ r (` expr r)) (\ s r (` frag r)) l r])

  (function expr-meta (l r) [property #16 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

  (function expr-signature (l r) [property #24 #8 (\ r (` expr r)) (\ s r (` frag r)) l r])

  (function expr-lowlink (l r) [property #32 #8 (\ r (` expr r)) (\ s r [var r]) l r])

  (function expr-dependencies (l r) [property #40 #8 (\ r (` expr r)) (\ s r (` (list expr) r)) l r])
  
  (function expr-binding-aug (l r) [property #48 #8 (\ r (` expr r)) (\ s r (` bndg-aug r)) l r])

(ignore Only for type(s) (-assembly-))

  (function expr-code (l r) [property #56 #8 (\ r (` expr r)) (\ s r (` expr-code r)) l r])

(ignore Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))

  (function expr-arguments (l r) [property #64 #8 (\ r (` expr r)) (\ s r (` (list expr) r)) l r])

(ignore Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-meta-) (-constrain-))

  (function expr-reference (l r) [property #56 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

(ignore Only for type(s) (-jump-))

  (function expr-short-circuit (l r) [property #88 #8 (\ r (` expr r)) (\ s r [var r]) l r])

(ignore Only for type(s) (-if-))

  (function expr-condition (l r) [property #56 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

  (function expr-consequent (l r) [property #64 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

  (function expr-alternate (l r) [property #72 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

(ignore Only for type(s) (-literal-))

  (function expr-value (l r) [property #56 #8 (\ r (` expr r)) (\ s r [var r]) l r])

(ignore Only for type(s) (-function-) (-continuation-) (-with-) (-constrain-))

  (function expr-expression (l r) [property #64 #8 (\ r (` expr r)) (\ s r (` expr r)) l r])

(ignore Only for type(s) (-function-) (-continuation-) (-with-))

  (function expr-parameters (l r) [property #72 #8 (\ r (` expr r)) (\ s r (` (list expr) r)) l r])

(ignore Only for type(s) (-function-))

  (function expr-binding-augs (l r) [property #80 #8 (\ r (` expr r)) (\ s r (` (list bndg-aug) r)) l r])

(ignore Only for type(s) (-continuation-) (-with-))

  (function expr-cont-instr-bndg (l r) [property #80 #8 (\ r (` expr r)) (\ s r [var r]) l r])

  (function expr-escapes (l r) [property #88 #8 (\ r (` expr r)) (\ s r [var r]) l r])

(ignore Only for type(s) (-symbol-))

  (function expr-name (l r) [property #56 #8 (\ r (` expr r)) (\ s r (` string r)) l r])

(ignore Only for type(s) (-invoke-) (-jump-))

  (function expr-contains-flag (l r) [property #72 #8 (\ r (` expr r)) (\ s r (` expr-contains-flag r)) l r])

  (function expr-temp-storage-bndg (l r) [property #80 #8 (\ r (` expr r)) (\ s r [var r]) l r])

(ignore Valid values for expr-type.)

  (function -storage- (l r) [=## #0 (\ r (` expr-type r)) r])

  (function -function- (l r) [=## #1 (\ r (` expr-type r)) r])

  (function -with- (l r) [=## #2 (\ r (` expr-type r)) r])

  (function -invoke- (l r) [=## #3 (\ r (` expr-type r)) r])

  (function -if- (l r) [=## #4 (\ r (` expr-type r)) r])

  (function -literal- (l r) [=## #6 (\ r (` expr-type r)) r])

  (function -symbol- (l r) [=## #7 (\ r (` expr-type r)) r])

  (function -jump- (l r) [=## #8 (\ r (` expr-type r)) r])

  (function -continuation- (l r) [=## #9 (\ r (` expr-type r)) r])

  (function -assembly- (l r) [=## #10 (\ r (` expr-type r)) r])

  (function -meta- (l r) [=## #11 (\ r (` expr-type r)) r])

  (function -constrain- (l r) [=## #12 (\ r (` expr-type r)) r])

(ignore Valid values for expr-contains-flag.)

  (function contains-none (l r) [=## #0 (\ r (` expr-contains-flag r)) r])

  (function contains-jump (l r) [=## #1 (\ r (` expr-contains-flag r)) r])

  (function contains-with (l r) [=## #3 (\ r (` expr-contains-flag r)) r])

(ignore
  Convenience functions for making L2 expressions. They save you from having
  to construct parameter and argument lists separately from the construction of
  the expression.)

(ignore Usage (make-functionN ref-expr (param-exprs ...) expr frag meta buf handler))

(function make-functionN (l r)
  [lllllst (` invoke r) (` make-function r) [@fst l] [list [lst [@frst l] [@rrrrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(ignore Analogous to above.)

(function make-continuationN (l r)
  [lllllst (` invoke r) (` make-continuation r) [@fst l] [list [lst [@frst l] [@rrrrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(ignore Usage (make-asmN opcode (arg-exprs ...) buf handler))

(function make-asmN (l r)
  [llllst (` invoke r) (` make-asm r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(ignore Usage (make-jumpN ref-expr (arg-exprs ...) frag meta buf handler))

(function make-jumpN (l r)
  [llllst (` invoke r) (` make-jump r) [@fst l] [list [lst [@frst l] [@rrrrst l] r] r] [@rrst l] r])

(ignore Analogous to above.)

(function make-invokeN (l r)
  [llllst (` invoke r) (` make-invoke r) [@fst l] [list [lst [@frst l] [@rrrrst l] r] r] [@rrst l] r])

(ignore Constant against which the length of a literal expression is checked.)

(function build-expression-literal-len (l r) [=# #64 r])

(constrain null-expr (\ r (` expr r)))

(storage null-expr (ignore))

(storage null-binding (ignore))

(constrain make-binding-aug
  (\ r (with-vars (a) (`(function (bndg-storage bndg-scope bndg-state string expr expr buffer ,a) bndg-aug)r)r)))

(function make-binding-aug (type scope state name symbol expression r handler)
  (let (bndg [buffer-alloc (binding-aug) r handler]) (do
    (setf bndg-storage bndg type)
    (setf bndg-scope bndg scope)
    (setf bndg-state bndg state)
    (setf bndg-name bndg name)
    (setf bndg-symbol bndg symbol)
    (setf bndg-expression bndg expression)
    bndg)))

(constrain make-literal (\ r (with-vars (a b) (`(function (,a frag expr buffer ,b) expr)r)r)))

(function make-literal (value frag meta reg handler)
  (substitute (.. reg handler) (let (t [buffer-alloc (expression) ..]) (do
    (setf expr-type t (-literal-))
    (setf expr-fragment t frag)
    (setf expr-meta t meta)
    (setf expr-signature t [vbl->frag [vbl ..]])
    (setf expr-lowlink t #0)
    (setf expr-dependencies t nil)
    (setf expr-binding-aug t [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr t ..])
    (setf expr-value t value)
    t))))

(constrain make-symbol (\ r (with-vars (b) (`(function (string frag expr buffer ,b) expr)r)r)))

(function make-symbol (name frag meta reg handler)
  (substitute (.. reg handler) (let (sym [buffer-alloc (expression) ..]) (do
    (setf expr-type sym (-symbol-))
    (setf expr-fragment sym frag)
    (setf expr-meta sym meta)
    (setf expr-signature sym [vbl->frag [vbl ..]])
    (setf expr-lowlink sym #0)
    (setf expr-dependencies sym nil)
    (setf expr-name sym name)
    (setf expr-binding-aug sym null-binding)
    sym))))

(ignore
  Binds a symbol expression to another symbol expression. symbol is the expression being
  bound. target is the symbol expression being bound to.)

(constrain bind-symbol (\ r (`(function (expr expr) ())r)))

(function bind-symbol (symbol target) (setf expr-binding-aug symbol (@ expr-binding-aug target)))

(ignore
  Makes an undefined binding with the given name. Internally, a storage expression is made
  to be the target of the symbol so as to enable type inferencing on symbols using this
  binding.)

(constrain make-undefined-binding (\ r (with-vars (b) (`(function (string buffer ,b) bndg-aug)r)r)))

(function make-undefined-binding (name r handler)
  (substitute (.. r handler)
    (let (stg [make-storage [make-symbol name null-frag null-expr ..] nil null-frag null-expr ..])
    (let (bndg (@ expr-binding-aug (@ expr-reference stg))) (do
    (setf bndg-storage bndg (absolute-storage))
    (setf bndg-scope bndg (global-scope))
    (setf bndg-state bndg (undefined-state))
    bndg)))))

(ignore
  Makes a symbol expression attached to the given augmented binding. bndg is the augmented
  binding to which the symbol will be attached. reg is the buffer into which the the
  symbol expression will be put. Return value is the symbol expression.)

(constrain use-binding-aug (\ r (with-vars (b) (`(function (bndg-aug buffer ,b) expr)r)r)))

(function use-binding-aug (bndg reg handler)
  (let (sym [buffer-alloc (expression) reg handler]) (do
    (setf expr-type sym (-symbol-))
    (setf expr-fragment sym null-fragment)
    (setf expr-meta sym null-expr)
    (setf expr-name sym (@ bndg-name bndg))
    (setf expr-binding-aug sym bndg)
    sym)))

(constrain make-function (\ r (with-vars (b) (`(function (expr (list expr) expr frag expr buffer ,b) expr)r)r)))

(function make-function (ref params expr frag meta reg handler)
  (substitute (.. reg handler) (let (func [buffer-alloc (expression) ..]) (do
    (setf expr-type func (-function-))
    (setf expr-fragment func frag)
    (setf expr-meta func meta)
    (setf expr-signature func [vbl->frag [vbl ..]])
    (setf expr-lowlink func #0)
    (setf expr-dependencies func nil)
    (setf expr-binding-aug func [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr func ..])
    (setf expr-reference func ref)
    (setf expr-binding-aug ref [make-binding-aug (absolute-storage) (local-scope) (defined-state) (@ expr-name ref) ref func ..])
    (setf expr-parameters func params)
    (foreach (param params)
      (setf expr-binding-aug param
        [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param func ..]))
    (setf expr-binding-augs func nil)
    (setf expr-expression func expr)
    func))))

(constrain make-continuation (\ r (with-vars (b) (`(function (expr (list expr) expr frag expr buffer ,b) expr)r)r)))

(function make-continuation (ref params expr frag meta reg handler)
  (substitute (.. reg handler) (let (cont [buffer-alloc (expression) ..]) (do
    (setf expr-type cont (-continuation-))
    (setf expr-fragment cont frag)
    (setf expr-meta cont meta)
    (setf expr-signature cont [vbl->frag [vbl ..]])
    (setf expr-lowlink cont #0)
    (setf expr-dependencies cont nil)
    (setf expr-binding-aug cont [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr cont ..])
    (setf expr-cont-instr-bndg cont
      [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..])
    (setf expr-reference cont ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref cont ..])
    (setf expr-parameters cont params)
    (foreach (param params)
      (setf expr-binding-aug param
        [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param cont ..]))
    (setf expr-escapes cont (false))
    (setf expr-expression cont expr)
    cont))))

(constrain make-with (\ r (with-vars (b) (`(function (expr expr frag expr buffer ,b) expr)r)r)))

(function make-with (ref expr frag meta reg handler)
  (substitute (.. reg handler) (let (wth [buffer-alloc (expression) ..]) (do
    (setf expr-type wth (-with-))
    (setf expr-fragment wth frag)
    (setf expr-meta wth meta)
    (setf expr-signature wth [vbl->frag [vbl ..]])
    (setf expr-lowlink wth #0)
    (setf expr-dependencies wth nil)
    (setf expr-binding-aug wth [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr wth ..])
    (setf expr-cont-instr-bndg wth [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..])
    (setf expr-reference wth ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref wth ..])
    (let (param [make-symbol null-string null-fragment null-expr ..]) (do
      (setf expr-binding-aug param
        [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param wth ..])
      (setf expr-parameters wth [cons param nil ..])))
    (setf expr-escapes wth (false))
    (setf expr-expression wth expr)
    wth))))

(constrain make-asm (\ r (with-vars (b) (`(function (expr-code (list expr) buffer ,b) expr)r)r)))

(function make-asm (code arguments reg handler)
  (let (u [buffer-alloc (expression) reg handler]) (do
    (setf expr-type u (-assembly-))
    (setf expr-code u code)
    (setf expr-arguments u arguments)
    u)))

(constrain make-jump (\ r (with-vars (b) (`(function (expr (list expr) frag expr buffer ,b) expr)r)r)))

(function make-jump (ref args frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-jump-))
    (setf expr-fragment u frag)
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-short-circuit u null-expr)
    (setf expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-arguments u args)
    u))))

(constrain make-storage (\ r (with-vars (b) (`(function (expr (list expr) frag expr buffer ,b) expr)r)r)))

(function make-storage (ref args frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-storage-))
    (setf expr-fragment u frag)
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-reference u ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref u ..])
    (setf expr-arguments u args)
    u))))

(constrain make-meta (\ r (with-vars (a b) (`(function (expr frag expr buffer ,b) expr)r)r)))

(function make-meta (ref frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-meta-))
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u null-binding)
    (setf expr-reference u ref)
    (setf expr-fragment u frag)
    u))))

(constrain make-constrain (\ r (with-vars (b) (`(function (expr expr frag expr buffer ,b) expr)r)r)))

(function make-constrain (expr ref frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-constrain-))
    (setf expr-fragment u frag)
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-reference u ref)
    (setf expr-expression u expr)
    u))))

(constrain make-if (\ r (with-vars (b) (`(function (expr expr expr frag expr buffer ,b) expr)r)r)))

(function make-if (condition consequent alternate frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-if-))
    (setf expr-fragment u frag)
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-condition u condition)
    (setf expr-consequent u consequent)
    (setf expr-alternate u alternate)
    u))))

(constrain make-invoke (\ r (with-vars (b) (`(function (expr (list expr) frag expr buffer ,b) expr)r)r)))

(function make-invoke (ref args frag meta reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-invoke-))
    (setf expr-fragment u frag)
    (setf expr-meta u meta)
    (setf expr-signature u [vbl->frag [vbl ..]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-binding-aug u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string null-expr u ..])
    (setf expr-arguments u args)
    u))))

(ignore Prints the given expression as it would be written in an L2 source file. s is an expression.)

(constrain print-expression (\ r (with-vars (a) (`(function (expr ,a) ())r)r)))

(function print-expression (s hdl) (substitute (.. hdl)
  (switch = (@ expr-type s)
    ((-with-) (do
      [print-str (stdout) (" (lparen)with(space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-invoke-) (-jump-) (-storage-) (do
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (lbracket)))
        ((-jump-) (" (lbrace)))
        (" (lparen)storage(space))) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      (foreach (t (@ expr-arguments s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-function-) (-continuation-) (do
      [print-str (stdout) (" (lparen)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-function-) (" function))
        (" continuation)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)(lparen)(space)) ..]
      (foreach (t (@ expr-parameters s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (rparen)(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    ((-if-) (do
      [print-str (stdout) (" (lparen)if(space)) ..]
      [print-expression (@ expr-condition s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-consequent s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-alternate s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-constrain-) (do
      [print-str (stdout) (" (lparen)constrain(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment (@ expr-signature s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-symbol-)
      (if [not= (@ expr-name s) null-string]
        [print-str (stdout) (@ expr-name s) ..]
        (do
          [print-str (stdout) (" (lparen)reference(space)) ..]
          [print-uint (stdout) (@ expr-binding-aug s) ..]
          [print-str (stdout) (" (rparen)) ..])))
          
    ((-literal-) (do
      [print-str (stdout) (" (lparen)literal(space)) ..]
      [print-uint (stdout) (@ expr-value s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-meta-) [print-fragment (@ expr-fragment s) ..])
      
    (ignore))))

(storage special-form-error (ignore))

(ignore
  Builds an expression from a given program fragment. d is the program fragment.
  reg is the buffer into which the built expressions will be put. The return value
  is the constructed expression. The continuation handler will be followed, and
  buffer reference by err set to the tuple (special-form-error, ...) in the event
  of a malformed expression.)

(constrain build-expression (\ r (with-vars (a) (`(function (frag expr buffer ,a) expr)r)r)))

(function build-expression (frag meta reg handler) (substitute (.. reg handler)
  (if [i/f:token? frag] [make-symbol [to-string [fragment->token frag] ..] frag meta ..]
  (let (d [frag->list frag])
    (if [= [length d] #0] {handler (storage _ special-form-error d null-fragment)}
    (switch str= [to-string [fragment->token [@car d]] ..]
      ((" with)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
          [make-with [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..] frag meta ..])))
      
      ((" if)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
          [make-if [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..]
            [build-expression [@cadddr d] meta ..] frag meta ..]))
      
      ((" function) (" continuation)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
        (if [i/f:token? [@caddr d]]
          {handler (storage _ special-form-error d [@caddr d])}
          (let (parameters (map (v [frag->list [@caddr d]])
              (if [i/f:token? v]
                [build-expression v meta ..]
                {handler (storage _ special-form-error d v)}) ..))
                
            [(switch str= [to-string [fragment->token [@car d]] ..]
                ((" function) make-function)
                make-continuation)
              [build-expression [@cadr d] meta ..] parameters [build-expression [@cadddr d] meta ..] frag meta ..])))))
      
      ((" invoke) (" jump) (" storage)
        (if [= [length d] #1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (and [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f:token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [(switch str= [to-string [fragment->token [@car d]] ..]
              ((" invoke) make-invoke)
              ((" jump) make-jump)
              make-storage)
            [build-expression [@cadr d] meta ..] (map (v [@cddr d]) [build-expression v meta ..] ..) frag meta ..])))
      
      ((" literal)
        (if (not [= [length d] #2])
          {handler (storage _ special-form-error d null-fragment)}
        (if (or (not [i/f:token? [@cadr d]]) (not [= [length [frag->list [@cadr d]]] (build-expression-literal-len)]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-literal
            (loop build-num (str [to-string [fragment->token [@cadr d]] ..]) (i (build-expression-literal-len)) (value #0)
              (if [= i #0]
                value
              (if [= [getb str] (char 1)]
                {build-num [+ str #1] [- i #1] [+ [<< value #1] #1]}
              (if [= [getb str] (char 0)]
                {build-num [+ str #1] [- i #1] [<< value #1]}
                {handler (storage _ special-form-error d [@cadr d])})))) frag meta ..])))
      
      ((" constrain)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
          [make-constrain [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..] frag meta ..]))
      
      [make-meta [build-expression [@car d] meta ..] frag meta ..]))))))

(ignore
  Make a unary function with the given name that calls an undefined function of the same
  name with the same arguments that it received. The idea is that the intrinsic generators
  will replace the function call with inline assembly.)

(constrain make-unary-intrinsic (\ r (with-vars (a) (`(function (string buffer ,a) expr)r)r)))

(function make-unary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (func-symbol [make-symbol name null-fragment null-expr ..])
        (callee-symbol [make-symbol null-string null-fragment null-expr ..])
        (param-a [make-symbol null-string null-fragment null-expr ..])
        (arg-a [make-symbol null-string null-fragment null-expr ..])
      (let (func (make-functionN func-symbol (param-a)
          (make-invokeN callee-symbol (arg-a) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-binding-aug callee-symbol [make-undefined-binding (@ expr-name func-symbol) ..])
        [bind-symbol arg-a param-a]
        func)))))

(ignore Performs actions analogous to make-unary-intrinsic, but for binary functions.)

(constrain make-binary-intrinsic (\ r (with-vars (a) (`(function (string buffer ,a) expr)r)r)))

(function make-binary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (func-symbol [make-symbol name null-fragment null-expr ..])
        (callee-symbol [make-symbol null-string null-fragment null-expr ..])
        (param-a [make-symbol null-string null-fragment null-expr ..])
        (param-b [make-symbol null-string null-fragment null-expr ..])
        (arg-a [make-symbol null-string null-fragment null-expr ..])
        (arg-b [make-symbol null-string null-fragment null-expr ..])
      (let (func (make-functionN func-symbol (param-a param-b)
          (make-invokeN callee-symbol (arg-a arg-b) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-binding-aug callee-symbol [make-undefined-binding (@ expr-name func-symbol) ..])
        [bind-symbol arg-a param-a]
        [bind-symbol arg-b param-b]
        func)))))

