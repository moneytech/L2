(;; A complete description for bindings that will be put into generated object files.)

(function binding-aug (l r) [mk# r #48])

(function bndg-name (l r) [mk-field l r #0 #8])
(function bndg-offset (l r) [mk-field l r #8 #8])
(function bndg-size (l r) [mk-field l r #16 #8])
(function bndg-definition (l r) [mk-field l r #24 #8])
(function bndg-context (l r) [mk-field l r #32 #8])
(function bndg-storage (l r) [mk-field l r #40 #1])
(function bndg-scope (l r) [mk-field l r #41 #1])
(function bndg-state (l r) [mk-field l r #42 #1])

(;; Valid values for bndg-storage)

(function absolute-storage (l r) [mk# r #0])
(function frame-relative-storage (l r) [mk# r #1])
(function top-relative-storage (l r) [mk# r #2])
(function nil-storage (l r) [mk# r #3])

(;; Valid values for bndg-scope)

(function local-scope (l r) [mk# r #0])
(function global-scope (l r) [mk# r #1])

(;; Valid values for bndg-state)

(function undefined-state (l r) [mk# r #0])
(function defined-state (l r) [mk# r #1])

(;; A complete representation for L2 expressions as they are found in L2 source files.)

(function expression (l r) [mk# r #56])

(function expr-type (l r) [mk-field l r #0 #8])
(function expr-parent (l r) [mk-field l r #8 #8])
(;; Only for type(s) (-begin-))
(function expr-expressions (l r) [mk-field l r #16 #8])
(;; Only for type(s) (-assembly-))
(function expr-opcode (l r) [mk-field l r #16 #8])
(;; Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))
(function expr-arguments (l r) [mk-field l r #24 #8])
(;; Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-meta-))
(function expr-reference (l r) [mk-field l r #16 #8])
(;; Only for type(s) (-jump-))
(function expr-short-circuit (l r) [mk-field l r #48 #8])
(;; Only for type(s) (-if-))
(function expr-condition (l r) [mk-field l r #16 #8])
(function expr-consequent (l r) [mk-field l r #24 #8])
(function expr-alternate (l r) [mk-field l r #32 #8])
(;; Only for type(s) (-literal-))
(function expr-value (l r) [mk-field l r #16 #8])
(;; Only for type(s) (-function-) (-continuation-) (-with-))
(function expr-expression (l r) [mk-field l r #24 #8])
(function expr-parameters (l r) [mk-field l r #32 #8])
(;; Only for type(s) (-function-))
(function expr-binding-augs (l r) [mk-field l r #40 #8])
(;; Only for type(s) (-continuation-) (-with-))
(function expr-cont-instr-bndg (l r) [mk-field l r #40 #8])
(function expr-escapes (l r) [mk-field l r #48 #8])
(;; Only for type(s) (-symbol-))
(function expr-name (l r) [mk-field l r #16 #8])
(function expr-binding-aug (l r) [mk-field l r #24 #8])
(;; Only for type(s) (-meta-))
(function expr-argument (l r) [mk-field l r #24 #8])
(;; Only for type(s) (-invoke-) (-jump-))
(function expr-contains-flag (l r) [mk-field l r #32 #8])
(function expr-temp-storage-bndg (l r) [mk-field l r #40 #8])

(;; Valid values for expr-type.)

(function -storage- (l r) [mk# r #0])
(function -function- (l r) [mk# r #1])
(function -with- (l r) [mk# r #2])
(function -invoke- (l r) [mk# r #3])
(function -if- (l r) [mk# r #4])
(function -begin- (l r) [mk# r #5])
(function -literal- (l r) [mk# r #6])
(function -symbol- (l r) [mk# r #7])
(function -jump- (l r) [mk# r #8])
(function -continuation- (l r) [mk# r #9])
(function -assembly- (l r) [mk# r #10])
(function -meta- (l r) [mk# r #11])

(;; Valid values for expr-contains-flag.)

(function contains-none (l r) [mk# r #0])
(function contains-jump (l r) [mk# r #1])
(function contains-with (l r) [mk# r #3])

(;; Convenience functions for making L2 expressions. They save you from having
  to construct parameter and argument lists separately from the construction of
  the expression.)

(;; Usage (make-functionN ref-expr (param-exprs ...) expr buf handler err))

(function make-functionN (l r)
  [lllllst (` invoke r) (` make-function r) [@fst l] [list [lst [@frst l] [@rrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(;; Analogous to above.)

(function make-continuationN (l r)
  [lllllst (` invoke r) (` make-continuation r) [@fst l] [list [lst [@frst l] [@rrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(;; Usage (make-asmN opcode (arg-exprs ...) buf handler err))

(function make-asmN (l r)
  [llllst (` invoke r) (` make-asm r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Analogous to above.)

(function make-jumpN (l r)
  [llllst (` invoke r) (` make-jump r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Analogous to above.)

(function make-invokeN (l r)
  [llllst (` invoke r) (` make-invoke r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Macro takes a reference to an expression as its first argument and an
  expression as its second argument. Produces code to obtain parent of expression
  referenced by first argument, set that to be the parent of the second expression,
  and put the second expression at the address referenced by the first argument.)

(function replace-expression (l r)
  (`(let (replace-expression:orig (,[@fst l]))
    (let (replace-expression:parent (@ expr-parent $replace-expression:orig))
      (let (replace-expression:repl (,[@frst l])) (begin
        (setf expr-parent replace-expression:repl replace-expression:parent)
        [set replace-expression:orig replace-expression:repl]))))r))

(;; The meta-expression (put field expr1 expr2) is the same as (setf field expr1 expr2)
  except that it also sets the parent of expr2 to be expr1.)

(function put (l r)
  (`(let (put:parent (,[@frst l])) (put:repl (,[@frrst l])) (begin
    (setf (,[@fst l]) put:parent put:repl)
    (setf expr-parent put:repl put:parent)))r))

(;; Constant against which the length of a literal expression is checked.)

(function build-expression-literal-len (l r) [mk# r #64])

(constrain null-expr (\(r) (` expr r)))

(storage null-expr (begin))

(storage null-binding (begin))

(function make-binding-aug (type scope state name definition r handler err) (with return
  (let (bndg [buffer-alloc (binding-aug) r handler err]) (begin
    (setf bndg-storage bndg type)
    (setf bndg-scope bndg scope)
    (setf bndg-state bndg state)
    (setf bndg-name bndg name)
    (setf bndg-definition bndg definition)
    {return bndg}))))

(constrain make-literal (\(r) (with-vars (a b c) (`(function (,a buffer ,b ,c) expr)r)r)))

(function make-literal (value reg handler err) (with return
  (let (t [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type t (-literal-))
    (setf expr-parent t null-expr)
    (setf expr-value t value)
    {return t}))))

(constrain make-symbol (\(r) (with-vars (b c) (`(function (string buffer ,b ,c) expr)r)r)))

(function make-symbol (name reg handler err) (with return
  (let (sym [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type sym (-symbol-))
    (setf expr-parent sym null-expr)
    (setf expr-name sym name)
    (setf expr-binding-aug sym null-binding)
    {return sym}))))

(;; Binds a symbol expression to another symbol expression. symbol
  is the expression being bound. target is the symbol expression
  being bound to.)

(function bind-symbol (symbol target) (setf expr-binding-aug symbol (@ expr-binding-aug target)))

(;; Makes a symbol expression attached to the given augmented binding. bndg is
  the augmented binding to which the symbol will be attached. reg is the buffer
  into which the the symbol expression will be put. Return value is the symbol
  expression.)

(function use-binding-aug (bndg reg handler err) (with return
  (let (sym [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type sym (-symbol-))
    (setf expr-parent sym null-expr)
    (setf expr-name sym (@ bndg-name bndg))
    (setf expr-binding-aug sym bndg)
    {return sym}))))

(constrain make-begin (\(r) (with-vars (b c) (`(function ((list expr) buffer ,b ,c) expr)r)r)))

(function make-begin (expressions reg handler err) (with return
  (let (beg [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type beg (-begin-))
    (setf expr-parent beg null-expr)
    (setf expr-expressions beg expressions)
    (foreach (expr expressions) (setf expr-parent expr beg))
    {return beg}))))

(constrain make-function (\(r) (with-vars (b c) (`(function (expr (list expr) expr buffer ,b ,c) expr)r)r)))

(function make-function (ref params expr reg handler err) (with return
  (substitute (.. reg handler err) (let (func [buffer-alloc (expression) ..]) (begin
    (setf expr-type func (-function-))
    (setf expr-parent func null-expr)
    (put expr-reference func ref)
    (setf expr-binding-aug ref [make-binding-aug (absolute-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-parameters func params)
    (foreach (param params) (begin
      (setf expr-parent param func)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])))
    (setf expr-binding-augs func nil)
    (put expr-expression func expr)
    {return func})))))

(constrain make-continuation (\(r) (with-vars (b c) (`(function (expr (list expr) expr buffer ,b ,c) expr)r)r)))

(function make-continuation (ref params expr reg handler err) (with return
  (substitute (.. reg handler err) (let (cont [buffer-alloc (expression) ..]) (begin
    (setf expr-type cont (-continuation-))
    (setf expr-parent cont null-expr)
    (setf expr-cont-instr-bndg cont [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (put expr-reference cont ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-parameters cont params)
    (foreach (param params) (begin
      (setf expr-parent param cont)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])))
    (setf expr-escapes cont (false))
    (put expr-expression cont expr)
    {return cont})))))

(constrain make-with (\(r) (with-vars (b c) (`(function (expr expr buffer ,b ,c) expr)r)r)))

(function make-with (ref expr reg handler err) (with return
  (substitute (.. reg handler err) (let (wth [buffer-alloc (expression) ..]) (begin
    (setf expr-type wth (-with-))
    (setf expr-parent wth null-expr)
    (setf expr-cont-instr-bndg wth [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (put expr-reference wth ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (let (param [make-symbol null-string ..]) (begin
      (setf expr-parent param wth)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])
      (setf expr-parameters wth [cons param nil ..])))
    (setf expr-escapes wth (false))
    (put expr-expression wth expr)
    {return wth})))))

(function make-asm (opcode arguments reg handler err) (with return
  (let (u [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type u (-assembly-))
    (setf expr-opcode u opcode)
    (setf expr-arguments u arguments)
    (foreach (arg arguments) (setf expr-parent arg u))
    {return u}))))

(constrain make-jump (\(r) (with-vars (b c) (`(function (expr (list expr) buffer ,b ,c) expr)r)r)))

(function make-jump (ref args reg handler err) (with return
  (substitute (.. reg handler err) (let (u [buffer-alloc (expression) ..]) (begin
    (setf expr-type u (-jump-))
    (setf expr-parent u null-expr)
    (setf expr-short-circuit u null-expr)
    (put expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string u ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    {return u})))))

(constrain make-storage (\(r) (with-vars (b c) (`(function (expr (list expr) buffer ,b ,c) expr)r)r)))

(function make-storage (ref args reg handler err) (with return
  (substitute (.. reg handler err) (let (u [buffer-alloc (expression) ..]) (begin
    (setf expr-type u (-storage-))
    (setf expr-parent u null-expr)
    (put expr-reference u ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    {return u})))))

(constrain make-meta (\(r) (with-vars (b c) (`(function (expr expr buffer ,b ,c) expr)r)r)))

(function make-meta (ref arg reg handler err) (with return
  (let (u [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type u (-meta-))
    (put expr-reference u ref)
    (setf expr-argument u arg)
    {return u}))))

(constrain make-if (\(r) (with-vars (b c) (`(function (expr expr expr buffer ,b ,c) expr)r)r)))

(function make-if (condition consequent alternate reg handler err) (with return
  (let (u [buffer-alloc (expression) reg handler err]) (begin
    (setf expr-type u (-if-))
    (setf expr-parent u null-expr)
    (put expr-condition u condition)
    (put expr-consequent u consequent)
    (put expr-alternate u alternate)
    {return u}))))

(constrain make-invoke (\(r) (with-vars (b c) (`(function (expr (list expr) buffer ,b ,c) expr)r)r)))

(function make-invoke (ref args reg handler err) (with return
  (substitute (.. reg handler err) (let (u [buffer-alloc (expression) ..]) (begin
    (setf expr-type u (-invoke-))
    (setf expr-parent u null-expr)
    (put expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string u ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    {return u})))))

(;; Builds a program from a list of expressions. exprs is the list of expressions
  from which the program will be built. A program is a function with no parent that
  has as its expression a begin expression.)

(constrain make-program (\(r) (with-vars (b c) (`(function ((list expr) buffer ,b ,c) expr)r)r)))

(function make-program (exprs r handler err) (with return (substitute (.. r handler err)
  (let (program [make-function [make-symbol null-string ..] nil [make-begin exprs ..] ..]) (begin
    (setf expr-parent program null-expr)
    (foreach (expr exprs)
      (if (or [= (@ expr-type expr) (-function-)] [= (@ expr-type expr) (-storage-)])
        (setf bndg-scope (@ expr-binding-aug(@ expr-reference expr)) (global-scope))
        (begin)))
    {return program})))))

(;; Prints the given expression as it would be written in an L2 source file.
  s is an expression.)

(constrain print-expression (\(r) (with-vars (a b c) (`(function (expr ,a ,b) ,c)r)r)))

(function print-expression (s hdl err) (substitute (.. hdl err)
  (switch = (@ expr-type s)
    ((-begin-) (begin
      [print-str (stdout) (" (lparen)begin(space)) ..]
      (foreach (t (@ expr-expressions s)) (begin
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)(rparen)) ..]))
    
    ((-with-) (begin
      [print-str (stdout) (" (lparen)with(space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-invoke-) (-jump-) (-storage-) (begin
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (lbracket)))
        ((-jump-) (" (lbrace)))
        (" (lparen)storage(space))) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      (foreach (t (@ expr-arguments s)) (begin
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-function-) (-continuation-) (begin
      [print-str (stdout) (" (lparen)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-function-) (" function))
        (" continuation)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)(lparen)(space)) ..]
      (foreach (t (@ expr-parameters s)) (begin
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (rparen)(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    ((-if-) (begin
      [print-str (stdout) (" (lparen)if(space)) ..]
      [print-expression (@ expr-condition s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-consequent s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-alternate s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-symbol-)
      (if [not= (@ expr-name s) null-string]
        [print-str (stdout) (@ expr-name s) ..]
        (begin
          [print-str (stdout) (" (lparen)reference(space)) ..]
          [print-uint (stdout) (@ expr-binding-aug s) ..]
          [print-str (stdout) (" (rparen)) ..])))
          
    ((-literal-) (begin
      [print-str (stdout) (" (lparen)literal(space)) ..]
      [print-uint (stdout) (@ expr-value s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-meta-) (begin
      [print-str (stdout) (" (lparen)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment (@ expr-argument s) ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    (begin))))

(storage special-form-error (begin))

(;; Builds an expression from a given program fragment. d is the program fragment.
  reg is the buffer into which the built expressions will be put. The return value
  is the constructed expression. The continuation handler will be followed, and
  buffer reference by err set to the tuple (special-form-error, ...) in the event
  of a malformed expression.)

(function build-expression (d reg handler err) (substitute (.. reg handler err)
  (if [= [length d] #0] {handler (sets err special-form-error d null-fragment)}
  (if [i/f:token? d] [make-symbol [to-string d ..] ..]
  (switch str= [to-string [@car d] ..]
    ((" with)
      (if (not [= [length d] #3])
        {handler (sets err special-form-error d null-fragment)}
      (if (not [i/f:token? [@cadr d]])
        {handler (sets err special-form-error d [@cadr d])}
        [make-with [build-expression [@cadr d] ..] [build-expression [@caddr d] ..] ..])))
    
    ((" begin) [make-begin [reverse (reverse-map (v [@cdr d]) [build-expression v ..] ..) ..] ..])
    
    ((" if)
      (if (not [= [length d] #4])
        {handler (sets err special-form-error d null-fragment)}
        [make-if [build-expression [@cadr d] ..] [build-expression [@caddr d] ..] [build-expression [@cadddr d] ..] ..]))
    
    ((" function) (" continuation)
      (if (not [= [length d] #4])
        {handler (sets err special-form-error d null-fragment)}
      (if (not [i/f:token? [@cadr d]])
        {handler (sets err special-form-error d [@cadr d])}
      (if [i/f:token? [@caddr d]]
        {handler (sets err special-form-error d [@caddr d])}
        (let (parameters [reverse (reverse-map (v [@caddr d])
            (if [i/f:token? v]
              [build-expression v ..]
              {handler (sets err special-form-error d v)}) ..) ..])
              
          [(switch str= [to-string [@car d] ..]
              ((" function) make-function)
              make-continuation)
            [build-expression [@cadr d] ..] parameters [build-expression [@cadddr d] ..] ..])))))
    
    ((" invoke) (" jump) (" storage)
      (if [= [length d] #1]
        {handler (sets err special-form-error d null-fragment)}
      (if (and [str= [to-string [@car d] ..] (" storage)] (not [i/f:token? [@cadr d]]))
        {handler (sets err special-form-error d [@cadr d])}
        [(switch str= [to-string [@car d] ..]
            ((" invoke) make-invoke)
            ((" jump) make-jump)
            make-storage)
          [build-expression [@cadr d] ..] [reverse (reverse-map (v [@cddr d]) [build-expression v ..] ..) ..] ..])))
    
    ((" literal)
      (if (not [= [length d] #2])
        {handler (sets err special-form-error d null-fragment)}
      (if (or (not [i/f:token? [@cadr d]]) (not [= [length [@cadr d]] (build-expression-literal-len)]))
        {handler (sets err special-form-error d [@cadr d])}
        [make-literal (with return
          {(continuation loop (str i value)
              (if [= i #0]
                {return value}
              (if [= [getb str] (char 1)]
                {loop [+ str #1] [- i #1] [+ [<< value #1] #1]}
              (if [= [getb str] (char 0)]
                {loop [+ str #1] [- i #1] [<< value #1]}
                {handler (sets err special-form-error d [@cadr d])}))))
            [to-string [@cadr d] ..] (build-expression-literal-len) #0}) ..])))
    
    [make-meta [build-expression [@car d] ..] [@cdr d] ..])))))

