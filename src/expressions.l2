(;; A complete description for bindings that will be put into generated object files.)

(function binding-aug (l r) [mk# r #48])

(function bndg-name (l r) [property #0 #8 (\(r) (` bndg-aug r)) (\(s r) (` string r)) l r])

(function bndg-offset (l r) [property #8 #8 (\(r) (` bndg-aug r)) (\(s r) [var r]) l r])

(function bndg-size (l r) [property #16 #8 (\(r) (` bndg-aug r)) (\(s r) [var r]) l r])

(function bndg-definition (l r) [property #24 #8 (\(r) (` bndg-aug r)) (\(s r) (` expr r)) l r])

(function bndg-context (l r) [property #32 #8 (\(r) (` bndg-aug r)) (\(s r) [var r]) l r])

(function bndg-storage (l r) [property #40 #1 (\(r) (` bndg-aug r)) (\(s r) (` bndg-storage r)) l r])

(function bndg-scope (l r) [property #41 #1 (\(r) (` bndg-aug r)) (\(s r) (` bndg-scope r)) l r])

(function bndg-state (l r) [property #42 #1 (\(r) (` bndg-aug r)) (\(s r) (` bndg-state r)) l r])

(;; Valid values for bndg-storage --------------------------------------------)

(function absolute-storage (l r) [mk## #0 (\(r) (` bndg-storage r)) r])

(function frame-relative-storage (l r) [mk## #1 (\(r) (` bndg-storage r)) r])

(function top-relative-storage (l r) [mk## #2 (\(r) (` bndg-storage r)) r])

(function nil-storage (l r) [mk## #3 (\(r) (` bndg-storage r)) r])

(;; Valid values for bndg-scope ----------------------------------------------)

(function local-scope (l r) [mk## #0 (\(r) (` bndg-scope r)) r])

(function global-scope (l r) [mk## #1 (\(r) (` bndg-scope r)) r])

(;; Valid values for bndg-state ----------------------------------------------)

(function undefined-state (l r) [mk## #0 (\(r) (` bndg-state r)) r])

(function defined-state (l r) [mk## #1 (\(r) (` bndg-state r)) r])

(;; A complete representation for L2 expressions as they are found in L2 source files.)

(function expression (l r) [mk# r #80])

(function expr-type (l r) [property #0 #8 (\(r) (` expr r)) (\(s r) (` expr-type r)) l r])

(function expr-parent (l r) [property #8 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(function expr-signature (l r) [property #16 #8 (\(r) (` expr r)) (\(s r) (` frag r)) l r])

(function expr-lowlink (l r) [property #24 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(function expr-dependencies (l r) [property #32 #8 (\(r) (` expr r)) (\(s r) (` (list expr) r)) l r])

(;; Only for type(s) (-begin-))

(function expr-expressions (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) (` (list expr) r)) l r])

(;; Only for type(s) (-assembly-))

(function expr-code (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) (` expr-code r)) l r])

(;; Only for type(s) (-assembly-) (-storage-) (-invoke-) (-jump-))

(function expr-arguments (l r) [property #48 #8 (\(r) (` expr r)) (\(s r) (` (list expr) r)) l r])

(;; Only for type(s) (-storage-) (-invoke-) (-jump-) (-function-) (-continuation-) (-with-) (-meta-) (-constrain-))

(function expr-reference (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(;; Only for type(s) (-jump-))

(function expr-short-circuit (l r) [property #72 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Only for type(s) (-if-))

(function expr-condition (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(function expr-consequent (l r) [property #48 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(function expr-alternate (l r) [property #56 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(;; Only for type(s) (-literal-))

(function expr-value (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Only for type(s) (-function-) (-continuation-) (-with-) (-constrain-))

(function expr-expression (l r) [property #48 #8 (\(r) (` expr r)) (\(s r) (` expr r)) l r])

(;; Only for type(s) (-function-) (-continuation-) (-with-))

(function expr-parameters (l r) [property #56 #8 (\(r) (` expr r)) (\(s r) (` (list expr) r)) l r])

(;; Only for type(s) (-function-))

(function expr-binding-augs (l r) [property #64 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Only for type(s) (-continuation-) (-with-))

(function expr-cont-instr-bndg (l r) [property #64 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(function expr-escapes (l r) [property #72 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Only for type(s) (-symbol-))

(function expr-name (l r) [property #40 #8 (\(r) (` expr r)) (\(s r) (` string r)) l r])

(function expr-binding-aug (l r) [property #48 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Only for type(s) (-meta-))

(function expr-argument (l r) [property #48 #8 (\(r) (` expr r)) (\(s r) (` (list frag) r)) l r])

(;; Only for type(s) (-invoke-) (-jump-))

(function expr-contains-flag (l r) [property #56 #8 (\(r) (` expr r)) (\(s r) (` expr-contains-flag r)) l r])

(function expr-temp-storage-bndg (l r) [property #64 #8 (\(r) (` expr r)) (\(s r) [var r]) l r])

(;; Valid values for expr-type. -----------------------------------------------)

(function -storage- (l r) [mk## #0 (\(r) (` expr-type r)) r])

(function -function- (l r) [mk## #1 (\(r) (` expr-type r)) r])

(function -with- (l r) [mk## #2 (\(r) (` expr-type r)) r])

(function -invoke- (l r) [mk## #3 (\(r) (` expr-type r)) r])

(function -if- (l r) [mk## #4 (\(r) (` expr-type r)) r])

(function -begin- (l r) [mk## #5 (\(r) (` expr-type r)) r])

(function -literal- (l r) [mk## #6 (\(r) (` expr-type r)) r])

(function -symbol- (l r) [mk## #7 (\(r) (` expr-type r)) r])

(function -jump- (l r) [mk## #8 (\(r) (` expr-type r)) r])

(function -continuation- (l r) [mk## #9 (\(r) (` expr-type r)) r])

(function -assembly- (l r) [mk## #10 (\(r) (` expr-type r)) r])

(function -meta- (l r) [mk## #11 (\(r) (` expr-type r)) r])

(function -constrain- (l r) [mk## #12 (\(r) (` expr-type r)) r])

(;; Valid values for expr-contains-flag. -------------------------------------)

(function contains-none (l r) [mk## #0 (\(r) (` expr-contains-flag r)) r])

(function contains-jump (l r) [mk## #1 (\(r) (` expr-contains-flag r)) r])

(function contains-with (l r) [mk## #3 (\(r) (` expr-contains-flag r)) r])

(;; Convenience functions for making L2 expressions. They save you from having
  to construct parameter and argument lists separately from the construction of
  the expression.)

(;; Usage (make-functionN ref-expr (param-exprs ...) expr buf handler))

(function make-functionN (l r)
  [lllllst (` invoke r) (` make-function r) [@fst l] [list [lst [@frst l] [@rrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(;; Analogous to above.)

(function make-continuationN (l r)
  [lllllst (` invoke r) (` make-continuation r) [@fst l] [list [lst [@frst l] [@rrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(;; Usage (make-asmN opcode (arg-exprs ...) buf handler))

(function make-asmN (l r)
  [llllst (` invoke r) (` make-asm r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Analogous to above.)

(function make-jumpN (l r)
  [llllst (` invoke r) (` make-jump r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Analogous to above.)

(function make-invokeN (l r)
  [llllst (` invoke r) (` make-invoke r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(;; Macro takes a reference to an expression as its first argument and an
  expression as its second argument. Produces code to obtain parent of expression
  referenced by first argument, set that to be the parent of the second expression,
  and put the second expression at the address referenced by the first argument.)

(function replace-expression (l r)
  (`(let (replace-expression:orig (,[@fst l]))
    (let (replace-expression:parent (@ expr-parent $replace-expression:orig))
      (let (replace-expression:repl (,[@frst l])) (do
        (setf expr-parent replace-expression:repl replace-expression:parent)
        [set replace-expression:orig replace-expression:repl]))))r))

(;; The meta-expression (put field expr1 expr2) is the same as (setf field expr1 expr2)
  except that it also sets the parent of expr2 to be expr1.)

(function put (l r)
  (`(let (put:parent (,[@frst l])) (put:repl (,[@frrst l])) (do
      (setf (,[@fst l]) put:parent put:repl)
      (setf expr-parent put:repl put:parent)))r))

(;; Constant against which the length of a literal expression is checked.)

(function build-expression-literal-len (l r) [mk# r #64])

(constrain null-expr (\(r) (` expr r)))

(storage null-expr (undefined))

(storage null-binding (undefined))

(constrain make-binding-aug (\(r) (with-vars (a) (`(function (bndg-storage bndg-scope bndg-state string expr buffer ,a) bndg-aug)r)r)))

(function make-binding-aug (type scope state name definition r handler)
  (let (bndg [buffer-alloc (binding-aug) r handler]) (do
    (setf bndg-storage bndg type)
    (setf bndg-scope bndg scope)
    (setf bndg-state bndg state)
    (setf bndg-name bndg name)
    (setf bndg-definition bndg definition)
    bndg)))

(constrain make-literal (\(r) (with-vars (a b) (`(function (,a buffer ,b) expr)r)r)))

(function make-literal (value reg handler)
  (let (t [buffer-alloc (expression) reg handler]) (do
    (setf expr-type t (-literal-))
    (setf expr-parent t null-expr)
    (setf expr-signature t [vbl->frag [vbl reg handler]])
    (setf expr-lowlink t #0)
    (setf expr-dependencies t nil)
    (setf expr-value t value)
    t)))

(constrain make-symbol (\(r) (with-vars (b) (`(function (string buffer ,b) expr)r)r)))

(function make-symbol (name reg handler)
  (let (sym [buffer-alloc (expression) reg handler]) (do
    (setf expr-type sym (-symbol-))
    (setf expr-parent sym null-expr)
    (setf expr-signature sym [vbl->frag [vbl reg handler]])
    (setf expr-lowlink sym #0)
    (setf expr-dependencies sym nil)
    (setf expr-name sym name)
    (setf expr-binding-aug sym null-binding)
    sym)))

(;; Binds a symbol expression to another symbol expression. symbol
  is the expression being bound. target is the symbol expression
  being bound to.)

(constrain bind-symbol (\(r) (`(function (expr expr) ())r)))

(function bind-symbol (symbol target) (setf expr-binding-aug symbol (@ expr-binding-aug target)))

(;; Makes a symbol expression attached to the given augmented binding. bndg is
  the augmented binding to which the symbol will be attached. reg is the buffer
  into which the the symbol expression will be put. Return value is the symbol
  expression.)

(constrain use-binding-aug (\(r) (with-vars (b) (`(function (bndg-aug buffer ,b) expr)r)r)))

(function use-binding-aug (bndg reg handler)
  (let (sym [buffer-alloc (expression) reg handler]) (do
    (setf expr-type sym (-symbol-))
    (setf expr-parent sym null-expr)
    (setf expr-name sym (@ bndg-name bndg))
    (setf expr-binding-aug sym bndg)
    sym)))

(constrain make-begin (\(r) (with-vars (b) (`(function ((list expr) buffer ,b) expr)r)r)))

(function make-begin (expressions reg handler)
  (let (beg [buffer-alloc (expression) reg handler]) (do
    (setf expr-type beg (-begin-))
    (setf expr-parent beg null-expr)
    (setf expr-signature beg [vbl->frag [vbl reg handler]])
    (setf expr-lowlink beg #0)
    (setf expr-dependencies beg nil)
    (setf expr-expressions beg expressions)
    (foreach (expr expressions) (setf expr-parent expr beg))
    beg)))

(constrain make-function (\(r) (with-vars (b) (`(function (expr (list expr) expr buffer ,b) expr)r)r)))

(function make-function (ref params expr reg handler)
  (substitute (.. reg handler) (let (func [buffer-alloc (expression) ..]) (do
    (setf expr-type func (-function-))
    (setf expr-parent func null-expr)
    (setf expr-signature func [vbl->frag [vbl reg handler]])
    (setf expr-lowlink func #0)
    (setf expr-dependencies func nil)
    (put expr-reference func ref)
    (setf expr-binding-aug ref [make-binding-aug (absolute-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-parameters func params)
    (foreach (param params) (do
      (setf expr-parent param func)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])))
    (setf expr-binding-augs func nil)
    (put expr-expression func expr)
    func))))

(constrain make-continuation (\(r) (with-vars (b) (`(function (expr (list expr) expr buffer ,b) expr)r)r)))

(function make-continuation (ref params expr reg handler)
  (substitute (.. reg handler) (let (cont [buffer-alloc (expression) ..]) (do
    (setf expr-type cont (-continuation-))
    (setf expr-parent cont null-expr)
    (setf expr-signature cont [vbl->frag [vbl reg handler]])
    (setf expr-lowlink cont #0)
    (setf expr-dependencies cont nil)
    (setf expr-cont-instr-bndg cont [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (put expr-reference cont ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-parameters cont params)
    (foreach (param params) (do
      (setf expr-parent param cont)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])))
    (setf expr-escapes cont (false))
    (put expr-expression cont expr)
    cont))))

(constrain make-with (\(r) (with-vars (b) (`(function (expr expr buffer ,b) expr)r)r)))

(function make-with (ref expr reg handler)
  (substitute (.. reg handler) (let (wth [buffer-alloc (expression) ..]) (do
    (setf expr-type wth (-with-))
    (setf expr-parent wth null-expr)
    (setf expr-signature wth [vbl->frag [vbl reg handler]])
    (setf expr-lowlink wth #0)
    (setf expr-dependencies wth nil)
    (setf expr-cont-instr-bndg wth [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (put expr-reference wth ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (let (param [make-symbol null-string ..]) (do
      (setf expr-parent param wth)
      (setf expr-binding-aug param [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name param) param ..])
      (setf expr-parameters wth [cons param nil ..])))
    (setf expr-escapes wth (false))
    (put expr-expression wth expr)
    wth))))

(constrain make-asm (\(r) (with-vars (b) (`(function (expr-code (list expr) buffer ,b) expr)r)r)))

(function make-asm (code arguments reg handler)
  (let (u [buffer-alloc (expression) reg handler]) (do
    (setf expr-type u (-assembly-))
    (setf expr-code u code)
    (setf expr-arguments u arguments)
    (foreach (arg arguments) (setf expr-parent arg u))
    u)))

(constrain make-jump (\(r) (with-vars (b) (`(function (expr (list expr) buffer ,b) expr)r)r)))

(function make-jump (ref args reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-jump-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (setf expr-short-circuit u null-expr)
    (put expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string u ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    u))))

(constrain make-storage (\(r) (with-vars (b) (`(function (expr (list expr) buffer ,b) expr)r)r)))

(function make-storage (ref args reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-storage-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (put expr-reference u ref)
    (setf expr-binding-aug ref [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) (@ expr-name ref) ref ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    u))))

(constrain make-meta (\(r) (with-vars (a b) (`(function (expr ,a buffer ,b) expr)r)r)))

(function make-meta (ref arg reg handler)
  (let (u [buffer-alloc (expression) reg handler]) (do
    (setf expr-type u (-meta-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (put expr-reference u ref)
    (setf expr-argument u arg)
    u)))

(constrain make-constrain (\(r) (with-vars (b) (`(function (expr expr buffer ,b) expr)r)r)))

(function make-constrain (expr ref reg handler)
  (let (u [buffer-alloc (expression) reg handler]) (do
    (setf expr-type u (-constrain-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (put expr-reference u ref)
    (put expr-expression u expr)
    u)))

(constrain make-if (\(r) (with-vars (b) (`(function (expr expr expr buffer ,b) expr)r)r)))

(function make-if (condition consequent alternate reg handler)
  (let (u [buffer-alloc (expression) reg handler]) (do
    (setf expr-type u (-if-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (put expr-condition u condition)
    (put expr-consequent u consequent)
    (put expr-alternate u alternate)
    u)))

(constrain make-invoke (\(r) (with-vars (b) (`(function (expr (list expr) buffer ,b) expr)r)r)))

(function make-invoke (ref args reg handler)
  (substitute (.. reg handler) (let (u [buffer-alloc (expression) ..]) (do
    (setf expr-type u (-invoke-))
    (setf expr-parent u null-expr)
    (setf expr-signature u [vbl->frag [vbl reg handler]])
    (setf expr-lowlink u #0)
    (setf expr-dependencies u nil)
    (put expr-reference u ref)
    (setf expr-contains-flag u (contains-with))
    (setf expr-temp-storage-bndg u [make-binding-aug (frame-relative-storage) (local-scope) (defined-state) null-string u ..])
    (setf expr-arguments u args)
    (foreach (arg args) (setf expr-parent arg u))
    u))))

(;; Builds a program from a list of expressions. exprs is the list of expressions
  from which the program will be built. A program is a function with no parent that
  has as its expression a begin expression.)

(constrain make-program (\(r) (with-vars (b) (`(function ((list expr) buffer ,b) expr)r)r)))

(function make-program (exprs r handler)
  (substitute (.. r handler)
    (let (program [make-function [make-symbol null-string ..] nil [make-begin exprs ..] ..]) (do
      (setf expr-parent program null-expr)
      (foreach (expr exprs)
        (if (or [= (@ expr-type expr) (-function-)] [= (@ expr-type expr) (-storage-)])
          (setf bndg-scope (@ expr-binding-aug(@ expr-reference expr)) (global-scope))
          (undefined)))
      program))))

(;; Prints the given expression as it would be written in an L2 source file.
  s is an expression.)

(constrain print-expression (\(r) (with-vars (a) (`(function (expr ,a) ())r)r)))

(function print-expression (s hdl) (substitute (.. hdl)
  (switch = (@ expr-type s)
    ((-begin-) (do
      [print-str (stdout) (" (lparen)begin(space)) ..]
      (foreach (t (@ expr-expressions s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)(rparen)) ..]))
    
    ((-with-) (do
      [print-str (stdout) (" (lparen)with(space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-invoke-) (-jump-) (-storage-) (do
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (lbracket)))
        ((-jump-) (" (lbrace)))
        (" (lparen)storage(space))) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      (foreach (t (@ expr-arguments s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-function-) (-continuation-) (do
      [print-str (stdout) (" (lparen)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-function-) (" function))
        (" continuation)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)(lparen)(space)) ..]
      (foreach (t (@ expr-parameters s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (rparen)(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    ((-if-) (do
      [print-str (stdout) (" (lparen)if(space)) ..]
      [print-expression (@ expr-condition s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-consequent s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-alternate s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-constrain-) (do
      [print-str (stdout) (" (lparen)constrain(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment (@ expr-signature s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-symbol-)
      (if [not= (@ expr-name s) null-string]
        [print-str (stdout) (@ expr-name s) ..]
        (do
          [print-str (stdout) (" (lparen)reference(space)) ..]
          [print-uint (stdout) (@ expr-binding-aug s) ..]
          [print-str (stdout) (" (rparen)) ..])))
          
    ((-literal-) (do
      [print-str (stdout) (" (lparen)literal(space)) ..]
      [print-uint (stdout) (@ expr-value s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-meta-) (do
      [print-str (stdout) (" (lparen)) ..]
      [print-expression (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment [list->fragment (@ expr-argument s)] ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    (undefined))))

(storage special-form-error (undefined))

(;; Builds an expression from a given program fragment. d is the program fragment.
  reg is the buffer into which the built expressions will be put. The return value
  is the constructed expression. The continuation handler will be followed, and
  buffer reference by err set to the tuple (special-form-error, ...) in the event
  of a malformed expression.)

(constrain build-expression (\(r) (with-vars (a) (`(function (frag buffer ,a) expr)r)r)))

(function build-expression (d reg handler) (substitute (.. reg handler)
  (if [i/f:token? d] [make-symbol [to-string [fragment->token d] ..] ..]
  (let (d [frag->list d])
    (if [= [length d] #0] {handler (storage _ special-form-error d null-fragment)}
    (switch str= [to-string [fragment->token [@car d]] ..]
      ((" with)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
          [make-with [build-expression [@cadr d] ..] [build-expression [@caddr d] ..] ..])))
      
      ((" begin) [make-begin [reverse (reverse-map (v [@cdr d]) [build-expression v ..] ..) ..] ..])
      
      ((" if)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
          [make-if [build-expression [@cadr d] ..] [build-expression [@caddr d] ..] [build-expression [@cadddr d] ..] ..]))
      
      ((" function) (" continuation)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
        (if [i/f:token? [@caddr d]]
          {handler (storage _ special-form-error d [@caddr d])}
          (let (parameters [reverse (reverse-map (v [frag->list [@caddr d]])
              (if [i/f:token? v]
                [build-expression v ..]
                {handler (storage _ special-form-error d v)}) ..) ..])
                
            [(switch str= [to-string [fragment->token [@car d]] ..]
                ((" function) make-function)
                make-continuation)
              [build-expression [@cadr d] ..] parameters [build-expression [@cadddr d] ..] ..])))))
      
      ((" invoke) (" jump) (" storage)
        (if [= [length d] #1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (and [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f:token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [(switch str= [to-string [fragment->token [@car d]] ..]
              ((" invoke) make-invoke)
              ((" jump) make-jump)
              make-storage)
            [build-expression [@cadr d] ..] [reverse (reverse-map (v [@cddr d]) [build-expression v ..] ..) ..] ..])))
      
      ((" literal)
        (if (not [= [length d] #2])
          {handler (storage _ special-form-error d null-fragment)}
        (if (or (not [i/f:token? [@cadr d]]) (not [= [length [frag->list [@cadr d]]] (build-expression-literal-len)]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-literal
            (loop build-num (str [to-string [fragment->token [@cadr d]] ..]) (i (build-expression-literal-len)) (value #0)
              (if [= i #0]
                value
              (if [= [getb str] (char 1)]
                {build-num [+ str #1] [- i #1] [+ [<< value #1] #1]}
              (if [= [getb str] (char 0)]
                {build-num [+ str #1] [- i #1] [<< value #1]}
                {handler (storage _ special-form-error d [@cadr d])})))) ..])))
      
      ((" constrain)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
          [make-constrain [build-expression [@cadr d] ..] [build-expression [@caddr d] ..] ..]))
      
      [make-meta [build-expression [@car d] ..] [@cdr d] ..]))))))

