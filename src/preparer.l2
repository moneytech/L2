(function defined-str= (a b) (and [not= a null-string] [not= b null-string] [str= a b]))

(function named-sym= (a b) [defined-str= (@ expr-name a) (@ expr-name b)])

(storage multiple-definition-error (ignore))

(constrain vfind-multiple-definitions (\ r (with-vars (a) (`(function (expr (values ,a)) expr)r)r)))

(function vfind-multiple-definitions (e ctx)
  (bind ctx (handler) (do
    (switch = (@ expr-type e)
      ((-continuation-) (-function-)
        (let (temp-reg [create-buffer #0 handler])
        (let (ref-with-params [cons (@ expr-reference e) (@ expr-parameters e) temp-reg handler]) (do
        (until (partial ref-with-params) [nil? partial] [@cdr partial]
          (if [nil? (find (f (@ cdr partial)) [named-sym= f [@car partial]])] (ignore)
            (let (dup-ref-name (@ expr-name[@car partial])) (do
            [destroy-buffer temp-reg handler]
            {handler (storage _ multiple-definition-error dup-ref-name)}))))
        [destroy-buffer temp-reg handler]))))
      
      (ignore))
    e)))

(constrain global-binding-augs-of (\ r (with-vars (a) (`(function ((list expr) buffer ,a) (list bndg-aug))r)r)))

(function global-binding-augs-of (exprs r handler)
  (loop add-binding (binding-augs nil) (exprs exprs)
    (if [nil? exprs]
      binding-augs
      (let (t [@car exprs])
        (if (or [= (@ expr-type t) (-function-)] [= (@ expr-type t) (-storage-)])
          (do
            (setf bndg-scope (@ expr-binding-aug (@ expr-reference t)) (global-scope))
            {add-binding [cons (@ expr-binding-aug (@ expr-reference t)) binding-augs r handler] [@cdr exprs]})
          {add-binding binding-augs [@cdr exprs]})))))

(constrain vunlink-symbols (\ r (`(function (expr (values (list bndg-aug))) expr)r)))

(function vunlink-symbols (s ctx)
  (bind ctx (blacklist)
    (if (and [= (@ expr-type s) (-symbol-)] (not [nil? (find (x blacklist) [= x (@ expr-binding-aug s)])]))
      (do (setf expr-binding-aug s null-binding) s)
      s)))

(constrain assign-binding (\ r (with-vars (a) (`(function (expr (list bndg-aug)) ,a)r)r)))

(function assign-binding (s bindings)
  (loop find (bindings bindings)
    (if [nil? bindings]
      (false)
      (let (ba [@car bindings])
        (if (and [not= (@ bndg-name ba) null-string] [not= (@ expr-name s) null-string]
            [str= (@ bndg-name ba) (@ expr-name s)])
          (do (setf expr-binding-aug s ba) (true))
          {find [@cdr bindings]})))))

(constrain link-symbols
  (\ r (with-vars (a b) (`(function (expr ,a (ref (list bndg-aug)) (list bndg-aug) (list bndg-aug) buffer ,b) ())r)r)))

(function link-symbols (s static-storage undefined-bindings static-bindings dynamic-bindings r handler)
  (substitute (.. r handler)
    (let (statics-ref (storage _ static-bindings))
    (let (dynamics-ref (storage _ dynamic-bindings))
    (let (bindings-ref (if static-storage statics-ref dynamics-ref))
    
    (switch = (@ expr-type s)
      ((-function-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) statics-ref ..]
        [set dynamics-ref nil]
        (foreach (u (@ expr-parameters s)) [prepend (@ expr-binding-aug u) dynamics-ref ..])
        [link-symbols (@ expr-expression s) (false) undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-with-) (-continuation-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) bindings-ref ..]
        (foreach (u (@ expr-parameters s)) [prepend (@ expr-binding-aug u) bindings-ref ..])
        [link-symbols (@ expr-expression s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-storage-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) bindings-ref ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings $statics-ref $dynamics-ref ..])))
      
      ((-symbol-)
        (if (and [= (@ expr-binding-aug s) null-binding] (not [assign-binding s $dynamics-ref])
            (not [assign-binding s $statics-ref]) (not [assign-binding s $undefined-bindings]))
          (let (stg [make-storage [make-symbol (@ expr-name s) null-frag null-expr ..] nil null-frag null-expr ..])
          (let (bndg (@ expr-binding-aug (@ expr-reference stg))) (do
          (setf bndg-storage bndg (absolute-storage))
          (setf bndg-scope bndg (global-scope))
          (setf bndg-state bndg (undefined-state))
          (setf expr-binding-aug s bndg)
          [prepend (@ expr-binding-aug s) undefined-bindings ..])))
          (ignore)))
      
      ((-if-) (do
        [link-symbols (@ expr-condition s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        [link-symbols (@ expr-consequent s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        [link-symbols (@ expr-alternate s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-invoke-) (-jump-) (do
        [link-symbols (@ expr-reference s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings $statics-ref $dynamics-ref ..])))
      
      ((-constrain-)
        [link-symbols (@ expr-expression s) static-storage undefined-bindings $statics-ref $dynamics-ref ..])
      
      (ignore)))))))

(constrain escape-analysis (\ r (with-vars (a) (`(function (expr ,a) ())r)r)))

(function escape-analysis (s escaping)
  (switch = (@ expr-type s)
    ((-symbol-)
      (let (target-expr (@ bndg-expression (@ expr-binding-aug s)))
        (if (and escaping (or [= (@ expr-type target-expr) (-continuation-)] [= (@ expr-type target-expr) (-with-)])
            [= (@ expr-reference target-expr) (@ bndg-symbol (@ expr-binding-aug s))])
          (setf expr-escapes target-expr escaping)
          (ignore))))
    
    ((-if-) (do
      [escape-analysis (@ expr-condition s) (true)]
      [escape-analysis (@ expr-consequent s) (true)]
      [escape-analysis (@ expr-alternate s) (true)]))
    
    ((-function-) (-continuation-) (-with-) (do
      (if (and escaping [= (@ expr-type s) (-continuation-)])
        (setf expr-escapes s escaping)
        (ignore))
      [escape-analysis (@ expr-expression s) (true)]))
    
    ((-storage-) (-jump-) (-invoke-) (do
      (if [= (@ expr-type s) (-jump-)] (do
        (if [= (@ expr-type (@ expr-reference s)) (-symbol-)]
          (let (target-expr (@ bndg-expression (@ expr-binding-aug (@ expr-reference s))))
          (if (and (or [= (@ expr-type target-expr) (-continuation-)] [= (@ expr-type target-expr) (-with-)])
              [= (@ expr-reference target-expr) (@ bndg-symbol (@ expr-binding-aug (@ expr-reference s)))])
            (setf expr-short-circuit s target-expr)
            (ignore)))
        (if [= (@ expr-type (@ expr-reference s)) (-continuation-)]
          (setf expr-short-circuit s (@ expr-reference s))
          (ignore)))
        [escape-analysis (@ expr-reference s) (false)])
      (if [= (@ expr-type s) (-invoke-)]
        [escape-analysis (@ expr-reference s) (true)]
        (ignore)))
      (foreach (t (@ expr-arguments s)) [escape-analysis t (true)])))
    
    ((-constrain-) [escape-analysis (@ expr-expression s) (true)])
    
    (ignore)))

(constrain vfind-dependencies (\ r (with-vars (a) (`(function (expr (values buffer ,a)) expr)r)r)))

(function vfind-dependencies (s ctx)
  (bind ctx (r handler) (substitute (.. r handler) (do
    (switch = (@ expr-type s)
      ((-if-) (do
        [prepend (@ expr-condition s) (& expr-dependencies s) ..]
        [prepend (@ expr-consequent s) (& expr-dependencies s) ..]
        [prepend (@ expr-alternate s) (& expr-dependencies s) ..]))
      
      ((-function-) (-continuation-) (-with-)
        [prepend (@ expr-expression s) (& expr-dependencies s) ..])
      
      ((-storage-) (-jump-) (-invoke-) (do
        [prepend (@ expr-reference s) (& expr-dependencies s) ..]
        (foreach (t (@ expr-arguments s)) [prepend t (& expr-dependencies s) ..])))
      
      ((-symbol-)
        (let (target-expr (@ bndg-expression (@ expr-binding-aug s))) (do
        [prepend target-expr (& expr-dependencies s) ..]
        [prepend s (& expr-dependencies target-expr) ..])))
      
      ((-constrain-) (do
        [prepend (@ expr-expression s) (& expr-dependencies s) ..]
        [prepend s (& expr-dependencies (@ expr-expression s)) ..]))
      
      (ignore))
    s))))

(constrain construct-sccs (\ r (with-vars (a b) (`(function (expr ,a (ref (list expr)) (ref (list (list expr))) buffer ,b) ())r)r)))

(function construct-sccs (s preorder stack sccs r handler)
  (substitute (.. r handler)
    (if [= (@ expr-lowlink s) #0]
      (let (marker $stack) (do
      (setf expr-lowlink s preorder)
      (foreach (t (@ expr-dependencies s)) (do
        [construct-sccs t [+ preorder #1] stack sccs ..]
        (if [< (@ expr-lowlink t) (@ expr-lowlink s)]
          (setf expr-lowlink s (@ expr-lowlink t))
          (ignore))))
      [prepend s stack ..]
      
      (if [= (@ expr-lowlink s) preorder] (do
        [prepend (loop add (t $stack) (scc nil)
          (if [= t marker] scc
            (let (u [@car t]) (do
            (setf expr-lowlink u [- #0 #1])
            {add [@cdr t] [cons u scc ..]})))) sccs ..]
        [set stack marker])
        (ignore))))
      (ignore))))

(constrain occurs-in? (\ r (with-vars (a) (`(function (vbl frag) ,a)r)r)))

(function occurs-in? (var val)
  (let (eval [evaluate val])
    (if [vbl? eval]
      [vbl= var [frag->vbl eval]]
    (if [i/f:token? eval]
      (false)
      (not [nil? (find (a [frag->list eval]) [occurs-in? var a])])))))

(constrain unify-var (\ r (with-vars (a) (`(function (vbl frag) ,a)r)r)))

(function unify-var (var val)
  (if (not [occurs-in? var val])
    (do [set-val var val] (true))
    (false)))

(constrain unify (\ r (with-vars (a) (`(function (frag frag) ,a)r)r)))

(function unify (x y)
  (let (xl [evaluate x]) (yl [evaluate y])
    (if (and [vbl? xl] [vbl? yl] [vbl= [frag->vbl xl] [frag->vbl yl]]) (true)
    (if [vbl? xl] [unify-var [frag->vbl xl] yl]
    (if [vbl? yl] [unify-var [frag->vbl yl] xl]
    (if (and [i/f:token? xl] [i/f:token? yl]) [i/f:token= [fragment->token xl] [fragment->token yl]]
    (if (or [i/f:token? xl] [i/f:token? yl]) (false)
    (let (xl [frag->list xl]) (yl [frag->list yl])
      (if [= [length xl] [length yl]]
        (loop do-unify (xl xl) (yl yl)
          (if [nil? xl]
            (true)
          (if (not [unify [@car xl] [@car yl]])
            (false)
            {do-unify [@cdr xl] [@cdr yl]})))
        (false))))))))))

(constrain scoped-signature (\ r (with-vars (a) (`(function (expr (list expr) buffer ,a) frag)r)r)))

(function scoped-signature (e scc r handler)
  (if (not [nil? (find (x scc) [= x e])])
    (@ expr-signature e)
    [copy-fragment (@ expr-signature e) (storage _ nil) (storage _ nil) r handler]))

(storage unification-error (ignore))

(constrain infer-types (\ r (with-vars (a) (`(function ((list expr) buffer ,a) ())r)r)))

(function infer-types (exprs buf handler)
  (substitute (.. buf handler) (do
    (ignore Type inferencing is done on strongly connected components)
    (let (stack (storage _ nil))
    (let (sccs (storage _ nil)) (do
    (foreach (expr exprs) [visit-expressions vfind-dependencies (storage _ expr) (values ..)])
    (foreach (expr exprs) [construct-sccs expr #1 stack sccs ..])
    
    (foreach (scc [reverse $sccs ..]) (do
      (foreach (e scc) (let (equations
          (let (function-token [token->fragment [build-token (" function) ..]])
          (let (continuation-token [token->fragment [build-token (" continuation) ..]])
          (switch = (@ expr-type e)
            ((-function-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (x (@ expr-parameters e)) (@ expr-signature x) ..) ..]])
              (list
                ((values (@ expr-signature e) [list->fragment [cons function-token [cons params-signature
                  [cons (@ expr-signature (@ expr-expression e)) nil ..] ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-reference e)))) ..)))
            
            ((-continuation-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (x (@ expr-parameters e)) (@ expr-signature x) ..) ..]])
              (list
                ((values (@ expr-signature e) [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-reference e)))) ..)))
            
            ((-constrain-)
              (list ((values (@ expr-signature e) (@ expr-signature (@ expr-expression e)))) ..))
            
            ((-invoke-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..) ..]])
              (list
                ((values [scoped-signature (@ expr-reference e) scc ..]
                  [list->fragment [cons function-token [cons params-signature [cons (@ expr-signature e) nil ..] ..] ..]])) ..)))
            
            ((-jump-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..) ..]])
              (list
                ((values [scoped-signature (@ expr-reference e) scc ..]
                  [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])) ..)))
            
            ((-with-)
              (let (params-signature [list->fragment [cons (@ expr-signature e) nil ..]])
              (list
                ((values (@ expr-signature (@ expr-reference e))
                  [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-expression e)))) ..)))
            
            ((-if-)
              (let (consequent-sig [scoped-signature (@ expr-consequent e) scc ..])
              (let (alternate-sig [scoped-signature (@ expr-alternate e) scc ..])
              (list ((values consequent-sig alternate-sig) (values (@ expr-signature e) consequent-sig)) ..))))
            
            ((-symbol-)
              (list ((values (@ expr-signature e) (@ expr-signature (@ bndg-symbol (@ expr-binding-aug e))))) ..))
            
            nil))))
        
        (foreach (equ equations)
          (bind equ (lhs rhs)
            (if [unify lhs rhs] (ignore)
              {handler (storage _ unification-error [recursive-evaluate lhs ..] [recursive-evaluate rhs ..] e)})))))
      
      (foreach (e scc) (setf expr-signature e [recursive-evaluate (@ expr-signature e) ..]))))))))))

(constrain visit-expressions (\ r (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function visit-expressions (visitor s ctx) (do
  (switch = (@ expr-type $s)
    ((-if-) (do
      [visit-expressions visitor (& expr-condition $s) ctx]
      [visit-expressions visitor (& expr-consequent $s) ctx]
      [visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (do
      (if [= (@ expr-type $s) (-storage-)] (ignore) [visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx])))
    
    (ignore))
  [set s [visitor $s ctx]]))

(constrain pre-visit-expressions (\ r (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function pre-visit-expressions (visitor s ctx) (do
  [set s [visitor $s ctx]]
  
  (switch = (@ expr-type $s)
    ((-if-) (do
      [pre-visit-expressions visitor (& expr-condition $s) ctx]
      [pre-visit-expressions visitor (& expr-consequent $s) ctx]
      [pre-visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [pre-visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (do
      (if [= (@ expr-type $s) (-storage-)] (ignore) [pre-visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx])))
    
    (ignore))))

(constrain classify-program-bindings (\ r (`(function (expr) ())r)))

(function classify-program-bindings (expr)
  (switch = (@ expr-type expr)
    ((-constrain-) [classify-program-bindings (@ expr-expression expr)])
    
    ((-storage-) (-jump-) (-invoke-) (do
      (if [= (@ expr-type expr) (-storage-)]
        (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
        (do
          (setf bndg-storage (@ expr-temp-storage-bndg expr) (absolute-storage))
          [classify-program-bindings (@ expr-reference expr)]))
      (foreach (t (@ expr-arguments expr)) [classify-program-bindings t])))
    
    ((-continuation-) (-with-) (do
      (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
      (foreach (t (@ expr-parameters expr)) (setf bndg-storage (@ expr-binding-aug t) (absolute-storage)))
      [classify-program-bindings (@ expr-expression expr)]))
    
    ((-if-) (do
      [classify-program-bindings (@ expr-condition expr)]
      [classify-program-bindings (@ expr-consequent expr)]
      [classify-program-bindings (@ expr-alternate expr)]))
    
    (ignore)))

(constrain containment-analysis (\ r (`(function (expr) expr-contains-flag)r)))

(function containment-analysis (s)
  (switch = (@ expr-type s)
    ((-constrain-) [containment-analysis (@ expr-expression s)])
    
    ((-if-)
      (let (condition-flag [containment-analysis (@ expr-condition s)])
          (consequent-flag [containment-analysis (@ expr-consequent s)])
          (alternate-flag [containment-analysis (@ expr-alternate s)])
        (if [= [+ consequent-flag alternate-flag] #1]
          (contains-with)
          [lor condition-flag [lor consequent-flag alternate-flag]])))
    
    ((-function-) (-continuation-) (-with-) (do
      [containment-analysis (@ expr-expression s)]
      (if [= (@ expr-type s) (-with-)] (contains-with) (contains-none))))
    
    ((-storage-) (fold (acc (contains-none)) (x (@ expr-arguments s)) [lor acc [containment-analysis x]]))
    
    ((-jump-) (-invoke-)
      (let (contains-flag (fold (acc [containment-analysis (@ expr-reference s)]) (x (@ expr-arguments s))
          [lor acc [containment-analysis x]])) (do
        (setf expr-contains-flag s contains-flag)
        (if [= (@ expr-type s) (-jump-)] (contains-jump) contains-flag))))
    
    (contains-none)))

(storage undefined-symbol-error (ignore))

(function preprocessed-expression-address (l r)
  (`(\ s bindings buf handler
    (substitute (.. buf handler)
      (if [= (@ expr-type s) (-symbol-)]
        (do
          (ignore
            If the expression, s, is a mere symbol, then we can just lookup its value in
            the bindings list instead of preprocessing, compiling, and then evaluating
            the expression.)
          (loop find-binding (bindings bindings)
            (if [nil? bindings]
              {handler (storage _ undefined-symbol-error (@ expr-name s))}
              (let (bndg [@car bindings])
                (if [str= (@ bndg-name bndg) (@ expr-name s)]
                  (@ bndg-offset bndg)
                  {find-binding [@cdr bindings]})))))
        (do
          (let (expr-container [make-function [make-symbol null-string null-frag null-expr ..] nil s null-frag null-expr ..])
          (let (exprs-preprocessed [generate-metaprogram [cons expr-container nil ..] (storage _ bindings) buf handler]) (do
          [load-program-and-mutate exprs-preprocessed bindings buf handler]
          (let (expr-container-preprocessed [@car exprs-preprocessed])
          [(@ bndg-offset (@ expr-binding-aug (@ expr-reference expr-container-preprocessed)))]))))))))r))

(ignore
  This function replaces meta-expressions with the code generated by calling the
  corresponding expression builder. It also sets the signatures of constrain-expressions
  to the result of evaluating a signature builder.)

(constrain vgenerate-metas (\ r (with-vars (a) (`(function (expr (values (list bndg-aug) buffer ,a)) expr)r)r)))

(function vgenerate-metas (s ctx)
  (bind ctx (bindings buf handler)
    (switch = (@ expr-type s)
      ((-meta-)
        (let (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
          [vgenerate-metas [build-expression [macro [list->fragment [@cdr [frag->list (@ expr-fragment s)]]] buf] s buf handler] ctx]))
      
      ((-constrain-)
        (let (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
          (do (setf expr-signature s [macro buf]) s)))
      
      s)))

(constrain init-function (\ r (with-vars (a b) (`(function (expr (ref (list bndg-aug)) buffer ,a (ref ,b)) ,b)r)r)))

(function init-function (function-expr bindings buf handler cache)
  (substitute (.. buf handler)
    (if [not= $cache null-cache]
      $cache
      (let (function-expr-ref (storage _ function-expr)) (do
        [pre-visit-expressions vgenerate-metas function-expr-ref (values $bindings ..)]
        [load-program-and-mutate [cons $function-expr-ref nil ..] $bindings buf handler]
        [set cache (@ bndg-offset (@ expr-binding-aug (@ expr-reference $function-expr-ref)))]
        $cache)))))

(storage null-cache (ignore))

(ignore
  From the supplied list of expressions, returns lazy versions of the
  contained functions. That is, the meta-expressions within the functions are
  expanded only when they are first called.)

(constrain generate-metaprogram (\ r (with-vars (a) (`(function ((list expr) (ref (list bndg-aug)) buffer ,a) (list expr))r)r)))

(function generate-metaprogram (exprs bindings buf handler)
  (substitute (.. buf handler)
    [reverse (fold (c nil) (s exprs)
      (let (cache [buffer-alloc (unit) buf handler]) (do
        [set cache null-cache]
        
        (if [= (@ expr-type s) (-function-)]
          (let (params (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string null-fragment null-expr ..] ..))
          (let (args (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string null-fragment null-expr ..] ..))
          (let (thunk [make-function [make-symbol (@ expr-name (@ expr-reference s)) null-fragment null-expr ..] params
            [make-invoke (make-invokeN [make-literal init-function null-fragment null-expr ..]
            ([make-literal s null-fragment null-expr ..] [make-literal bindings null-fragment null-expr ..]
            [make-literal buf null-fragment null-expr ..] [make-literal handler null-fragment null-expr ..]
            [make-literal cache null-fragment null-expr ..]) null-fragment null-expr ..) args null-fragment null-expr ..]
            null-fragment null-expr ..]) (do
          (foreach (a params) (t args) [bind-symbol t a])
          [cons thunk c ..]))))
        
          c)))) ..]))

