(function defined-str= (a b) (and [not= a null-string] [not= b null-string] [str= a b]))

(function named-sym= (a b) [defined-str= (@ expr-name a) (@ expr-name b)])

(storage multiple-definition-error (begin))

(constrain vfind-multiple-definitions (\(r) (with-vars (a) (`(function (expr ,a) expr)r)r)))

(function vfind-multiple-definitions (e ctx) (with return (begin
  (define (handler (@0 ctx))
  
  (switch = (@ expr-type e)
    ((-begin-) (begin
      (define (temp-reg [create-buffer #0 handler])
      (define (definitions (reverse-filter (f (@ expr-expressions e))
          (or [= (@ expr-type f) (-storage-)] [= (@ expr-type f) (-function-)]) temp-reg handler))
      (until (partial definitions) [nil? partial] [@cdr partial] (with break (begin
        (find (f (@ cdr partial)) [named-sym= (@ expr-reference f) (@ expr-reference [@car partial])] {break (begin)})
        (define (dup-ref-name (@ expr-name(@ expr-reference[@car partial])))
        [destroy-buffer temp-reg handler]
        {handler (storage _ multiple-definition-error dup-ref-name)}))))
      [destroy-buffer temp-reg handler]))))
    
    ((-continuation-) (-function-) (begin
      (define (temp-reg [create-buffer #0 handler])
      (define (ref-with-params [cons (@ expr-reference e) (@ expr-parameters e) temp-reg handler])
      (until (partial ref-with-params) [nil? partial] [@cdr partial] (with break (begin
        (find (f (@ cdr partial)) [named-sym= f [@car partial]] {break (begin)})
        (define (dup-ref-name (@ expr-name[@car partial]))
        [destroy-buffer temp-reg handler]
        {handler (storage _ multiple-definition-error dup-ref-name)}))))
      [destroy-buffer temp-reg handler]))))
    
    (begin))
    {return e}))))

(constrain get-parent-function (\(r) (`(function (expr) expr)r)))

(function get-parent-function (n)
  (loop move-up (n (@ expr-parent n))
    (if [= (@ expr-type n) (-function-)]
      n
      {move-up (@ expr-parent n)})))

(function binding-of (symbol) (with return (begin
  (storage same-func (true))
  (until (t symbol) [= t null-expr] (@ expr-parent t)
    (switch = (@ expr-type t)
      ((-begin-) (foreach (u (@ expr-expressions t))
        (if (and (or [= (@ expr-type u) (-function-)] (and [= (@ expr-type u) (-storage-)] (or $same-func
            [= (@ bndg-storage(@ expr-binding-aug(@ expr-reference u))) (absolute-storage)])))
            [named-sym= (@ expr-reference u) symbol])
          {return (@ expr-binding-aug(@ expr-reference u))}
          (begin))))
      
      ((-function-) (begin
        (if [named-sym= (@ expr-reference t) symbol]
          {return (@ expr-binding-aug(@ expr-reference t))}
          (foreach (u (@ expr-parameters t))
            (if (and (or $same-func [= (@ bndg-storage(@ expr-binding-aug u)) (absolute-storage)]) [named-sym= u symbol])
              {return (@ expr-binding-aug u)}
              (begin))))
        [set same-func (false)]))
      
      ((-continuation-) (-with-) (-storage-)
        (if (and (or $same-func [= (@ bndg-storage(@ expr-binding-aug(@ expr-reference t))) (absolute-storage)])
            [named-sym= (@ expr-reference t) symbol])
          {return (@ expr-binding-aug(@ expr-reference t))}
        (if [= (@ expr-type t) (-storage-)] (begin)
          (foreach (u (@ expr-parameters t))
            (if (and (or $same-func [= (@ bndg-storage(@ expr-binding-aug u)) (absolute-storage)]) [named-sym= u symbol])
              {return (@ expr-binding-aug u)}
              (begin))))))
      
      (begin)))
  {return null-binding})))

(function jump-reference? (s) (and [= (@ expr-type(@ expr-parent s)) (-jump-)] [= (@ expr-reference(@ expr-parent s)) s]))

(function invoke-reference? (s) (and [= (@ expr-type(@ expr-parent s)) (-invoke-)] [= (@ expr-reference(@ expr-parent s)) s]))

(function function-reference? (s) (and [= (@ expr-type(@ expr-parent s)) (-function-)] [= (@ expr-reference(@ expr-parent s)) s]))

(function c-reference? (s)
  (and (or [= (@ expr-type(@ expr-parent s)) (-continuation-)] [= (@ expr-type(@ expr-parent s)) (-with-)])
    [= (@ expr-reference(@ expr-parent s)) s]))

(function get-target-expression (s) (@ expr-parent(@ bndg-definition(@ expr-binding-aug s))))

(function get-root-function (s)
  (loop move-up (s s) (parent (@ expr-parent s))
    (if [not= parent null-expr]
      {move-up parent (@ expr-parent parent)}
      s)))

(storage param-count-mismatch-error (begin))

(function vlink-symbols (s ctx) (with return (begin
  (define (handler (@1 ctx))
  (define (r (@0 ctx))
  
  (substitute (.. r handler)
    (if [= (@ expr-type s) (-symbol-)]
      (begin
        (setf expr-binding-aug s (if [not= (@ expr-binding-aug s) null-binding] (@ expr-binding-aug s) [binding-of s]))
        (if [= (@ expr-binding-aug s) null-binding]
          (begin
            (define (stg [make-storage [make-symbol (@ expr-name s) ..] nil ..])
            (define (bndg (@ expr-binding-aug(@ expr-reference stg)))
            (setf bndg-storage bndg (absolute-storage))
            (setf bndg-scope bndg (global-scope))
            (setf bndg-state bndg (undefined-state))
            (define (rf [get-root-function s])
            [prepend stg (& expr-expressions(@ expr-expression rf)) ..]
            (setf expr-parent stg (@ expr-expression rf))
            (setf expr-binding-aug s bndg)
            {return s}))))
        (if (and (or (and [jump-reference? s] [c-reference? (@ bndg-definition(@ expr-binding-aug s))])
            (and [invoke-reference? s] [function-reference? (@ bndg-definition(@ expr-binding-aug s))]))
            (not [= [length(@ expr-arguments(@ expr-parent s))] [length(@ expr-parameters[get-target-expression s])]]))
          {handler (storage _ param-count-mismatch-error (@ expr-parent s) [get-target-expression s])}
          {return s})))
    (if (and (or (and [= (@ expr-type s) (-continuation-)] [jump-reference? s])
        (and [= (@ expr-type s) (-function-)] [invoke-reference? s]))
        (not [= [length (@ expr-arguments(@ expr-parent s))] [length (@ expr-parameters s)]]))
      {handler (storage _ param-count-mismatch-error (@ expr-parent s) s)}
      {return s}))))))))

(function vescape-analysis-aux (ref target)
  (if [jump-reference? ref]
    (setf expr-short-circuit (@ expr-parent ref) target)
    (setf expr-escapes target (true))))

(function vescape-analysis (s ctx) (with return (begin
  (if (and [= (@ expr-type s) (-symbol-)] (not [= (@ bndg-definition(@ expr-binding-aug s)) s])
      [c-reference? (@ bndg-definition(@ expr-binding-aug s))])
    [vescape-analysis-aux s [get-target-expression s]]
  (if [= (@ expr-type s) (-continuation-)]
    [vescape-analysis-aux s s]
    (begin)))
  {return s})))

(function visit-expressions (visitor s ctx) (begin
  (switch = (@ expr-type $s)
    ((-begin-)
      (until (partial (@ expr-expressions $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx]))
    
    ((-if-) (begin
      [visit-expressions visitor (& expr-condition $s) ctx]
      [visit-expressions visitor (& expr-consequent $s) ctx]
      [visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (begin
      (if [= (@ expr-type $s) (-storage-)] (begin) [visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx])))
    
    (begin))
  (replace-expression s [visitor $s ctx])))

(function pre-visit-expressions (visitor s ctx) (begin
  (replace-expression s [visitor $s ctx])
  
  (switch = (@ expr-type $s)
    ((-begin-)
      (until (partial (@ expr-expressions $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx]))
    
    ((-if-) (begin
      [pre-visit-expressions visitor (& expr-condition $s) ctx]
      [pre-visit-expressions visitor (& expr-consequent $s) ctx]
      [pre-visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [pre-visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (begin
      (if [= (@ expr-type $s) (-storage-)] (begin) [pre-visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx])))
    
    (begin))))

(function classify-program-bindings (expr)
  (switch = (@ expr-type expr)
    ((-begin-) (foreach (t (@ expr-expressions expr)) [classify-program-bindings t]))
    
    ((-constrain-) [classify-program-bindings (@ expr-expression expr)])
    
    ((-storage-) (-jump-) (-invoke-) (begin
      (if [= (@ expr-type expr) (-storage-)]
        (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
        (begin
          (setf bndg-storage (@ expr-temp-storage-bndg expr) (absolute-storage))
          [classify-program-bindings (@ expr-reference expr)]))
      (foreach (t (@ expr-arguments expr)) [classify-program-bindings t])))
    
    ((-continuation-) (-with-) (begin
      (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
      (foreach (t (@ expr-parameters expr)) (setf bndg-storage (@ expr-binding-aug t) (absolute-storage)))
      [classify-program-bindings (@ expr-expression expr)]))
    
    ((-if-) (begin
      [classify-program-bindings (@ expr-condition expr)]
      [classify-program-bindings (@ expr-consequent expr)]
      [classify-program-bindings (@ expr-alternate expr)]))
    
    (begin)))

(function containment-analysis (s)
  (switch = (@ expr-type s)
    ((-begin-) (fold (acc (contains-none)) (x (@ expr-expressions s)) [lor acc [containment-analysis x]]))
    
    ((-constrain-) [containment-analysis (@ expr-expression s)])
    
    ((-if-)
      (let (condition-flag [containment-analysis (@ expr-condition s)])
          (consequent-flag [containment-analysis (@ expr-consequent s)])
          (alternate-flag [containment-analysis (@ expr-alternate s)])
        (if [= [+ consequent-flag alternate-flag] #1]
          (contains-with)
          [lor condition-flag [lor consequent-flag alternate-flag]])))
    
    ((-function-) (-continuation-) (-with-)
      (let (_ [containment-analysis (@ expr-expression s)])
        (if [= (@ expr-type s) (-with-)] (contains-with) (contains-none))))
    
    ((-storage-) (fold (acc (contains-none)) (x (@ expr-arguments s)) [lor acc [containment-analysis x]]))
    
    ((-jump-) (-invoke-)
      (let (contains-flag (fold (acc [containment-analysis (@ expr-reference s)]) (x (@ expr-arguments s))
          [lor acc [containment-analysis x]]))
        (let (_ (setf expr-contains-flag s contains-flag))
          (if [= (@ expr-type s) (-jump-)] (contains-jump) contains-flag))))
    
    (begin)))

(storage undefined-symbol-error (begin))

(function preprocessed-expression-address (l r)
  (`(\(s bindings buf handler) (with return
    (substitute (.. buf handler)
      (if [= (@ expr-type s) (-symbol-)]
        (begin
          (;; If the expression, s, is a mere symbol, then we can just lookup its value in
              the bindings list instead of preprocessing, compiling, and then evaluating
              the expression.)
          (foreach (bndg bindings)
            (if [str= (@ bndg-name bndg) (@ expr-name s)]
              {return (@ bndg-offset bndg)} (begin)))
          {handler (storage _ undefined-symbol-error (@ expr-name s))})
        (begin
          (define (expr-container [make-function [make-symbol null-string ..] nil s ..])
          (define (expr-container-program [make-program [cons expr-container nil ..] ..])
          (define (program-preprocessed [generate-metaprogram expr-container-program (storage _ bindings) buf handler])
          [load-program-and-mutate program-preprocessed bindings buf handler]
          (define (expr-container-preprocessed [@car (@ expr-expressions (@ expr-expression program-preprocessed))])
          {return [(@ bndg-offset (@ expr-binding-aug (@ expr-reference expr-container-preprocessed)))]})))))))))r))

(;; This function replaces meta-expressions with the code generated by calling
  the corresponding macros. s is the input expression. ctx is a tuple, let
  us unpack it to (bindings expr-buf handler). bindings is a list of global
  bindings. expr-buf is the buffer where the fragments and expressions
  generated by macros will be put. Return value is s if s is not a meta-
  expression, otherwise it is the output of the meta-program. The continuation
  handler is followed.)

(;;((-constrain-) (with return
      (define (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
      (setf expr-signature s [macro buf])
      {return s}))))

(function vgenerate-metas (s ctx)
  (let (handler (@2 ctx))
  (let (bindings (@0 ctx))
  (let (buf (@1 ctx))
  
  (switch = (@ expr-type s)
    ((-meta-)
      (let (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
        [vgenerate-metas [build-expression [macro (@ expr-argument s) buf] buf handler] ctx]))
    
    s)))))

(;; This function handles the lazy compilation of expressions that are neither
  storage nor function ones. It merely compiles its source and then puts a
  handle to it in the cache to facilitate for future executions. expr is the
  expression as it was given in the source. bindings is a reference to the
  list of global bindings that are visible to this expression. expr-buf is the
  buffer where the assembly expressions corresponding to expr will be put.
  obj-buf is where the object code corresponding to expr will be put. Return
  value is a handle to the object code.)

(function init-expression (expr bindings buf handler cache)
  (if [not= $cache null-cache] $cache (with return (substitute (.. buf handler) (begin
    (storage expr-ref expr)
    [pre-visit-expressions vgenerate-metas expr-ref (storage _ $bindings ..)]
    [set cache [segment [load-program-and-mutate [make-program [cons $expr-ref nil ..] ..] $bindings buf
      handler] (" .text)]]
    {return $cache})))))

(function init-storage (data storage-expr bindings buf handler cache)
  (if [not= $cache null-cache] $cache (with return (substitute (.. buf handler) (begin
    (storage sets nil)
    (storage data-ref data)
    (foreach (arg (@ expr-arguments storage-expr)) (begin
      (storage arg-ref arg)
      [pre-visit-expressions vgenerate-metas arg-ref (storage _ $bindings ..)]
      [append (make-invokeN [make-literal set ..] ([make-literal $data-ref ..] $arg-ref) ..) sets ..]
      [set+ data-ref (unit)]))
    [set cache [segment [load-program-and-mutate [make-program $sets ..] $bindings buf handler] (" .text)]]
    {return $cache})))))

(function init-function (function-expr bindings buf handler cache)
  (if [not= $cache null-cache] $cache (with return (substitute (.. buf handler) (begin
    (storage function-expr-ref function-expr)
    [pre-visit-expressions vgenerate-metas function-expr-ref (storage _ $bindings ..)]
    [load-program-and-mutate [make-program [cons $function-expr-ref nil ..] ..] $bindings buf handler]
    [set cache (@ bndg-offset (@ expr-binding-aug (@ expr-reference $function-expr-ref)))]
    {return $cache})))))

(storage null-cache (begin))

(;; From the supplied meta-program expressions, makes a lazy meta-program. That
  is, this function turns the supplied code into last minute requests for
  compilation followed by execution. program is a list of expressions
  representing the metaprogram. bindings is a reference to the list of bindings
  that will be visible to the meta-program during its execution. expr-buf
  if the buffer that the generated metaprogram expressions should be be put
  into. obj-buf is the buffer into which the object code generated by the
  lazy compilation will be put into. handler and err will also be used if
  there are any failures in the lazy compilation. Return value is a program
  expression representing the meta-program.)
  
(function generate-metaprogram (program bindings buf handler)
  (substitute (.. buf handler)
    [make-program [reverse (fold (c nil) (s (@ expr-expressions (@ expr-expression program)))
      (with break (begin
        (define (cache [buffer-alloc (unit) buf handler])
        [set cache null-cache]
        
        (if [= (@ expr-type s) (-storage-)]
          (define (args (reverse-map (_ (@ expr-arguments s)) [make-begin nil ..] ..))
          (define (storage-ref [make-symbol (@ expr-name (@ expr-reference s)) ..])
          (define (c [cons [make-storage storage-ref args ..] c ..])
          (define (storage-ref-arg [make-symbol null-string ..])
          [bind-symbol storage-ref-arg storage-ref]
          (define (init-invoke (make-invokeN (make-invokeN [make-literal init-storage ..] (storage-ref-arg [make-literal s ..]
            [make-literal bindings ..] [make-literal buf ..] [make-literal handler ..]
            [make-literal cache ..]) ..) () ..))
          (define (c [cons init-invoke c ..])
          {break c}))))))
      
        (if [= (@ expr-type s) (-function-)]
          (define (params (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string ..] ..))
          (define (args (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string ..] ..))
          (define (thunk [make-function [make-symbol (@ expr-name (@ expr-reference s)) ..] params
            [make-invoke (make-invokeN [make-literal init-function ..] ([make-literal s ..] [make-literal bindings ..]
            [make-literal buf ..] [make-literal handler ..] [make-literal cache ..]) ..) args ..] ..])
          (foreach (a params) (t args) [bind-symbol t a])
          (define (c [cons thunk c ..])
          {break c}))))
    
        (begin
          (define (init-invoke (make-invokeN (make-invokeN [make-literal init-expression ..] ([make-literal s ..]
            [make-literal bindings ..] [make-literal buf ..] [make-literal handler ..] [make-literal cache ..]) ..) () ..))
          (define (c [cons init-invoke c ..])
          {break c}))))))))) ..] ..]))

