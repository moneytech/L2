(function defined-str= (a b) (and [not= a null-string] [not= b null-string] [str= a b]))

(function named-sym= (a b) [defined-str= (@ expr-name a) (@ expr-name b)])

(storage multiple-definition-error (undefined))

(constrain vfind-multiple-definitions (\(r) (with-vars (a) (`(function (expr ,a) expr)r)r)))

(function vfind-multiple-definitions (e ctx)
  (let (handler (@0 ctx)) (do
    (switch = (@ expr-type e)
      ((-begin-)
        (let (temp-reg [create-buffer #0 handler])
        (let (definitions (reverse-filter (f (@ expr-expressions e))
            (or [= (@ expr-type f) (-storage-)] [= (@ expr-type f) (-function-)]) temp-reg handler)) (do
        (until (partial definitions) [nil? partial] [@cdr partial]
          (if [nil? (find (f (@ cdr partial)) [named-sym= (@ expr-reference f) (@ expr-reference [@car partial])])] (undefined)
            (let (dup-ref-name (@ expr-name(@ expr-reference[@car partial]))) (do
            [destroy-buffer temp-reg handler]
            {handler (storage _ multiple-definition-error dup-ref-name)}))))
        [destroy-buffer temp-reg handler]))))
      
      ((-continuation-) (-function-)
        (let (temp-reg [create-buffer #0 handler])
        (let (ref-with-params [cons (@ expr-reference e) (@ expr-parameters e) temp-reg handler]) (do
        (until (partial ref-with-params) [nil? partial] [@cdr partial]
          (if [nil? (find (f (@ cdr partial)) [named-sym= f [@car partial]])] (undefined)
            (let (dup-ref-name (@ expr-name[@car partial])) (do
            [destroy-buffer temp-reg handler]
            {handler (storage _ multiple-definition-error dup-ref-name)}))))
        [destroy-buffer temp-reg handler]))))
      
      (undefined))
    e)))

(constrain get-parent-function (\(r) (`(function (expr) expr)r)))

(function get-parent-function (n)
  (loop move-up (n (@ expr-parent n))
    (if [= (@ expr-type n) (-function-)]
      n
      {move-up (@ expr-parent n)})))

(constrain global-binding-augs-of (\(r) (with-vars (a) (`(function (expr buffer ,a) (list bndg-aug))r)r)))

(function global-binding-augs-of (prog r handler)
  (loop add-binding (binding-augs nil) (exprs (@ expr-expressions (@ expr-expression prog)))
    (if [nil? exprs]
      binding-augs
      (let (t [@car exprs])
        (if (or [= (@ expr-type t) (-function-)] [= (@ expr-type t) (-storage-)])
          {add-binding [cons (@ expr-binding-aug (@ expr-reference t)) binding-augs r handler] [@cdr exprs]}
          {add-binding binding-augs [@cdr exprs]})))))

(constrain vunlink-symbols (\(r) (`(function (expr (values (list bndg-aug))) expr)r)))

(function vunlink-symbols (s ctx)
  (bind ctx (blacklist)
    (if (and [= (@ expr-type s) (-symbol-)] (not [nil? (find (x blacklist) [= x (@ expr-binding-aug s)])]))
      (let (_ (setf expr-binding-aug s null-binding)) s)
      s)))

(constrain assign-binding (\(r) (with-vars (a) (`(function (expr (list bndg-aug)) ,a)r)r)))

(function assign-binding (s bindings)
  (loop find (bindings bindings)
    (if [nil? bindings]
      (false)
      (let (ba [@car bindings])
        (if (and [not= (@ bndg-name ba) null-string] [not= (@ expr-name s) null-string]
            [str= (@ bndg-name ba) (@ expr-name s)])
          (let (_ (setf expr-binding-aug s ba)) (true))
          {find [@cdr bindings]})))))

(constrain link-symbols
  (\(r) (with-vars (a b) (`(function (expr ,a (ref (list bndg-aug)) (list bndg-aug) (list bndg-aug) buffer ,b) ())r)r)))

(function link-symbols (s static-storage undefined-bindings static-bindings dynamic-bindings r handler)
  (substitute (.. r handler)
    (let (statics-ref (storage _ static-bindings))
    (let (dynamics-ref (storage _ dynamic-bindings))
    (let (bindings-ref (if static-storage statics-ref dynamics-ref))
    
    (switch = (@ expr-type s)
      ((-begin-) (do
        (foreach (t (@ expr-expressions s))
          (if [= (@ expr-type t) (-storage-)]
            [prepend (@ expr-binding-aug (@ expr-reference t)) bindings-ref ..]
          (if [= (@ expr-type t) (-function-)]
            [prepend (@ expr-binding-aug (@ expr-reference t)) statics-ref ..]
            (undefined))))
        (foreach (t (@ expr-expressions s))
          [link-symbols t static-storage undefined-bindings $statics-ref $dynamics-ref ..])))
      
      ((-function-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) statics-ref ..]
        [set dynamics-ref nil]
        (foreach (u (@ expr-parameters s)) [prepend (@ expr-binding-aug u) dynamics-ref ..])
        [link-symbols (@ expr-expression s) (false) undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-with-) (-continuation-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) bindings-ref ..]
        (foreach (u (@ expr-parameters s)) [prepend (@ expr-binding-aug u) bindings-ref ..])
        [link-symbols (@ expr-expression s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-storage-) (do
        [prepend (@ expr-binding-aug (@ expr-reference s)) bindings-ref ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings $statics-ref $dynamics-ref ..])))
      
      ((-symbol-)
        (if (and [= (@ expr-binding-aug s) null-binding] (not [assign-binding s $dynamics-ref])
            (not [assign-binding s $statics-ref]) (not [assign-binding s $undefined-bindings]))
          (let (stg [make-storage [make-symbol (@ expr-name s) ..] nil ..])
          (let (bndg (@ expr-binding-aug (@ expr-reference stg))) (do
          (setf bndg-storage bndg (absolute-storage))
          (setf bndg-scope bndg (global-scope))
          (setf bndg-state bndg (undefined-state))
          (setf expr-binding-aug s bndg)
          [prepend (@ expr-binding-aug s) undefined-bindings ..])))
          (undefined)))
      
      ((-if-) (do
        [link-symbols (@ expr-condition s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        [link-symbols (@ expr-consequent s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        [link-symbols (@ expr-alternate s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]))
      
      ((-invoke-) (-jump-) (do
        [link-symbols (@ expr-reference s) static-storage undefined-bindings $statics-ref $dynamics-ref ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings $statics-ref $dynamics-ref ..])))
      
      ((-constrain-)
        [link-symbols (@ expr-expression s) static-storage undefined-bindings $statics-ref $dynamics-ref ..])
      
      (undefined)))))))

(function jump-reference? (s) (and [= (@ expr-type(@ expr-parent s)) (-jump-)] [= (@ expr-reference(@ expr-parent s)) s]))

(function c-reference? (s)
  (and (or [= (@ expr-type(@ expr-parent s)) (-continuation-)] [= (@ expr-type(@ expr-parent s)) (-with-)])
    [= (@ expr-reference(@ expr-parent s)) s]))

(function get-target-expression (s) (@ expr-parent(@ bndg-definition(@ expr-binding-aug s))))

(function vescape-analysis-aux (ref target)
  (if [jump-reference? ref]
    (setf expr-short-circuit (@ expr-parent ref) target)
    (setf expr-escapes target (true))))

(function vescape-analysis (s ctx) (do
  (if (and [= (@ expr-type s) (-symbol-)] (not [= (@ bndg-definition(@ expr-binding-aug s)) s])
      [c-reference? (@ bndg-definition(@ expr-binding-aug s))])
    [vescape-analysis-aux s [get-target-expression s]]
  (if [= (@ expr-type s) (-continuation-)]
    [vescape-analysis-aux s s]
    (undefined)))
  s))

(constrain vfind-dependencies (\(r) (with-vars (a) (`(function (expr (values buffer ,a)) expr)r)r)))

(function vfind-dependencies (s ctx)
  (bind ctx (r handler) (substitute (.. r handler)
    (let (_ (switch = (@ expr-type s)
        ((-begin-)
          (foreach (t (@ expr-expressions s)) [prepend t (& expr-dependencies s) ..]))
        
        ((-if-) (do
          [prepend (@ expr-condition s) (& expr-dependencies s) ..]
          [prepend (@ expr-consequent s) (& expr-dependencies s) ..]
          [prepend (@ expr-alternate s) (& expr-dependencies s) ..]))
        
        ((-function-) (-continuation-) (-with-)
          [prepend (@ expr-expression s) (& expr-dependencies s) ..])
        
        ((-storage-) (-jump-) (-invoke-) (do
          [prepend (@ expr-reference s) (& expr-dependencies s) ..]
          (foreach (t (@ expr-arguments s)) [prepend t (& expr-dependencies s) ..])))
        
        ((-symbol-)
          (let (definition (@ bndg-definition (@ expr-binding-aug s))) (do
          [prepend (@ expr-parent definition) (& expr-dependencies s) ..]
          [prepend s (& expr-dependencies (@ expr-parent definition)) ..])))
        
        ((-constrain-) (do
          [prepend (@ expr-expression s) (& expr-dependencies s) ..]
          [prepend s (& expr-dependencies (@ expr-expression s)) ..]))
        
        (undefined)))
      s))))

(constrain construct-sccs (\(r) (with-vars (a b) (`(function (expr ,a (ref (list expr)) (ref (list (list expr))) buffer ,b) ())r)r)))

(function construct-sccs (s preorder stack sccs r handler)
  (substitute (.. r handler)
    (if [= (@ expr-lowlink s) #0]
      (let (marker $stack) (do
      (setf expr-lowlink s preorder)
      (foreach (t (@ expr-dependencies s)) (do
        [construct-sccs t [+ preorder #1] stack sccs ..]
        (if [< (@ expr-lowlink t) (@ expr-lowlink s)]
          (setf expr-lowlink s (@ expr-lowlink t))
          (undefined))))
      [prepend s stack ..]
      
      (if [= (@ expr-lowlink s) preorder] (do
        [prepend (loop add (t $stack) (scc nil)
          (if [= t marker] scc
            (let (u [@car t]) (do
            (setf expr-lowlink u [- #0 #1])
            {add [@cdr t] [cons u scc ..]})))) sccs ..]
        [set stack marker])
        (undefined))))
      (undefined))))

(constrain occurs-in? (\(r) (with-vars (a) (`(function (vbl frag) ,a)r)r)))

(function occurs-in? (var val)
  (let (eval [evaluate val])
    (if [vbl? eval]
      [vbl= var [frag->vbl eval]]
    (if [i/f:token? eval]
      (false)
      (not [nil? (find (a [frag->list eval]) [occurs-in? var a])])))))

(constrain unify-var (\(r) (with-vars (a) (`(function (vbl frag) ,a)r)r)))

(function unify-var (var val)
  (if (not [occurs-in? var val])
    (let (_ [set-val var val]) (true))
    (false)))

(constrain unify (\(r) (with-vars (a) (`(function (frag frag) ,a)r)r)))

(function unify (x y)
  (let (xl [evaluate x]) (yl [evaluate y])
    (if (and [vbl? xl] [vbl? yl] [vbl= [frag->vbl xl] [frag->vbl yl]]) (true)
    (if [vbl? xl] [unify-var [frag->vbl xl] yl]
    (if [vbl? yl] [unify-var [frag->vbl yl] xl]
    (if (and [i/f:token? xl] [i/f:token? yl]) [i/f:token= [fragment->token xl] [fragment->token yl]]
    (if (or [i/f:token? xl] [i/f:token? yl]) (false)
    (let (xl [frag->list xl]) (yl [frag->list yl])
      (if [= [length xl] [length yl]]
        (loop do-unify (xl xl) (yl yl)
          (if [nil? xl]
            (true)
          (if (not [unify [@car xl] [@car yl]])
            (false)
            {do-unify [@cdr xl] [@cdr yl]})))
        (false))))))))))

(constrain scoped-signature (\(r) (with-vars (a) (`(function (expr (list expr) buffer ,a) frag)r)r)))

(function scoped-signature (e scc r handler)
  (if (not [nil? (find (x scc) [= x e])])
    (@ expr-signature e)
    [copy-fragment (@ expr-signature e) (storage _ nil) (storage _ nil) r handler]))

(storage unification-error (undefined))

(constrain infer-types (\(r) (with-vars (a) (`(function (expr buffer ,a) ())r)r)))

(function infer-types (program buf handler)
  (substitute (.. buf handler) (do
    (;; Type inferencing is done on strongly connected components)
    (let (stack (storage _ nil))
    (let (sccs (storage _ nil)) (do
    [visit-expressions vfind-dependencies (storage _ program) (values ..)]
    [construct-sccs program #1 stack sccs ..]
    
    (foreach (scc [reverse $sccs ..]) (do
      (foreach (e scc) (let (equations
          (let (function-token [token->fragment [build-token (" function) ..]])
          (let (continuation-token [token->fragment [build-token (" continuation) ..]])
          (switch = (@ expr-type e)
            ((-function-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (x (@ expr-parameters e)) (@ expr-signature x) ..) ..]])
              (list
                ((values (@ expr-signature e) [list->fragment [cons function-token [cons params-signature
                  [cons (@ expr-signature (@ expr-expression e)) nil ..] ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-reference e)))) ..)))
            
            ((-continuation-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (x (@ expr-parameters e)) (@ expr-signature x) ..) ..]])
              (list
                ((values (@ expr-signature e) [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-reference e)))) ..)))
            
            ((-constrain-)
              (list ((values (@ expr-signature e) (@ expr-signature (@ expr-expression e)))) ..))
            
            ((-invoke-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..) ..]])
              (list
                ((values [scoped-signature (@ expr-reference e) scc ..]
                  [list->fragment [cons function-token [cons params-signature [cons (@ expr-signature e) nil ..] ..] ..]])) ..)))
            
            ((-jump-)
              (let (params-signature [list->fragment [reverse
                (reverse-map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..) ..]])
              (list
                ((values [scoped-signature (@ expr-reference e) scc ..]
                  [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])) ..)))
            
            ((-with-)
              (let (params-signature [list->fragment [cons (@ expr-signature e) nil ..]])
              (list
                ((values (@ expr-signature (@ expr-reference e))
                  [list->fragment [cons continuation-token [cons params-signature nil ..] ..]])
                (values (@ expr-signature e) (@ expr-signature (@ expr-expression e)))) ..)))
            
            ((-if-)
              (let (consequent-sig [scoped-signature (@ expr-consequent e) scc ..])
              (let (alternate-sig [scoped-signature (@ expr-alternate e) scc ..])
              (list ((values consequent-sig alternate-sig) (values (@ expr-signature e) consequent-sig)) ..))))
            
            ((-symbol-)
              (list ((values (@ expr-signature e) (@ expr-signature (@ bndg-definition (@ expr-binding-aug e))))) ..))
            
            nil))))
        
        (foreach (equ equations)
          (bind equ (lhs rhs)
            (if [unify lhs rhs] (undefined)
              {handler (storage _ unification-error [recursive-evaluate lhs ..] [recursive-evaluate rhs ..] e)})))))
      
      (foreach (e scc) (setf expr-signature e [recursive-evaluate (@ expr-signature e) ..]))))))))))

(constrain visit-expressions (\(r) (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function visit-expressions (visitor s ctx) (do
  (switch = (@ expr-type $s)
    ((-begin-)
      (until (partial (@ expr-expressions $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx]))
    
    ((-if-) (do
      [visit-expressions visitor (& expr-condition $s) ctx]
      [visit-expressions visitor (& expr-consequent $s) ctx]
      [visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (do
      (if [= (@ expr-type $s) (-storage-)] (undefined) [visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx])))
    
    (undefined))
  (replace-expression s [visitor $s ctx])))

(constrain pre-visit-expressions (\(r) (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function pre-visit-expressions (visitor s ctx) (do
  (replace-expression s [visitor $s ctx])
  
  (switch = (@ expr-type $s)
    ((-begin-)
      (until (partial (@ expr-expressions $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx]))
    
    ((-if-) (do
      [pre-visit-expressions visitor (& expr-condition $s) ctx]
      [pre-visit-expressions visitor (& expr-consequent $s) ctx]
      [pre-visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [pre-visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-jump-) (-invoke-) (-storage-) (do
      (if [= (@ expr-type $s) (-storage-)] (undefined) [pre-visit-expressions visitor (& expr-reference $s) ctx])
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx])))
    
    (undefined))))

(constrain classify-program-bindings (\(r) (`(function (expr) ())r)))

(function classify-program-bindings (expr)
  (switch = (@ expr-type expr)
    ((-begin-) (foreach (t (@ expr-expressions expr)) [classify-program-bindings t]))
    
    ((-constrain-) [classify-program-bindings (@ expr-expression expr)])
    
    ((-storage-) (-jump-) (-invoke-) (do
      (if [= (@ expr-type expr) (-storage-)]
        (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
        (do
          (setf bndg-storage (@ expr-temp-storage-bndg expr) (absolute-storage))
          [classify-program-bindings (@ expr-reference expr)]))
      (foreach (t (@ expr-arguments expr)) [classify-program-bindings t])))
    
    ((-continuation-) (-with-) (do
      (setf bndg-storage (@ expr-binding-aug(@ expr-reference expr)) (absolute-storage))
      (foreach (t (@ expr-parameters expr)) (setf bndg-storage (@ expr-binding-aug t) (absolute-storage)))
      [classify-program-bindings (@ expr-expression expr)]))
    
    ((-if-) (do
      [classify-program-bindings (@ expr-condition expr)]
      [classify-program-bindings (@ expr-consequent expr)]
      [classify-program-bindings (@ expr-alternate expr)]))
    
    (undefined)))

(constrain containment-analysis (\(r) (`(function (expr) expr-contains-flag)r)))

(function containment-analysis (s)
  (switch = (@ expr-type s)
    ((-begin-) (fold (acc (contains-none)) (x (@ expr-expressions s)) [lor acc [containment-analysis x]]))
    
    ((-constrain-) [containment-analysis (@ expr-expression s)])
    
    ((-if-)
      (let (condition-flag [containment-analysis (@ expr-condition s)])
          (consequent-flag [containment-analysis (@ expr-consequent s)])
          (alternate-flag [containment-analysis (@ expr-alternate s)])
        (if [= [+ consequent-flag alternate-flag] #1]
          (contains-with)
          [lor condition-flag [lor consequent-flag alternate-flag]])))
    
    ((-function-) (-continuation-) (-with-)
      (let (_ [containment-analysis (@ expr-expression s)])
        (if [= (@ expr-type s) (-with-)] (contains-with) (contains-none))))
    
    ((-storage-) (fold (acc (contains-none)) (x (@ expr-arguments s)) [lor acc [containment-analysis x]]))
    
    ((-jump-) (-invoke-)
      (let (contains-flag (fold (acc [containment-analysis (@ expr-reference s)]) (x (@ expr-arguments s))
          [lor acc [containment-analysis x]]))
        (let (_ (setf expr-contains-flag s contains-flag))
          (if [= (@ expr-type s) (-jump-)] (contains-jump) contains-flag))))
    
    (contains-none)))

(storage undefined-symbol-error (undefined))

(function preprocessed-expression-address (l r)
  (`(\(s bindings buf handler)
    (substitute (.. buf handler)
      (if [= (@ expr-type s) (-symbol-)]
        (do
          (;; If the expression, s, is a mere symbol, then we can just lookup its value in
              the bindings list instead of preprocessing, compiling, and then evaluating
              the expression.)
          (loop find-binding (bindings bindings)
            (if [nil? bindings]
              {handler (storage _ undefined-symbol-error (@ expr-name s))}
              (let (bndg [@car bindings])
                (if [str= (@ bndg-name bndg) (@ expr-name s)]
                  (@ bndg-offset bndg)
                  {find-binding [@cdr bindings]})))))
        (do
          (let (expr-container [make-function [make-symbol null-string ..] nil s ..])
          (let (expr-container-program [make-program [cons expr-container nil ..] ..])
          (let (program-preprocessed [generate-metaprogram expr-container-program (storage _ bindings) buf handler]) (do
          [load-program-and-mutate program-preprocessed bindings buf handler]
          (let (expr-container-preprocessed [@car (@ expr-expressions (@ expr-expression program-preprocessed))])
          [(@ bndg-offset (@ expr-binding-aug (@ expr-reference expr-container-preprocessed)))])))))))))r))

(;; This function replaces meta-expressions with the code generated by calling
  the corresponding macros. s is the input expression. ctx is a tuple, let
  us unpack it to (bindings expr-buf handler). bindings is a list of global
  bindings. expr-buf is the buffer where the fragments and expressions
  generated by macros will be put. Return value is s if s is not a meta-
  expression, otherwise it is the output of the meta-program. The continuation
  handler is followed.)

(constrain vgenerate-metas (\(r) (with-vars (a) (`(function (expr (values (list bndg-aug) buffer ,a)) expr)r)r)))

(function vgenerate-metas (s ctx)
  (bind ctx (bindings buf handler)
    (switch = (@ expr-type s)
      ((-meta-)
        (let (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
          [vgenerate-metas [build-expression [macro (@ expr-argument s) buf] buf handler] ctx]))
      
      ((-constrain-)
        (let (macro [(preprocessed-expression-address) (@ expr-reference s) bindings buf handler])
          (let (_ (setf expr-signature s [macro buf]))
            s)))
      
      s)))

(;; This function handles the lazy compilation of expressions that are neither
  storage nor function ones. It merely compiles its source and then puts a
  handle to it in the cache to facilitate for future executions. expr is the
  expression as it was given in the source. bindings is a reference to the
  list of global bindings that are visible to this expression. expr-buf is the
  buffer where the assembly expressions corresponding to expr will be put.
  obj-buf is where the object code corresponding to expr will be put. Return
  value is a handle to the object code.)

(constrain init-expression (\(r) (with-vars (a b) (`(function (expr (ref (list bndg-aug)) buffer ,a (ref ,b)) ,b)r)r)))

(function init-expression (expr bindings buf handler cache)
  (substitute (.. buf handler)
    (if [not= $cache null-cache]
      $cache
      (let (expr-ref (storage _ expr)) (do
        [pre-visit-expressions vgenerate-metas expr-ref (values $bindings ..)]
        [set cache [segment [load-program-and-mutate [make-program [cons $expr-ref nil ..] ..] $bindings buf
          handler] (" .text)]]
        $cache)))))

(constrain init-storage (\(r) (with-vars (c a b) (`(function (,c expr (ref (list bndg-aug)) buffer ,a (ref ,b)) ,b)r)r)))

(function init-storage (data storage-expr bindings buf handler cache)
  (substitute (.. buf handler)
    (if [not= $cache null-cache]
      $cache
      (let (sets (storage _ nil))
        (let (data-ref (storage _ data)) (do
        (foreach (arg (@ expr-arguments storage-expr))
          (let (arg-ref (storage _ arg)) (do
          [pre-visit-expressions vgenerate-metas arg-ref (values $bindings ..)]
          [append (make-invokeN [make-literal set ..] ([make-literal $data-ref ..] $arg-ref) ..) sets ..]
          [set+ data-ref (unit)])))
        [set cache [segment [load-program-and-mutate [make-program $sets ..] $bindings buf handler] (" .text)]]
        $cache))))))

(constrain init-function (\(r) (with-vars (a b) (`(function (expr (ref (list bndg-aug)) buffer ,a (ref ,b)) ,b)r)r)))

(function init-function (function-expr bindings buf handler cache)
  (substitute (.. buf handler)
    (if [not= $cache null-cache]
      $cache
      (let (function-expr-ref (storage _ function-expr)) (do
        [pre-visit-expressions vgenerate-metas function-expr-ref (values $bindings ..)]
        [load-program-and-mutate [make-program [cons $function-expr-ref nil ..] ..] $bindings buf handler]
        [set cache (@ bndg-offset (@ expr-binding-aug (@ expr-reference $function-expr-ref)))]
        $cache)))))

(storage null-cache (undefined))

(;; From the supplied meta-program expressions, makes a lazy meta-program. That
  is, this function turns the supplied code into last minute requests for
  compilation followed by execution. program is a list of expressions
  representing the metaprogram. bindings is a reference to the list of bindings
  that will be visible to the meta-program during its execution. expr-buf
  if the buffer that the generated metaprogram expressions should be be put
  into. obj-buf is the buffer into which the object code generated by the
  lazy compilation will be put into. handler and err will also be used if
  there are any failures in the lazy compilation. Return value is a program
  expression representing the meta-program.)

(constrain generate-metaprogram (\(r) (with-vars (a) (`(function (expr (ref (list bndg-aug)) buffer ,a) expr)r)r)))

(function generate-metaprogram (program bindings buf handler)
  (substitute (.. buf handler)
    [make-program [reverse (fold (c nil) (s (@ expr-expressions (@ expr-expression program)))
      (let (cache [buffer-alloc (unit) buf handler]) (do
        [set cache null-cache]
        
        (if [= (@ expr-type s) (-storage-)]
          (let (args (reverse-map (_ (@ expr-arguments s)) [make-begin nil ..] ..))
          (let (storage-ref [make-symbol (@ expr-name (@ expr-reference s)) ..])
          (let (c [cons [make-storage storage-ref args ..] c ..])
          (let (storage-ref-arg [make-symbol null-string ..]) (do
          [bind-symbol storage-ref-arg storage-ref]
          (let (init-invoke (make-invokeN (make-invokeN [make-literal init-storage ..] (storage-ref-arg [make-literal s ..]
            [make-literal bindings ..] [make-literal buf ..] [make-literal handler ..]
            [make-literal cache ..]) ..) () ..))
          [cons init-invoke c ..]))))))
        
        (if [= (@ expr-type s) (-function-)]
          (let (params (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string ..] ..))
          (let (args (reverse-map (_ (@ expr-parameters s)) [make-symbol null-string ..] ..))
          (let (thunk [make-function [make-symbol (@ expr-name (@ expr-reference s)) ..] params
            [make-invoke (make-invokeN [make-literal init-function ..] ([make-literal s ..] [make-literal bindings ..]
            [make-literal buf ..] [make-literal handler ..] [make-literal cache ..]) ..) args ..] ..]) (do
          (foreach (a params) (t args) [bind-symbol t a])
          [cons thunk c ..]))))
        
          (let (init-invoke (make-invokeN (make-invokeN [make-literal init-expression ..] ([make-literal s ..]
            [make-literal bindings ..] [make-literal buf ..] [make-literal handler ..] [make-literal cache ..]) ..) () ..))
          [cons init-invoke c ..])))))) ..] ..]))

