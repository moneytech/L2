(;; x86-64 Linux specific constants.)

(function sys-read (l r) [mk## #0 (\(r) (` syscall-num r)) r])

(function sys-write (l r) [mk## #1 (\(r) (` syscall-num r)) r])

(function sys-open (l r) [mk## #2 (\(r) (` syscall-num r)) r])

(function sys-close (l r) [mk## #3 (\(r) (` syscall-num r)) r])

(function sys-fstat (l r) [mk## #5 (\(r) (` syscall-num r)) r])

(function sys-mmap (l r) [mk## #9 (\(r) (` syscall-num r)) r])

(function sys-munmap (l r) [mk## #11 (\(r) (` syscall-num r)) r])

(function sys-exit (l r) [mk## #60 (\(r) (` syscall-num r)) r])

(function sys-clock-gettime (l r) [mk## #228 (\(r) (` syscall-num r)) r])

(function o-rdonly (l r) [mk# r #0])

(function o-wronly (l r) [mk# r #1])

(function o-rdwr (l r) [mk# r #2])

(function o-creat (l r) [mk# r #64])

(function s-irwxu (l r) [mk# r #448])

(function s-irwxg (l r) [mk# r #56])

(function s-irwxo (l r) [mk# r #7])

(function prot-read (l r) [mk# r #1])

(function prot-write (l r) [mk# r #2])

(function prot-exec (l r) [mk# r #4])

(function prot-none (l r) [mk# r #0])

(function map-private (l r) [mk# r #2])

(function map-anonymous (l r) [mk# r #32])

(function page-size (l r) [mk# r #4096])

(function arg-max (l r) (`(page-size)r))

(function clock-process-cputime-id (l r) [mk# r #2])

(function stdin (l r) [mk## #0 (\(r) (` fd r)) r])

(function stdout (l r) [mk## #1 (\(r) (` fd r)) r])

(function byte (l r) [mk# r #1])

(function unit (l r) [mk# r #8])

(function alloc-alignment (l r) [mk# r #8])

(;; Layout of the header of our endogenous linked list of mmaped regions.)

(function buffer-element (l r) [mk# r #40])

(;; Contains reference to next mmaped region. Is null-element otherwise.)

(function buf-next-elt (l r) [property #0 #8 (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to last mmaped region in buffer. Field required to reduce allocation time.)

(function buf-last-elt (l r) [property #8 #8 (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to next aligned free memory in buffer element.)

(function buf-curr-pos (l r) [property #16 #8 (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains reference to the end of the buffer element.)

(function buf-end-pos (l r) [property #24 #8 (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains magic debug value.)

(function buf-magic-dbg (l r) [property #32 #8 (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; --------------------------------------------------------------------------)

(constrain syscall (\(r) (with-vars (a b c d e f g) (`(function (syscall-num ,a ,b ,c ,d ,e ,f) ,g)r)r)))

(function exit (code) [syscall (sys-exit) code (undefined) (undefined) (undefined) (undefined) (undefined)])

(constrain strlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strlen (str)
  (loop do-count (i #0)
    (if [getb [+ str i]] {do-count [+ i #1]} i)))

(constrain strvlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strvlen (str)
  (loop do-count (i #1)
    (if (or [getb [+ str [- i #1]]] [getb [+ str i]])
      {do-count [+ i #1]}
      i)))

(constrain null-strrchr (\(r) (` string r)))

(storage null-strrchr (undefined))

(constrain strrchr (\(r) (with-vars (a) (`(function (string ,a) string)r)r)))

(function strrchr (s c)
  (loop do-search (t [+ s [strlen s]])
    (if [= [getb t] c]
      t
    (if [= t s]
      null-strrchr
      {do-search [- t #1]}))))

(constrain strcmp (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcmp (s1 s2)
  (loop do-cmp (s1 s1) (s2 s2)
    (if (and [getb s1] [getb s2] [= [getb s1] [getb s2]])
      {do-cmp [+ s1 #1] [+ s2 #1]}
      [- [getb s1] [getb s2]])))

(constrain str= (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function str= (s1 s2) (not [strcmp s1 s2]))

(constrain strcpy (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcpy (dest src)
  (loop do-cpy (dest dest) (src src) (do
    [setb dest [getb src]]
    (if [getb dest]
      {do-cpy [+ dest #1] [+ src #1]}
      (undefined)))))

(function memcpy (dest src n)
  (loop do-cpy (dest dest) (src src) (n n)
    (if n
      (do
        [setb dest [getb src]]
        {do-cpy [+ dest #1] [+ src #1] [- n #1]})
      (undefined))))

(function memset (s c n)
  (loop do-set (s s) (n n)
    (if n
      (do
        [setb s c]
        {do-set [+ s #1] [- n #1]})
      (undefined))))

(function isspace (c) (switch = c
  ((space) (true))
  ((ff) (true))
  ((lf) (true))
  ((cr) (true))
  ((ht) (true))
  ((vt) (true))
  (false)))

(;; What follows is essentially wrappers for Linux syscalls. The only twist is
  that if the actual syscall returns an error code, then these functions will
  modify the supplied error buffer and follow the error continuation instead
  of returning.)

(storage file-access-error (undefined))

(constrain open (\(r) (with-vars (b) (`(function (string ,b) fd)r)r)))

(function open (path handler)
  (let (ret [syscall (sys-open) path (o-rdonly) (undefined) (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error path)}
      ret)))

(constrain create (\(r) (with-vars (b) (`(function (string ,b) fd)r)r)))

(function create (path handler)
  (let (ret [syscall (sys-open) path [lor (o-wronly) (o-creat)] [lor (s-irwxu) [lor (s-irwxg) (s-irwxo)]]  (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error path)}
      ret)))

(constrain null-string (\(r) (` string r)))

(storage null-string (undefined))

(constrain print (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function print (fd d len handler)
  (let (ret [syscall (sys-write) fd d len (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error null-string)}
      ret)))

(constrain print-str (\(r) (with-vars (b e) (`(function (fd string ,b) ,e)r)r)))

(function print-str (fd str handler) [print fd str [strlen str] handler])

(constrain print-str (\(r) (with-vars (a b e) (`(function (fd ,a ,b) ,e)r)r)))

(function print-char (fd ch handler) [print fd (storage _ ch) #1 handler])

(constrain print-uint (\(r) (with-vars (a b e) (`(function (fd ,a ,b) ,e)r)r)))

(function print-uint (fd i handler)
  (let (j (storage _ #19))
  (let (str (storage _ (undefined) (undefined) (undefined))) (do
  (until (i i) [= i #0] [/ i #10] (do
    [setb [+ str $j] (switch = [rem i #10]
      (#9 (char 9))
      (#8 (char 8))
      (#7 (char 7))
      (#6 (char 6))
      (#5 (char 5))
      (#4 (char 4))
      (#3 (char 3))
      (#2 (char 2))
      (#1 (char 1))
      (char 0))]
    [set j [- $j #1]]))
  [print fd [+ str [+ $j #1]] [- #19 $j] handler]))))

(constrain read (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function read (fd buf cnt handler)
  (let (ret [syscall (sys-read) fd buf cnt (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error null-string)}
      ret)))

(constrain close (\(r) (with-vars (a c) (`(function (fd ,a) ,c)r)r)))

(function close (fd handler)
  (let (ret [syscall (sys-close) fd (undefined) (undefined) (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error null-string)}
      ret)))

(constrain size (\(r) (with-vars (a c) (`(function (fd ,a) ,c)r)r)))

(function size (fd handler)
  (let (statbuf (storage _ (undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)
    (undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)(undefined)))
  (let (ret [syscall (sys-fstat) fd statbuf (undefined) (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ file-access-error null-string)}
      [get [+ statbuf #48]]))))

(storage memory-access-error (undefined))

(;; Creates a new virtual address mapping of the size in bytes given at len.)

(function mmap (len handler)
  (let (ret [syscall (sys-mmap) #0 len [lor (prot-read) (prot-write)] [lor (map-private) (map-anonymous)] [lnot #0] #0])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ memory-access-error)}
      ret)))

(;; Deletes virtual address mappings coinciding with the range starting with the
  value at ptr and having an extent of the value given at len.)

(function munmap (ptr len handler)
  (let (ret [syscall (sys-munmap) ptr len (undefined) (undefined) (undefined) (undefined)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (storage _ memory-access-error)}
      ret)))

(function pad-size (x nearest) (let (r [rem x nearest]) [+ x (if r [- nearest r] #0)]))

(constrain null-element (\(r) (` buffer r)))

(storage null-element (undefined))

(;; Creates a new buffer with a minimum capacity in bytes given by the value at
  min-capacity.)

(constrain create-buffer (\(r) (with-vars (a b) (`(function (,a ,b) buffer)r)r)))

(function create-buffer (min-capacity handler)
  (let (len [pad-size [+ min-capacity (buffer-element)] (page-size)])
    (let (reg [mmap len handler]) (do
      (setf buf-next-elt reg null-element)
      (setf buf-last-elt reg reg)
      (setf buf-curr-pos reg [+ reg (buffer-element)])
      (setf buf-end-pos reg [+ reg len])
      (setf buf-magic-dbg reg (hex DEADBEEFDEADBEEF))
      reg))))

(;; Allocates memory in the buffer at reg of an amount in bytes equal to the
  integer at len. The only way to deallocate this memory is destroy the entire
  buffer at reg.)

(constrain buffer-alloc (\(r) (with-vars (a b d) (`(function (,a buffer ,b) ,d)r)r)))

(function buffer-alloc (len reg handler)
  (let (len [pad-size len (alloc-alignment)])
  (let (last-elt-ref (storage _ (@ buf-last-elt reg))) (do
  (if [> [+(@ buf-curr-pos $last-elt-ref)len] (@ buf-end-pos $last-elt-ref)]
    (do
      (setf buf-next-elt $last-elt-ref [create-buffer [+ len [* #2[-(@ buf-end-pos $last-elt-ref) $last-elt-ref]]] handler])
      (setf buf-last-elt reg (@ buf-next-elt $last-elt-ref))
      [set last-elt-ref (@ buf-next-elt $last-elt-ref)])
    (undefined))
  
  (setf buf-curr-pos $last-elt-ref [+(@ buf-curr-pos $last-elt-ref)len])
  [-(@ buf-curr-pos $last-elt-ref)len]))))

(;; Releases the memory associated with the buffer reg. After a call to this
  function, it is invalid to read or write data to the memory allocated on
  this region.)

(constrain destroy-buffer (\(r) (with-vars (b) (`(function (buffer ,b) ())r)r)))

(function destroy-buffer (reg handler)
  (loop do-destroy (reg reg)
    (let (next-reg (@ buf-next-elt reg)) (do
      [munmap reg [- (@ buf-end-pos reg) reg] handler]
      (if [= next-reg null-element]
        (undefined)
        {do-destroy next-reg})))))

(;; Returns a C-string that is a copy of the one at src. The returned string and
  its dependencies will all reside in the region reg.)

(constrain rstrcpy (\(r) (with-vars (a) (`(function (string buffer ,a) string)r)r)))

(function rstrcpy (src reg handler)
  (let (dest [buffer-alloc [+[strlen src]#1] reg handler]) (do
    [strcpy dest src]
    dest)))

(;; Returns a list containing the the command line arguments. The returned list
  and its dependencies will all reside in the region reg.)

(constrain argv (\(r) (with-vars (a) (`(function (buffer ,a) (list string))r)r)))

(function argv (reg handler)
  (let (f [open (" /proc/self/cmdline) handler])
    (fallthrough
        (let (buf [buffer-alloc (arg-max) reg cleanup])
        (let (bytes-rem [read f buf (arg-max) cleanup])
        (storage _ no-error
          (loop get-arg (buf buf) (bytes-rem bytes-rem) (args nil)
            (if bytes-rem
              {get-arg [+ buf [+ [strlen buf] #1]] [- bytes-rem [+ [strlen buf] #1]] [cons buf args reg cleanup]}
              [reverse args reg cleanup])))))
      
      (cleanup err
        (let (_ [close f handler])
        (if [= (@0 err) no-error] (@1 err) {handler err}))))))

