(;; x86-64 Linux specific constants.)

(function sys-read (l r) [mk## #0 (\(r) (` syscall-num r)) r])

(function sys-write (l r) [mk## #1 (\(r) (` syscall-num r)) r])

(function sys-open (l r) [mk## #2 (\(r) (` syscall-num r)) r])

(function sys-close (l r) [mk## #3 (\(r) (` syscall-num r)) r])

(function sys-fstat (l r) [mk## #5 (\(r) (` syscall-num r)) r])

(function sys-mmap (l r) [mk## #9 (\(r) (` syscall-num r)) r])

(function sys-munmap (l r) [mk## #11 (\(r) (` syscall-num r)) r])

(function sys-exit (l r) [mk## #60 (\(r) (` syscall-num r)) r])

(function sys-clock-gettime (l r) [mk## #228 (\(r) (` syscall-num r)) r])

(function o-rdonly (l r) [mk# r #0])

(function o-wronly (l r) [mk# r #1])

(function o-rdwr (l r) [mk# r #2])

(function o-creat (l r) [mk# r #64])

(function s-irwxu (l r) [mk# r #448])

(function s-irwxg (l r) [mk# r #56])

(function s-irwxo (l r) [mk# r #7])

(function prot-read (l r) [mk# r #1])

(function prot-write (l r) [mk# r #2])

(function prot-exec (l r) [mk# r #4])

(function prot-none (l r) [mk# r #0])

(function map-private (l r) [mk# r #2])

(function map-anonymous (l r) [mk# r #32])

(function page-size (l r) [mk# r #4096])

(function arg-max (l r) (`(page-size)r))

(function clock-process-cputime-id (l r) [mk# r #2])

(function stdin (l r) [mk## #0 (\(r) (` fd r)) r])

(function stdout (l r) [mk## #1 (\(r) (` fd r)) r])

(function byte (l r) [mk# r #1])

(function unit (l r) [mk# r #8])

(function alloc-alignment (l r) [mk# r #8])

(;; Layout of the header of our endogenous linked list of mmaped regions.)

(function buffer-element (l r) [mk# r #40])

(;; Contains reference to next mmaped region. Is null-element otherwise.)

(function buf-next-elt (l r) [property #0 8b (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to last mmaped region in buffer. Field required to reduce allocation time.)

(function buf-last-elt (l r) [property #8 8b (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to next aligned free memory in buffer element.)

(function buf-curr-pos (l r) [property #16 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains reference to the end of the buffer element.)

(function buf-end-pos (l r) [property #24 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains magic debug value.)

(function buf-magic-dbg (l r) [property #32 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; --------------------------------------------------------------------------)

(constrain syscall (\(r) (with-vars (a b c d e f g) (`(function (syscall-num ,a ,b ,c ,d ,e ,f) ,g)r)r)))

(function exit (code) [syscall (sys-exit) code (begin) (begin) (begin) (begin) (begin)])

(constrain strlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strlen (str)
  (loop do-count (i #0)
    (if [getb [+ str i]] {do-count [+ i #1]} i)))

(constrain strvlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strvlen (str)
  (loop do-count (i #1)
    (if (or [getb [+ str [- i #1]]] [getb [+ str i]])
      {do-count [+ i #1]}
      i)))

(constrain null-strrchr (\(r) (` string r)))

(storage null-strrchr (begin))

(constrain strrchr (\(r) (with-vars (a) (`(function (string ,a) string)r)r)))

(function strrchr (s c)
  (loop do-search (t [+ s [strlen s]])
    (if [= [getb t] c]
      t
    (if [= t s]
      null-strrchr
      {do-search [- t #1]}))))

(constrain strcmp (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcmp (s1 s2)
  (loop do-cmp (s1 s1) (s2 s2)
    (if (and [getb s1] [getb s2] [= [getb s1] [getb s2]])
      {do-cmp [+ s1 #1] [+ s2 #1]}
      [- [getb s1] [getb s2]])))

(constrain str= (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function str= (s1 s2) (not [strcmp s1 s2]))

(constrain strcpy (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcpy (dest src) (with return
  {(continuation loop (dest src) (begin
    [setb dest [getb src]]
    (if [getb dest]
      {loop [+ dest #1] [+ src #1]}
      {return (begin)}))) dest src}))

(function memcpy (dest src n) (with return
  {(continuation loop (dest src n)
    (if n
      (begin
        [setb dest [getb src]]
        {loop [+ dest #1] [+ src #1] [- n #1]})
      {return (begin)})) dest src n}))

(function memset (s c n) (with return
  {(continuation loop (s n)
    (if n
      (begin
        [setb s c]
        {loop [+ s #1] [- n #1]})
      {return (begin)})) s n}))

(function isspace (c) (switch = c
  ((space) (true))
  ((ff) (true))
  ((lf) (true))
  ((cr) (true))
  ((ht) (true))
  ((vt) (true))
  (false)))

(;; What follows is essentially wrappers for Linux syscalls. The only twist is
  that if the actual syscall returns an error code, then these functions will
  modify the supplied error buffer and follow the error continuation instead
  of returning.)

(storage file-access-error (begin))

(constrain open (\(r) (with-vars (b) (`(function (string ,b) fd)r)r)))

(function open (path handler)
  (let (ret [syscall (sys-open) path (o-rdonly) (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error path)}
      ret)))

(constrain create (\(r) (with-vars (b) (`(function (string ,b) fd)r)r)))

(function create (path handler)
  (let (ret [syscall (sys-open) path [lor (o-wronly) (o-creat)] [lor (s-irwxu) [lor (s-irwxg) (s-irwxo)]]  (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error path)}
      ret)))

(constrain null-string (\(r) (` string r)))

(storage null-string (begin))

(constrain print (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function print (fd d len handler)
  (let (ret [syscall (sys-write) fd d len (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error null-string)}
      ret)))

(constrain print-str (\(r) (with-vars (b e) (`(function (fd string ,b) ,e)r)r)))

(function print-str (fd str handler) [print fd str [strlen str] handler])

(constrain print-str (\(r) (with-vars (a b e) (`(function (fd ,a ,b) ,e)r)r)))

(function print-char (fd ch handler) [print fd (storage _ ch) #1 handler])

(constrain print-uint (\(r) (with-vars (a b e) (`(function (fd ,a ,b) ,e)r)r)))

(function print-uint (fd i handler) (begin
  (storage j #19)
  (storage str (begin) (begin) (begin))
  (until (i i) [= i #0] [/ i #10] (begin
    [setb [+ str $j] (switch = [rem i #10]
      (#9 (char 9))
      (#8 (char 8))
      (#7 (char 7))
      (#6 (char 6))
      (#5 (char 5))
      (#4 (char 4))
      (#3 (char 3))
      (#2 (char 2))
      (#1 (char 1))
      (char 0))]
    [set j [- $j #1]]))
  [print fd [+ str [+ $j #1]] [- #19 $j] handler]))

(constrain read (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function read (fd buf cnt handler)
  (let (ret [syscall (sys-read) fd buf cnt (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error null-string)}
      ret)))

(constrain close (\(r) (with-vars (a c) (`(function (fd ,a) ,c)r)r)))

(function close (fd handler)
  (let (ret [syscall (sys-close) fd (begin) (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error null-string)}
      ret)))

(constrain size (\(r) (with-vars (a c) (`(function (fd ,a) ,c)r)r)))

(function size (fd handler) (with return (begin
  (storage statbuf (begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)
    (begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin))
  (let (ret [syscall (sys-fstat) fd statbuf (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values file-access-error null-string)}
      {return [get [+ statbuf #48]]})))))

(storage memory-access-error (begin))

(;; Creates a new virtual address mapping of the size in bytes given at len.)

(function mmap (len handler)
  (let (ret [syscall (sys-mmap) #0 len [lor (prot-read) (prot-write)] [lor (map-private) (map-anonymous)] [lnot #0] #0])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values memory-access-error)}
      ret)))

(;; Deletes virtual address mappings coinciding with the range starting with the
  value at ptr and having an extent of the value given at len.)

(function munmap (ptr len handler)
  (let (ret [syscall (sys-munmap) ptr len (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (values memory-access-error)}
      ret)))

(function pad-size (x nearest) (let (r [rem x nearest]) [+ x (if r [- nearest r] #0)]))

(constrain null-element (\(r) (` buffer r)))

(storage null-element (begin))

(;; Creates a new buffer with a minimum capacity in bytes given by the value at
  min-capacity.)

(constrain create-buffer (\(r) (with-vars (a b) (`(function (,a ,b) buffer)r)r)))

(function create-buffer (min-capacity handler) (with return
  (let (len [pad-size [+ min-capacity (buffer-element)] (page-size)])
    (let (reg [mmap len handler]) (begin
      (setf buf-next-elt reg null-element)
      (setf buf-last-elt reg reg)
      (setf buf-curr-pos reg [+ reg (buffer-element)])
      (setf buf-end-pos reg [+ reg len])
      (setf buf-magic-dbg reg (hex DEADBEEFDEADBEEF))
      {return reg})))))

(constrain check-buffer-integrity (\(r) (with-vars (a) (`(function (buffer) ,a)r)r)))

(function check-buffer-integrity (reg) (with return
  {(continuation loop (reg)
      (if [= (@ buf-magic-dbg reg) (hex DEADBEEFDEADBEEF)]
        (let (reg (@ buf-next-elt reg))
          (if [= reg null-element]
            {return (begin)}
            {loop reg}))
        [exit #11])) reg}))

(;; Allocates memory in the buffer at reg of an amount in bytes equal to the
  integer at len. The only way to deallocate this memory is destroy the entire
  buffer at reg.)

(constrain buffer-alloc (\(r) (with-vars (a b d) (`(function (,a buffer ,b) ,d)r)r)))

(function buffer-alloc (len reg handler) (with return
  (let (len [pad-size len (alloc-alignment)]) (begin
    (;;[check-buffer-integrity reg])
    (storage last-elt-ref (@ buf-last-elt reg))
    (if [> [+(@ buf-curr-pos $last-elt-ref)len] (@ buf-end-pos $last-elt-ref)]
      (begin
        (setf buf-next-elt $last-elt-ref [create-buffer [+ len [* #2[-(@ buf-end-pos $last-elt-ref) $last-elt-ref]]] handler])
        (setf buf-last-elt reg (@ buf-next-elt $last-elt-ref))
        [set last-elt-ref (@ buf-next-elt $last-elt-ref)])
      (begin))
    
    (setf buf-curr-pos $last-elt-ref [+(@ buf-curr-pos $last-elt-ref)len])
    {return [-(@ buf-curr-pos $last-elt-ref)len]}))))

(;; Releases the memory associated with the buffer reg. After a call to this
  function, it is invalid to read or write data to the memory allocated on
  this region.)

(constrain destroy-buffer (\(r) (with-vars (b) (`(function (buffer ,b) ())r)r)))

(function destroy-buffer (reg handler) (with return (begin
  (;;[check-buffer-integrity reg])
  {(continuation loop (reg)
    (let (next-reg (@ buf-next-elt reg)) (begin
      [munmap reg [- (@ buf-end-pos reg) reg] handler]
      (if [= next-reg null-element]
        {return (begin)}
        {loop next-reg})))) reg})))

(;; Returns a C-string that is a copy of the one at src. The returned string and
  its dependencies will all reside in the region reg.)

(constrain rstrcpy (\(r) (with-vars (a) (`(function (string buffer ,a) string)r)r)))

(function rstrcpy (src reg handler) (with return
  (let (dest [buffer-alloc [+[strlen src]#1] reg handler]) (begin
    [strcpy dest src]
    {return dest}))))

(;; Returns a list containing the the command line arguments. The returned list
  and its dependencies will all reside in the region reg.)

(constrain argv (\(r) (with-vars (a) (`(function (buffer ,a) (list string))r)r)))

(function argv (reg handler)
  (let (f [open (" /proc/self/cmdline) handler])
    (fallthrough
        (let (buf [buffer-alloc (arg-max) reg cleanup])
        (let (bytes-rem [read f buf (arg-max) cleanup])
        (storage _ no-error
          (loop get-arg (buf buf) (bytes-rem bytes-rem) (args nil)
            (if bytes-rem
              {get-arg [+ buf [+ [strlen buf] #1]] [- bytes-rem [+ [strlen buf] #1]] [cons buf args reg cleanup]}
              [reverse args reg cleanup])))))
      
      (cleanup err
        (let (_ [close f handler])
        (if [= (@0 err) no-error] (@1 err) {handler err}))))))

