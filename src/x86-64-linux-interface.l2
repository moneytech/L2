(;; x86-64 Linux specific constants.)

(function sys-read (l r) [mk# r #0])
(function sys-write (l r) [mk# r #1])
(function sys-open (l r) [mk# r #2])
(function sys-close (l r) [mk# r #3])
(function sys-fstat (l r) [mk# r #5])
(function sys-mmap (l r) [mk# r #9])
(function sys-munmap (l r) [mk# r #11])
(function sys-exit (l r) [mk# r #60])
(function sys-clock-gettime (l r) [mk# r #228])
(function o-rdonly (l r) [mk# r #0])
(function o-wronly (l r) [mk# r #1])
(function o-rdwr (l r) [mk# r #2])
(function o-creat (l r) [mk# r #64])
(function s-irwxu (l r) [mk# r #448])
(function s-irwxg (l r) [mk# r #56])
(function s-irwxo (l r) [mk# r #7])
(function prot-read (l r) [mk# r #1])
(function prot-write (l r) [mk# r #2])
(function prot-exec (l r) [mk# r #4])
(function prot-none (l r) [mk# r #0])
(function map-private (l r) [mk# r #2])
(function map-anonymous (l r) [mk# r #32])
(function page-size (l r) [mk# r #4096])
(function arg-max (l r) (`(page-size)r))
(function clock-process-cputime-id (l r) [mk# r #2])
(function stdin (l r) [mk# r #0])
(function stdout (l r) [mk# r #1])
(function byte (l r) [mk# r #1])
(function unit (l r) [mk# r #8])
(function alloc-alignment (l r) [mk# r #8])

(;; Layout of the header of our endogenous linked list of mmaped regions.)

(function buffer-element (l r) [mk# r #40])

(;; Contains reference to next mmaped region. Is null-element otherwise.)

(function buf-next-elt (l r) [property #0 8b (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to last mmaped region in buffer. Field required to reduce allocation time.)

(function buf-last-elt (l r) [property #8 8b (\(r) (` buffer r)) (\(s r) (` buffer r)) l r])

(;; Contains reference to next aligned free memory in buffer element.)

(function buf-curr-pos (l r) [property #16 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains reference to the end of the buffer element.)

(function buf-end-pos (l r) [property #24 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; Contains magic debug value.)

(function buf-magic-dbg (l r) [property #32 8b (\(r) (` buffer r)) (\(s r) [var r]) l r])

(;; --------------------------------------------------------------------------)

(function exit (code) [syscall (sys-exit) code (begin) (begin) (begin) (begin) (begin)])

(constrain strlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strlen (str) (with return
  {(continuation loop (i)
    (if [getb [+ str i]]
      {loop [+ i #1]}
      {return i})) #0}))

(constrain strvlen (\(r) (with-vars (a) (`(function (string) ,a)r)r)))

(function strvlen (str) (with return
  {(continuation loop (i)
    (if (or [getb [+ str [- i #1]]] [getb [+ str i]])
      {loop [+ i #1]}
      {return i})) #1}))

(storage null-strrchr (begin))

(function strrchr (s c) (with return
  (let (t [+ s [strlen s]]) (begin
    {(continuation loop (t)
      (if [= [getb t] c]
        {return t}
      (if [= t s]
        {return null-strrchr}
        {loop [- t #1]}))) t}))))

(constrain strcmp (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcmp (s1 s2) (with return
  {(continuation loop (s1 s2)
    (if (and [getb s1] [getb s2] [= [getb s1] [getb s2]])
      {loop [+ s1 #1] [+ s2 #1]}
      {return [- [getb s1] [getb s2]]})) s1 s2}))

(constrain str= (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function str= (s1 s2) (not [strcmp s1 s2]))

(constrain strcpy (\(r) (with-vars (a) (`(function (string string) ,a)r)r)))

(function strcpy (dest src) (with return
  {(continuation loop (dest src) (begin
    [setb dest [getb src]]
    (if [getb dest]
      {loop [+ dest #1] [+ src #1]}
      {return (begin)}))) dest src}))

(function memcpy (dest src n) (with return
  {(continuation loop (dest src n)
    (if n
      (begin
        [setb dest [getb src]]
        {loop [+ dest #1] [+ src #1] [- n #1]})
      {return (begin)})) dest src n}))

(function memset (s c n) (with return
  {(continuation loop (s n)
    (if n
      (begin
        [setb s c]
        {loop [+ s #1] [- n #1]})
      {return (begin)})) s n}))

(function isspace (c) (switch = c
  ((space) (true))
  ((ff) (true))
  ((lf) (true))
  ((cr) (true))
  ((ht) (true))
  ((vt) (true))
  (false)))

(;; What follows is essentially wrappers for Linux syscalls. The only twist is
  that if the actual syscall returns an error code, then these functions will
  modify the supplied error buffer and follow the error continuation instead
  of returning.)

(storage file-access-error (begin))

(constrain open (\(r) (with-vars (b c) (`(function (string ,b ,c) fd)r)r)))

(function open (path handler err)
  (let (ret [syscall (sys-open) path (o-rdonly) (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error path)}
      ret)))

(constrain create (\(r) (with-vars (b c) (`(function (string ,b ,c) fd)r)r)))

(function create (path handler err)
  (let (ret [syscall (sys-open) path [lor (o-wronly) (o-creat)] [lor (s-irwxu) [lor (s-irwxg) (s-irwxo)]]  (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error path)}
      ret)))

(constrain null-string (\(r) (` string r)))

(storage null-string (begin))

(constrain print (\(r) (with-vars (a b c d e) (`(function (fd ,a ,b ,c ,d) ,e)r)r)))

(function print (fd d len handler err)
  (let (ret [syscall (sys-write) fd d len (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error null-string)}
      ret)))

(constrain print-str (\(r) (with-vars (b c e) (`(function (fd string ,b ,c) ,e)r)r)))

(function print-str (fd str handler err) [print fd str [strlen str] handler err])

(constrain print-str (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function print-char (fd ch handler err) [print fd (storage _ ch) #1 handler err])

(constrain print-uint (\(r) (with-vars (a b c e) (`(function (fd ,a ,b ,c) ,e)r)r)))

(function print-uint (fd i handler err) (begin
  (storage j #19)
  (storage str (begin) (begin) (begin))
  (until (i i) [= i #0] [/ i #10] (begin
    [setb [+ str $j] (switch = [rem i #10]
      (#9 (char 9))
      (#8 (char 8))
      (#7 (char 7))
      (#6 (char 6))
      (#5 (char 5))
      (#4 (char 4))
      (#3 (char 3))
      (#2 (char 2))
      (#1 (char 1))
      (char 0))]
    [set j [- $j #1]]))
  [print fd [+ str [+ $j #1]] [- #19 $j] handler err]))

(constrain read (\(r) (with-vars (a b c d e) (`(function (fd ,a ,b ,c ,d) ,e)r)r)))

(function read (fd buf cnt handler err)
  (let (ret [syscall (sys-read) fd buf cnt (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error null-string)}
      ret)))

(constrain close (\(r) (with-vars (a b c) (`(function (fd ,a ,b) ,c)r)r)))

(function close (fd handler err)
  (let (ret [syscall (sys-close) fd (begin) (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error null-string)}
      ret)))

(constrain size (\(r) (with-vars (a b c) (`(function (fd ,a ,b) ,c)r)r)))

(function size (fd handler err) (with return (begin
  (storage statbuf (begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)
    (begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin)(begin))
  (let (ret [syscall (sys-fstat) fd statbuf (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err file-access-error null-string)}
      {return [get [+ statbuf #48]]})))))

(storage memory-access-error (begin))

(;; Creates a new virtual address mapping of the size in bytes given at len.)

(function mmap (len handler err)
  (let (ret [syscall (sys-mmap) #0 len [lor (prot-read) (prot-write)] [lor (map-private) (map-anonymous)] [lnot #0] #0])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err memory-access-error)}
      ret)))

(;; Deletes virtual address mappings coinciding with the range starting with the
  value at ptr and having an extent of the value given at len.)

(function munmap (ptr len handler err)
  (let (ret [syscall (sys-munmap) ptr len (begin) (begin) (begin) (begin)])
    (if (and [<= [- #0 #4095] ret] [<= ret [- #0 #1]])
      {handler (sets err memory-access-error)}
      ret)))

(function pad-size (x nearest) (let (r [rem x nearest]) [+ x (if r [- nearest r] #0)]))

(constrain null-element (\(r) (` buffer r)))

(storage null-element (begin))

(;; Creates a new buffer with a minimum capacity in bytes given by the value at
  min-capacity.)

(constrain create-buffer (\(r) (with-vars (a b c) (`(function (,a ,b ,c) buffer)r)r)))

(function create-buffer (min-capacity handler err) (with return
  (let (len [pad-size [+ min-capacity (buffer-element)] (page-size)])
    (let (reg [mmap len handler err]) (begin
      (setf buf-next-elt reg null-element)
      (setf buf-last-elt reg reg)
      (setf buf-curr-pos reg [+ reg (buffer-element)])
      (setf buf-end-pos reg [+ reg len])
      (setf buf-magic-dbg reg (hex DEADBEEFDEADBEEF))
      {return reg})))))

(constrain check-buffer-integrity (\(r) (with-vars (a) (`(function (buffer) ,a)r)r)))

(function check-buffer-integrity (reg) (with return
  {(continuation loop (reg)
      (if [= (@ buf-magic-dbg reg) (hex DEADBEEFDEADBEEF)]
        (let (reg (@ buf-next-elt reg))
          (if [= reg null-element]
            {return (begin)}
            {loop reg}))
        [exit #11])) reg}))

(;; Allocates memory in the buffer at reg of an amount in bytes equal to the
  integer at len. The only way to deallocate this memory is destroy the entire
  buffer at reg.)

(constrain buffer-alloc (\(r) (with-vars (a b c d) (`(function (,a buffer ,b ,c) ,d)r)r)))

(function buffer-alloc (len reg handler err) (with return
  (let (len [pad-size len (alloc-alignment)]) (begin
    (;;[check-buffer-integrity reg])
    (storage last-elt-ref (@ buf-last-elt reg))
    (if [> [+(@ buf-curr-pos $last-elt-ref)len] (@ buf-end-pos $last-elt-ref)]
      (begin
        (setf buf-next-elt $last-elt-ref [create-buffer [+ len [* #2[-(@ buf-end-pos $last-elt-ref) $last-elt-ref]]] handler err])
        (setf buf-last-elt reg (@ buf-next-elt $last-elt-ref))
        [set last-elt-ref (@ buf-next-elt $last-elt-ref)])
      (begin))
    
    (setf buf-curr-pos $last-elt-ref [+(@ buf-curr-pos $last-elt-ref)len])
    {return [-(@ buf-curr-pos $last-elt-ref)len]}))))

(;; Releases the memory associated with the buffer reg. After a call to this
  function, it is invalid to read or write data to the memory allocated on
  this region.)

(constrain destroy-buffer (\(r) (with-vars (b c d) (`(function (buffer ,b ,c) ,d)r)r)))

(function destroy-buffer (reg handler err) (with return (begin
  (;;[check-buffer-integrity reg])
  {(continuation loop (reg)
    (let (next-reg (@ buf-next-elt reg)) (begin
      [munmap reg [- (@ buf-end-pos reg) reg] handler err]
      (if [= next-reg null-element]
        {return (begin)}
        {loop next-reg})))) reg})))

(;; Returns a C-string that is a copy of the one at src. The returned string and
  its dependencies will all reside in the region reg.)

(constrain rstrcpy (\(r) (with-vars (a b) (`(function (string buffer ,a ,b) string)r)r)))

(function rstrcpy (src reg handler err) (with return
  (let (dest [buffer-alloc [+[strlen src]#1] reg handler err]) (begin
    [strcpy dest src]
    {return dest}))))

(;; Returns a list containing the the command line arguments. The returned list
  and its dependencies will all reside in the region reg.)

(constrain argv (\(r) (with-vars (a b) (`(function (buffer ,a ,b) (list string))r)r)))

(function argv (reg handler err) (with return (begin
  (storage f (begin))
  (storage retval (begin))
  (fallthrough
    (begin
      [set f [open (" /proc/self/cmdline) handler err]]
      (storage buf [buffer-alloc (arg-max) reg cleanup err])
      (storage bytes-rem [read $f $buf (arg-max) cleanup err])
      [set retval (with break {(continuation loop (buf bytes-rem args)
        (if bytes-rem
          {loop [+ buf [+ [strlen buf] #1]] [- bytes-rem [+ [strlen buf] #1]] [cons buf args reg cleanup err]}
          {break [reverse args reg cleanup err]})) $buf $bytes-rem nil})])
          
    (cleanup (begin
      [close $f handler err]
      (if [= (@0 err) no-error] {return $retval} {handler (begin)})))))))

