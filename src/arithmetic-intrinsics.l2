(ignore
  The following function wraps the arithmetic intrinsics so that the addresses of
  functions like + and - can be taken like non-intrinsic functions.)

(constrain wrap-arithmetic-intrinsics (\ r (with-vars (a) (`(function (buffer ,a) (list expr))r)r)))

(function wrap-arithmetic-intrinsics (buf handler)
  (substitute (.. buf handler) (list
    ([make-unary-intrinsic [rstrcpy (" getb) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get1b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get2b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get4b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get8b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get) ..] ..]
    [make-binary-intrinsic [rstrcpy (" setb) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set1b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set2b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set4b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set8b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set) ..] ..]
    [make-binary-intrinsic [rstrcpy (" +) ..] ..]
    [make-binary-intrinsic [rstrcpy (" -) ..] ..]
    [make-binary-intrinsic [rstrcpy (" *) ..] ..]
    [make-binary-intrinsic [rstrcpy (" /) ..] ..]
    [make-binary-intrinsic [rstrcpy (" rem) ..] ..]
    [make-binary-intrinsic [rstrcpy (" =) ..] ..]
    [make-binary-intrinsic [rstrcpy (" <) ..] ..]
    [make-binary-intrinsic [rstrcpy (" >) ..] ..]
    [make-binary-intrinsic [rstrcpy (" <<) ..] ..]
    [make-binary-intrinsic [rstrcpy (" >>) ..] ..]
    [make-binary-intrinsic [rstrcpy (" bor) ..] ..]
    [make-binary-intrinsic [rstrcpy (" band) ..] ..]
    [make-unary-intrinsic [rstrcpy (" bnot) ..] ..]) ..)))

(ignore
  The following function generates inline assembly for the following functions: getb,
  get1b, get2b, get4b, get8b, get, setb, set1b, set2b, set4b, set8b, set, +, -, *, /, rem,
  =, <, >, <<, >>, bor, band, bnot. This function only applies to invocations of functions
  with the aforementioned names that are undefined in the invocation's lexical
  environment.)

(constrain generate-arithmetic-intrinsics
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-arithmetic-intrinsics (n gens c relocs r handler)
  (substitute (.. r handler)
    (and (and [= (@ expr-type n) (-invoke-)] [= (@ expr-type (@ expr-reference n)) (-symbol-)]
        [= (@ bndg-state (@ expr-symbol-binding-aug (@ expr-reference n))) (undefined-state)])
      (switch str= (@ bndg-name (@ expr-symbol-binding-aug (@ expr-reference n)))
        ((" getb) (" get1b) (let
            (arg1 [@car (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-movzx)
            ([bndg->op expr-val-bndg relocs ..][make-mem-op #1(r10)(none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..]
          (true)))))
        
        ((" get2b) (let
            (arg1 [@car (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-movzx)
            ([bndg->op expr-val-bndg relocs ..][make-mem-op #2(r10)(none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..]
          (true)))))
        
        ((" get4b) (let
            (arg1 [@car (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-movzx)
            ([bndg->op expr-val-bndg relocs ..][make-mem-op #4(r10)(none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..]
          (true)))))
        
        ((" get8b) (" get) (let
            (arg1 [@car (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov)
            ([bndg->op expr-val-bndg relocs ..][make-mem-op #8(r10)(none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..]
          (true)))))
        
        ((" setb) (" set1b) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov)
            ([make-mem-op #1(r10)(none)#0 #0 #4 ..][bndg->partial-op #1 arg2-val-bndg relocs ..][make-reg-op(r11l)..]) ..) c ..]
          (true)))))
        
        ((" set2b) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov)
            ([make-mem-op #2(r10)(none)#0 #0 #4 ..][bndg->partial-op #2 arg2-val-bndg relocs ..][make-reg-op(r11w)..]) ..) c ..]
          (true)))))
        
        ((" set4b) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov)
            ([make-mem-op #4(r10)(none)#0 #0 #4 ..][bndg->partial-op #4 arg2-val-bndg relocs ..][make-reg-op(r11d)..]) ..) c ..]
          (true)))))
        
        ((" set8b) (" set) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov)
            ([make-mem-op #8(r10)(none)#0 #0 #4 ..][bndg->partial-op #8 arg2-val-bndg relocs ..][make-reg-op(r11)..]) ..) c ..]
          (true)))))
          
        ((" +) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
          [prepend (make-instrN (x86-add)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
          (true)))))
        
        ((" -) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-sub)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          (true)))))
        
        ((" *) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mul) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]
          (true)))))
        
        ((" /) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]
          (true)))))
        
        ((" rem) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rdx) ..]) ..) c ..]
          (true)))))
        
        ((" =) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-sub)
            ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setz) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))))
        
        ((" <) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-sub)
            ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setc) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))))
        
        ((" >) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-sub)
            ([bndg->op arg2-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setc) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))))
        
        ((" <<) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
          [prepend (make-instrN (x86-shl) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]
          (true)))))
        
        ((" >>) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r10)..])..) c ..]
          [prepend (make-instrN (x86-shr) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]
          (true)))))
        
        ((" bor) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN(x86-or)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          (true)))))
        
        ((" band) (let
            (arg1 [@car (@ expr-arguments n)])
            (arg2 [@cadr (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (arg2-val-bndg (@ expr-binding-aug arg2))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [generate-expression arg2 gens c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..] [bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN(x86-and)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          (true)))))
        
        ((" bnot) (let
            (arg1 [@car (@ expr-arguments n)]) (let
            (arg1-val-bndg (@ expr-binding-aug arg1))
            (expr-val-bndg (@ expr-binding-aug n)) (do
          [generate-expression arg1 gens c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN (x86-not) ([bndg->op expr-val-bndg relocs ..]) ..) c ..]
          (true)))))
          
        (false)))))

(constrain place-arithmetic-intrinsics (\ r (with-vars (b c) (`(function (expr ,b (list placer) (values ,b reg-use-vec)) ,c)r)r)))

(function place-arithmetic-intrinsics (n offset plcs ret-val)
  (and (and [= (@ expr-type n) (-invoke-)] [= (@ expr-type (@ expr-reference n)) (-symbol-)]
      [= (@ bndg-state (@ expr-symbol-binding-aug (@ expr-reference n))) (undefined-state)])
    (switch str= (@ bndg-name (@ expr-symbol-binding-aug (@ expr-reference n)))
      ((" getb) (" get1b) (" get2b) (" get4b) (" get8b) (" get) (" bnot) (let
          (arg1 [@car (@ expr-arguments n)]) (let
          (arg1-val-bndg (@ expr-binding-aug arg1))
          (expr-val-bndg (@ expr-binding-aug n))
        (let (sub-expr-offset [- offset (word-size)])
        (bind (bottom-offset in-use) [place-temp-bindings arg1 sub-expr-offset plcs ret-val]
        (let (in-use [bor in-use (hex FFFFFFFFFFFF0C31)])
        (let (in-use [binding-to-register/memory arg1-val-bndg sub-expr-offset in-use]) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-reference n)) (nil-storage))
        (values (use-storage ret-val) bottom-offset in-use)
        (true)))))))))
      
      ((" setb) (" set1b) (" set2b) (" set4b) (" set8b) (" set) (" bor) (" band) (" +) (" -) (" =) (" <) (" >) (let
          (arg1 [@car (@ expr-arguments n)])
          (arg2 [@cadr (@ expr-arguments n)]) (let
          (arg1-val-bndg (@ expr-binding-aug arg1))
          (arg2-val-bndg (@ expr-binding-aug arg2))
          (expr-val-bndg (@ expr-binding-aug n))
        (let (sub-expr-offset [- offset [* #2(word-size)]])
        (bind (bottom-offset1 in-use1) [place-temp-bindings arg1 sub-expr-offset plcs bind]
        (bind (bottom-offset2 in-use2) [place-temp-bindings arg2 sub-expr-offset plcs bind]
        (let (bottom-offset [min bottom-offset1 bottom-offset2])
        (let (in-use [bor [bor in-use1 in-use2] (hex FFFFFFFFFFFF0C31)])
        (let (in-use [binding-to-register/memory arg1-val-bndg [- offset [* #1(word-size)]] in-use])
        (let (in-use [binding-to-register/memory arg2-val-bndg [- offset [* #2(word-size)]] in-use]) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-reference n)) (nil-storage))
        (values (use-storage ret-val) bottom-offset in-use)
        (true))))))))))))
      
      (false))))

