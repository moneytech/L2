(ignore
  The following function wraps the arithmetic intrinsics so that the addresses of
  functions like + and - can be taken like non-intrinsic functions.)

(constrain wrap-arithmetic-intrinsics (\ r (with-vars (a) (`(function (buffer ,a) (list expr))r)r)))

(function wrap-arithmetic-intrinsics (buf handler)
  (substitute (.. buf handler) (list
    ([make-unary-intrinsic [rstrcpy (" getb) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get1b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get2b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get4b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get8b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get) ..] ..]
    [make-binary-intrinsic [rstrcpy (" setb) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set1b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set2b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set4b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set8b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set) ..] ..]
    [make-binary-intrinsic [rstrcpy (" +) ..] ..]
    [make-binary-intrinsic [rstrcpy (" -) ..] ..]
    [make-binary-intrinsic [rstrcpy (" *) ..] ..]
    [make-binary-intrinsic [rstrcpy (" /) ..] ..]
    [make-binary-intrinsic [rstrcpy (" rem) ..] ..]
    [make-binary-intrinsic [rstrcpy (" =) ..] ..]
    [make-binary-intrinsic [rstrcpy (" <) ..] ..]
    [make-binary-intrinsic [rstrcpy (" >) ..] ..]
    [make-binary-intrinsic [rstrcpy (" <<) ..] ..]
    [make-binary-intrinsic [rstrcpy (" >>) ..] ..]
    [make-binary-intrinsic [rstrcpy (" bor) ..] ..]
    [make-binary-intrinsic [rstrcpy (" band) ..] ..]
    [make-unary-intrinsic [rstrcpy (" bnot) ..] ..]) ..)))

(constrain undefined-symbol? (\ r (with-vars (a) (`(function (expr) ,a)r)r)))

(function undefined-symbol? (n)
  (and [= (@ expr-type n) (-symbol-)]
    [= (@ bndg-state (@ expr-reference n)) (undefined-state)]))

(constrain symbol-name= (\ r (with-vars (a) (`(function (string expr) ,a)r)r)))

(function symbol-name= (str n)
  [str= str (@ bndg-name (@ expr-reference n))])

(constrain variable (\ r (with-vars (a b) (`(function ((ref ,b) ,b) ,a)r)r)))

(function variable (var val) (do [set var val] (true)))

(constrain match-undefined-unary-invoke (\ r (with-vars (a) (`(function ((ref string) (ref expr) expr) ,a)r)r)))

(function match-undefined-unary-invoke (name arg1 n)
  (match-property
    (expr-type (%[= (-invoke-)]))
    (expr-target (%(match-property
      (expr-type (%[= (-symbol-)]))
      (expr-reference (%(match-property
        (bndg-state (%[= (undefined-state)]))
        (bndg-name (%[variable name]))))))))
    (expr-arguments (%(match-list
      (%[variable arg1])))) n))

(constrain initialize-unary-arithmetic-operators
  (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-unary-arithmetic-operators (n offset inits ret-val)
  (bind-if [match-undefined-unary-invoke name arg1 n] (name arg1)
    (let
        (arg1-val-bndg (@ expr-binding-aug $arg1))
        (expr-val-bndg (@ expr-binding-aug n))
      (switch str= $name
        ((" getb) (" get1b) (" get2b) (" get4b) (" get8b) (" get) (" bnot)
          (let (sub-expr-offset [- offset (word-size)])
          (bind (bottom-offset in-use) [initialize-expression $arg1 sub-expr-offset inits ret-val]
          (let (in-use [bor in-use (hex FFFFFFFFFFFF0831)])
          (let (in-use [expr-to-register/memory $arg1 sub-expr-offset in-use]) (do
          (setf bndg-size (@ expr-binding-aug n) (word-size))
          (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
          (setf expr-generator n [function->generator generate-unary-arithmetic-operators])
          (values (use-storage ret-val) bottom-offset in-use)
          (true)))))))
        
        (false)))
    (false)))

(ignore
  If the given binding is not already in a register, a move is generated from the binding
  to the given register. Returns the register in which the value at the binding can be
  found.)

(constrain generate-move-to-register
  (\ r (with-vars (a) (`(function (register bndg-aug (ref (list instr)) (ref (list reloc)) buffer ,a) register)r)r)))

(function generate-move-to-register (reg bndg c relocs r handler)
  (substitute (.. r handler)
    (if [= (@ bndg-storage bndg) (register-storage)]
      (@ bndg-offset bndg)
      (do
        [prepend (make-instrN (x86-mov) ([make-reg-op reg ..] [bndg->op bndg relocs ..]) ..) c ..]
        reg))))

(ignore
  The following function generates inline assembly for the following functions: getb,
  get1b, get2b, get4b, get8b, get, setb, set1b, set2b, set4b, set8b, set, +, -, *, /, rem,
  =, <, >, <<, >>, bor, band, bnot. This function only applies to invocations of functions
  with the aforementioned names that are undefined in the invocation's lexical
  environment.)

(constrain generate-unary-arithmetic-operators
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-unary-arithmetic-operators (n c relocs r handler)
  (substitute (.. r handler)
    (bind-if [match-undefined-unary-invoke name arg1 n] (name arg1)
      (let
        (arg1-val-bndg (@ expr-binding-aug $arg1))
        (expr-val-bndg (@ expr-binding-aug n))
        
      (switch str= $name
        ((" getb) (" get1b) (do
          [generate-expression $arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN(x86-movzx)
              ([bndg->op expr-val-bndg relocs ..][make-mem-op #1 arg1-reg (none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..])
          (true)))
        
        ((" get2b) (do
          [generate-expression $arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-movzx)
              ([bndg->op expr-val-bndg relocs ..][make-mem-op #2 arg1-reg (none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..])
          (true)))
        
        ((" get4b) (do
          [generate-expression $arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-movzx)
              ([bndg->op expr-val-bndg relocs ..][make-mem-op #4 arg1-reg (none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..])
          (true)))
        
        ((" get8b) (" get) (do
          [generate-expression $arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([bndg->op expr-val-bndg relocs ..][make-mem-op #8 arg1-reg (none)#0 #0 #4 ..][make-reg-op(r11)..])..) c ..])
          (true)))
        
        ((" bnot) (do
          [generate-expression $arg1 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN (x86-not) ([bndg->op expr-val-bndg relocs ..]) ..) c ..]
          (true)))
          
        (false)))
      (false))))

(constrain match-undefined-binary-invoke (\ r (with-vars (a) (`(function ((ref string) (ref expr) (ref expr) expr) ,a)r)r)))

(function match-undefined-binary-invoke (name arg1 arg2 n)
  (match-property
    (expr-type (%[= (-invoke-)]))
    (expr-target (%(match-property
      (expr-type (%[= (-symbol-)]))
      (expr-reference (%(match-property
        (bndg-state (%[= (undefined-state)]))
        (bndg-name (%[variable name]))))))))
    (expr-arguments (%(match-list
      (%[variable arg1])
      (%[variable arg2])))) n))

(constrain initialize-binary-arithmetic-operators
  (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-binary-arithmetic-operators (n offset inits ret-val)
  (bind-if [match-undefined-binary-invoke name arg1 arg2 n] (name arg1 arg2)
    (let
      (arg1-val-bndg (@ expr-binding-aug $arg1))
      (arg2-val-bndg (@ expr-binding-aug $arg2))
      (expr-val-bndg (@ expr-binding-aug n))
      
    (switch str= $name
      ((" setb) (" set1b) (" set2b) (" set4b) (" set8b) (" set) (" bor) (" band) (" +) (" -) (" =) (" <) (" >)
        (let (sub-expr-offset [- offset [* #2(word-size)]])
        (bind (bottom-offset1 in-use1) [initialize-expression $arg1 sub-expr-offset inits bind]
        (bind (bottom-offset2 in-use2) [initialize-expression $arg2 sub-expr-offset inits bind]
        (let (bottom-offset [min bottom-offset1 bottom-offset2])
        (let (in-use [bor [bor in-use1 in-use2] (hex FFFFFFFFFFFF0C31)])
        (let (in-use [expr-to-register/memory $arg1 [- offset [* #1(word-size)]] in-use])
        (let (in-use [expr-to-register/memory $arg2 [- offset [* #2(word-size)]] in-use]) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
        (setf expr-generator n [function->generator generate-binary-arithmetic-operators])
        (values (use-storage ret-val) bottom-offset in-use)
        (true))))))))))
      
      ((" /) (" rem)
        (let (sub-expr-offset [- offset [* #2(word-size)]])
        (bind (bottom-offset1 in-use1) [initialize-expression $arg1 sub-expr-offset inits bind]
        (bind (bottom-offset2 in-use2) [initialize-expression $arg2 sub-expr-offset inits bind]
        (let (bottom-offset [min bottom-offset1 bottom-offset2])
        (let (in-use [bor [bor in-use1 in-use2] (hex FFFFFFFFFFFF0034)])
        (bind (arg1-success? in-use) [try-binding-to-register arg1-val-bndg (rax) in-use bind]
        (let (in-use (if arg1-success? in-use [expr-to-register/memory $arg1 [- offset [* #1(word-size)]] in-use]))
        (let (in-use [expr-to-register/memory $arg2 [- offset [* #2(word-size)]] in-use]) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
        (setf expr-generator n [function->generator generate-binary-arithmetic-operators])
        (values (use-storage ret-val) bottom-offset in-use)
        (true)))))))))))
      
      ((" *)
        (let (sub-expr-offset [- offset [* #2(word-size)]])
        (bind (bottom-offset1 in-use1) [initialize-expression $arg1 sub-expr-offset inits bind]
        (bind (bottom-offset2 in-use2) [initialize-expression $arg2 sub-expr-offset inits bind]
        (let (bottom-offset [min bottom-offset1 bottom-offset2])
        (let (in-use [bor [bor in-use1 in-use2] (hex FFFFFFFFFFFF0030)])
        (bind (arg1-success? in-use) [try-binding-to-register arg1-val-bndg (rax) in-use bind]
        (let (in-use (if arg1-success? in-use [expr-to-register/memory $arg1 [- offset [* #1(word-size)]] in-use]))
        (let (in-use [expr-to-register/memory $arg2 [- offset [* #2(word-size)]] in-use]) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
        (setf expr-generator n [function->generator generate-binary-arithmetic-operators])
        (values (use-storage ret-val) bottom-offset [bor in-use (hex 0000000000000004)])
        (true)))))))))))
      
      ((" <<) (" >>)
        (let (sub-expr-offset [- offset [* #2(word-size)]])
        (bind (bottom-offset1 in-use1) [initialize-expression $arg1 sub-expr-offset inits bind]
        (bind (bottom-offset2 in-use2) [initialize-expression $arg2 sub-expr-offset inits bind]
        (let (bottom-offset [min bottom-offset1 bottom-offset2])
        (let (in-use [bor [bor in-use1 in-use2] (hex FFFFFFFFFFFF0830)])
        (let (in-use [expr-to-register/memory $arg1 [- offset [* #1(word-size)]] in-use])
        (bind (arg2-success? in-use) [try-binding-to-register arg2-val-bndg (rcx) in-use bind]
        (let (in-use (if arg2-success? in-use [expr-to-register/memory $arg2 [- offset [* #2(word-size)]] in-use])) (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
        (setf expr-generator n [function->generator generate-binary-arithmetic-operators])
        (values (use-storage ret-val) bottom-offset in-use)
        (true)))))))))))
      
      (false)))
    (false)))

(constrain generate-binary-arithmetic-operators
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-binary-arithmetic-operators (n c relocs r handler)
  (substitute (.. r handler)
    (bind-if [match-undefined-binary-invoke name arg1 arg2 n] (name arg1 arg2)
      (let
        (arg1-val-bndg (@ expr-binding-aug $arg1))
        (arg2-val-bndg (@ expr-binding-aug $arg2))
        (expr-val-bndg (@ expr-binding-aug n))
        
      (switch str= $name
        ((" setb) (" set1b) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #1 arg1-reg (none)#0 #0 #4 ..][bndg->partial-op #1 arg2-val-bndg relocs ..][make-reg-op(r11l)..]) ..) c ..])
          (true)))
        
        ((" set2b) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #2 arg1-reg (none)#0 #0 #4 ..][bndg->partial-op #2 arg2-val-bndg relocs ..][make-reg-op(r11w)..]) ..) c ..])
          (true)))
        
        ((" set4b) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #4 arg1-reg (none)#0 #0 #4 ..][bndg->partial-op #4 arg2-val-bndg relocs ..][make-reg-op(r11d)..]) ..) c ..])
          (true)))
        
        ((" set8b) (" set) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #8 arg1-reg (none)#0 #0 #4 ..][bndg->partial-op #8 arg2-val-bndg relocs ..][make-reg-op(r11)..]) ..) c ..])
          (true)))
          
        ((" +) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
          [prepend (make-instrN (x86-add)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
          (true)))
        
        ((" -) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-sub)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          (true)))
        
        ((" *) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mul) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]
          (true)))
        
        ((" /) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]
          (true)))
        
        ((" rem) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg->op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (rdx) ..]) ..) c ..]
          (true)))
        
        ((" =) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-cmp)
            ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setz) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))
        
        ((" <) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-cmp)
            ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setc) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))
        
        ((" >) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg->op expr-val-bndg relocs ..][bndg->op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN(x86-cmp)
            ([bndg->op arg2-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-setc) ([bndg->partial-op #1 expr-val-bndg relocs ..]) ..) c ..]
          (true)))
        
        ((" <<) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
          [prepend (make-instrN (x86-shl) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]
          (true)))
        
        ((" >>) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg->op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-shr) ([bndg->op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]
          (true)))
        
        ((" bor) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN(x86-or)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          (true)))
        
        ((" band) (do
          [generate-expression $arg1 c relocs ..]
          [generate-expression $arg2 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..] [bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN(x86-and)
            ([bndg->op expr-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          (true)))
          
        (false)))
      (false))))

(function sbyte? (val)
  (or [= val [band val (hex 000000000000007F)]] [= val [bor val (hex FFFFFFFFFFFFFF80)]]))

(function sword? (val)
  (or [= val [band val (hex 000000007FFFFFFF)]] [= val [bor val (hex FFFFFFFF80000000)]]))

(constrain match-arithmetic-if
  (\ r (with-vars (a) (`(function ((ref string) (ref expr) (ref expr) (ref expr) (ref expr) expr) ,a)r)r)))

(function match-arithmetic-if (name arg1 arg2 consequent alternate n)
  (match-property
    (expr-type (%[= (-if-)]))
    (expr-condition
      (%(guard-match
        (%[match-undefined-binary-invoke name arg1 arg2])
        (switch str= $name ((" <) (" >) (" =) (true)) (false)))))
    (expr-consequent (%[variable consequent]))
    (expr-alternate (%[variable alternate])) n))

(constrain initialize-arithmetic-if-bindings
  (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-arithmetic-if-bindings (n offset inits ret-val)
  (bind-if [match-arithmetic-if name arg1 arg2 consequent alternate n]
    (name arg1 arg2 consequent alternate)
      (let (offset [- offset [* #2(word-size)]]) (do
      (setf expr-binding-aug $consequent (@ expr-binding-aug n))
      (setf expr-binding-aug $alternate (@ expr-binding-aug n))
      (bind (bottom-offset in-use) [initialize-expression $arg1 offset inits bind]
      (bind (bottom-offset' in-use') [initialize-expression $arg2 offset inits bind]
      (bind (bottom-offset'' in-use'') [initialize-expression $consequent offset inits bind]
      (bind (bottom-offset''' in-use''') [initialize-expression $alternate offset inits bind]
      (let (in-use [bor in-use [bor in-use' [bor in-use'' [bor in-use''' (hex FFFFFFFFFFFF0830)]]]])
      (let (bottom-offset [min bottom-offset [min bottom-offset' [min bottom-offset'' bottom-offset''']]])
      (let (in-use [expr-to-register/memory $arg1 [+ offset [* #1(word-size)]] in-use])
      (let (in-use [expr-to-register/memory $arg2 [+ offset [* #0(word-size)]] in-use]) (do
      (setf bndg-storage (@ expr-binding-aug (@ expr-condition n)) (nil-storage))
      (setf bndg-storage (@ expr-binding-aug (@ expr-target (@ expr-condition n))) (nil-storage))
      (setf expr-generator n [function->generator generate-arithmetic-if])
      (values (use-storage ret-val) bottom-offset in-use)
      (setf bndg-size (@ expr-binding-aug n) (word-size))
      (true))))))))))))
    (false)))

(constrain generate-arithmetic-if
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-arithmetic-if (n c relocs r handler)
  (substitute (.. r handler)
    (bind-if [match-arithmetic-if name arg1 arg2 consequent alternate n] (name arg1 arg2 consequent alternate)
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (arg1-val-bndg (@ expr-binding-aug $arg1))
          (arg2-val-bndg (@ expr-binding-aug $arg2))
          (consequent-val-bndg (@ expr-binding-aug $consequent))
          (alternate-val-bndg (@ expr-binding-aug $alternate))
          (alternate-instr-bndg [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..]) (do
        [generate-expression $arg1 c relocs ..]
        [generate-expression $arg2 c relocs ..]
        (switch str= $name
          ((" =) (do
            [prepend (make-instrN(x86-cmp)
              ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
            [prepend (make-instrN (x86-jnz) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]))
          ((" <) (do
            [prepend (make-instrN(x86-cmp)
              ([bndg->op arg1-val-bndg relocs ..][bndg->op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
            [prepend (make-instrN (x86-jnc) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]))
          ((" >) (do
            [prepend (make-instrN(x86-cmp)
              ([bndg->op arg2-val-bndg relocs ..][bndg->op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
            [prepend (make-instrN (x86-jnc) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]))
          (ignore))
        [generate-expression $consequent c relocs ..]
        [generate-bndg-bndg-move expr-val-bndg consequent-val-bndg (r11) c relocs ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-instr-bndg ..] c ..]
        [generate-expression $alternate c relocs ..]
        [generate-bndg-bndg-move expr-val-bndg alternate-val-bndg (r11) c relocs ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true)))
      (false))))

(function match-get-base+offset (name base offset n)
  (bind-if (match-property
      (expr-type (%[= (-invoke-)]))
      (expr-target (%[undefined-symbol?]))
      (expr-target (%(match-property (expr-reference
        (%(match-property (bndg-name (%[variable name]))))))))
      (expr-arguments (%(match-list
        (%(match-property
            (expr-type (%[= (-invoke-)]))
            (expr-target (%[undefined-symbol?]))
            (expr-target (%[symbol-name= (" +)]))
            (expr-arguments
              (%(guard-match
                  (%(match-list
                      (%[variable addr-part1])
                      (%[variable addr-part2])))
                  (or
                    [= (@ expr-type $addr-part1) (-literal-)]
                    [= (@ expr-type $addr-part2) (-literal-)]))))))))) n)
    (addr-part1 addr-part2)
      (if [= (@ expr-type $addr-part1) (-literal-)]
        (do [set base $addr-part2] [set offset (@ expr-value $addr-part1)] (true))
        (do [set base $addr-part1] [set offset (@ expr-value $addr-part2)] (true)))
    (false)))

(constrain initialize-get-base+offset
  (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-get-base+offset (n offset inits ret-val)
  (bind-if (and [match-get-base+offset name base addr-offset n] [sbyte? $addr-offset])
    (name base addr-offset)
      (let
          (base-val-bndg (@ expr-binding-aug $base))
          (expr-val-bndg (@ expr-binding-aug n))
        (switch str= $name
          ((" getb) (" get1b) (" get2b) (" get4b) (" get8b) (" get)
            (let (sub-expr-offset [- offset (word-size)])
            (bind (bottom-offset in-use) [initialize-expression $base sub-expr-offset inits ret-val]
            (let (in-use [bor in-use (hex FFFFFFFFFFFF0831)])
            (let (in-use [expr-to-register/memory $base sub-expr-offset in-use]) (do
            (setf bndg-size (@ expr-binding-aug n) (word-size))
            (setf bndg-storage (@ expr-binding-aug (@ expr-target n)) (nil-storage))
            (setf bndg-storage (@ expr-binding-aug (@ expr-target [@car (@ expr-arguments n)])) (nil-storage))
            (setf expr-generator n [function->generator generate-get-base+offset])
            (values (use-storage ret-val) bottom-offset in-use)
            (true)))))))
          
          (false)))
    (false)))

(constrain generate-get-base+offset
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-get-base+offset (n c relocs r handler)
  (substitute (.. r handler)
    (bind-if [match-get-base+offset name base offset n]
      (name base offset)
        (if [sbyte? $offset]
          (switch str= $name
            ((" getb) (" get1b) (do
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg->op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #1 base-reg (none)#0 $offset #1 ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" get2b) (do
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg->op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #2 base-reg (none)#0 $offset #1 ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" get4b) (do
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg->op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #4 base-reg (none)#0 $offset #1 ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" get) (" get8b) (do
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([bndg->op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op(word-size)base-reg(none)#0 $offset #1 ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            (false))
          (false))
      (false))))

(function match-set-base+offset (name base offset value n)
  (bind-if (match-property
      (expr-type (%[= (-invoke-)]))
      (expr-target (%[undefined-symbol?]))
      (expr-target (%(match-property (expr-reference
        (%(match-property (bndg-name (%[variable name]))))))))
      (expr-arguments (%(match-list
        (%(match-property
            (expr-type (%[= (-invoke-)]))
            (expr-target (%[undefined-symbol?]))
            (expr-target (%[symbol-name= (" +)]))
            (expr-arguments
              (%(guard-match
                  (%(match-list
                      (%[variable addr-part1])
                      (%[variable addr-part2])))
                  (or
                    [= (@ expr-type $addr-part1) (-literal-)]
                    [= (@ expr-type $addr-part2) (-literal-)]))))))
        (%[variable value])))) n)
    (addr-part1 addr-part2)
      (if [= (@ expr-type $addr-part1) (-literal-)]
        (do [set base $addr-part2] [set offset (@ expr-value $addr-part1)] (true))
        (do [set base $addr-part1] [set offset (@ expr-value $addr-part2)] (true)))
    (false)))

(constrain generate-set-base+offset
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-set-base+offset (n c relocs r handler)
  (substitute (.. r handler)
    (bind-if [match-set-base+offset name base offset value n]
      (name base offset value)
        (if [sbyte? $offset]
          (switch str= $name
            ((" setb) (" set1b) (do
              [generate-expression $value c relocs ..]
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #1 base-reg (none)#0 $offset #1 ..]
                  [bndg->partial-op #1 (@ expr-binding-aug $value) relocs ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" set2b) (do
              [generate-expression $value c relocs ..]
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #2 base-reg (none)#0 $offset #1 ..]
                  [bndg->partial-op #2 (@ expr-binding-aug $value) relocs ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" set4b) (do
              [generate-expression $value c relocs ..]
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #4 base-reg (none)#0 $offset #1 ..]
                  [bndg->partial-op #4 (@ expr-binding-aug $value) relocs ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            
            ((" set) (" set8b) (do
              [generate-expression $value c relocs ..]
              [generate-expression $base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)base-reg(none)#0 $offset #1 ..]
                  [bndg->op (@ expr-binding-aug $value) relocs ..] [make-reg-op(r11)..]) ..) c ..])
              (true)))
            (false))
          (false))
      (false))))

(constrain initialize-arithmetic-intrinsics
  (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-arithmetic-intrinsics (n offset inits ret-val) (or
  [initialize-get-base+offset n offset inits ret-val]
  [initialize-arithmetic-if-bindings n offset inits ret-val]
  [initialize-unary-arithmetic-operators n offset inits ret-val]
  [initialize-binary-arithmetic-operators n offset inits ret-val]))

