(;; The constants to be used in x86-64-generator.l2)

(function rax (l r) [mk## #0 (\(r) (` expr-code r)) r])

(function rcx (l r) [mk## #1 (\(r) (` expr-code r)) r])

(function rdx (l r) [mk## #2 (\(r) (` expr-code r)) r])

(function rbx (l r) [mk## #3 (\(r) (` expr-code r)) r])

(function rsp (l r) [mk## #4 (\(r) (` expr-code r)) r])

(function rbp (l r) [mk## #5 (\(r) (` expr-code r)) r])

(function rsi (l r) [mk## #6 (\(r) (` expr-code r)) r])

(function rdi (l r) [mk## #7 (\(r) (` expr-code r)) r])

(function r8 (l r) [mk## #8 (\(r) (` expr-code r)) r])

(function r9 (l r) [mk## #9 (\(r) (` expr-code r)) r])

(function r10 (l r) [mk## #10 (\(r) (` expr-code r)) r])

(function r11 (l r) [mk## #11 (\(r) (` expr-code r)) r])

(function r12 (l r) [mk## #12 (\(r) (` expr-code r)) r])

(function r13 (l r) [mk## #13 (\(r) (` expr-code r)) r])

(function r14 (l r) [mk## #14 (\(r) (` expr-code r)) r])

(function r15 (l r) [mk## #15 (\(r) (` expr-code r)) r])

(function rip (l r) [mk## #16 (\(r) (` expr-code r)) r])

(function leaq-mdb-to-reg (l r) [mk## #17 (\(r) (` expr-code r)) r])

(function movq-reg-to-mdb (l r) [mk## #18 (\(r) (` expr-code r)) r])

(function jmp-rel (l r) [mk## #19 (\(r) (` expr-code r)) r])

(function movq-mdb-to-reg (l r) [mk## #20 (\(r) (` expr-code r)) r])

(function pushq-reg (l r) [mk## #21 (\(r) (` expr-code r)) r])

(function movq-reg-to-reg (l r) [mk## #22 (\(r) (` expr-code r)) r])

(function subq-imm-to-reg (l r) [mk## #23 (\(r) (` expr-code r)) r])

(function addq-imm-to-reg (l r) [mk## #24 (\(r) (` expr-code r)) r])

(function popq-reg (l r) [mk## #25 (\(r) (` expr-code r)) r])

(function leave (l r) [mk## #26 (\(r) (` expr-code r)) r])

(function ret (l r) [mk## #27 (\(r) (` expr-code r)) r])

(function jmp-to-reg (l r) [mk## #28 (\(r) (` expr-code r)) r])

(function je-rel (l r) [mk## #29 (\(r) (` expr-code r)) r])

(function orq-reg-to-reg (l r) [mk## #30 (\(r) (` expr-code r)) r])

(function movq-imm-to-reg (l r) [mk## #31 (\(r) (` expr-code r)) r])

(function call-reg (l r) [mk## #32 (\(r) (` expr-code r)) r])

(function label (l r) [mk## #33 (\(r) (` expr-code r)) r])

(function lnkr-add-off-to-ref (l r) [mk## #34 (\(r) (` expr-code r)) r])

(function lnkr-sub-rip-to-ref (l r) [mk## #35 (\(r) (` expr-code r)) r])

(;; Offsets for the register contents in the continuation buffer. ------------)

(function word-size (l r) [mk# r #8])

(function cont-size (l r) [mk# r [* #7 (word-size)]])

(function cont-r15 (l r) [mk# r [* #6 (word-size)]])

(function cont-r12 (l r) [mk# r [* #5 (word-size)]])

(function cont-rbx (l r) [mk# r [* #4 (word-size)]])

(function cont-r13 (l r) [mk# r [* #3 (word-size)]])

(function cont-r14 (l r) [mk# r [* #2 (word-size)]])

(function cont-cir (l r) [mk# r [* #1 (word-size)]])

(function cont-rbp (l r) [mk# r [* #0 (word-size)]])

(function vlayout-frames (n r) (with return (substitute (.. (@0 r) (@1 r)) (begin
  (switch = (@ expr-type n)
    ((-function-) (begin
      (storage parameter-offset-ref [* #2 (word-size)])
      (foreach (t (@ expr-parameters n)) (begin
        (setf bndg-offset (@ expr-binding-aug t) $parameter-offset-ref)
        [set+ parameter-offset-ref (word-size)]))
        
      (storage binding-offset-ref #0)
      (foreach (u [reverse (@ expr-binding-augs n) ..]) (begin
        [set- binding-offset-ref [pad-size (@ bndg-size u) (word-size)]]
        (setf bndg-offset u $binding-offset-ref)))))
    
    ((-continuation-) (-with-) (begin
      (if (@ expr-escapes n) (begin
        (setf bndg-size (@ expr-binding-aug(@ expr-reference n)) (cont-size))
        [append (@ expr-binding-aug(@ expr-reference n)) (& expr-binding-augs[get-parent-function n]) ..])
        (begin))
      (foreach (t (@ expr-parameters n)) (begin
        (setf bndg-size (@ expr-binding-aug t) (word-size))
        [append (@ expr-binding-aug t) (& expr-binding-augs[get-parent-function n]) ..]))))
    
    ((-storage-) (begin
      (setf bndg-size (@ expr-binding-aug(@ expr-reference n)) [* [length (@ expr-arguments n)] (word-size)])
      [append (@ expr-binding-aug(@ expr-reference n)) (& expr-binding-augs[get-parent-function n]) ..]))
    
    ((-jump-) (-invoke-) (begin
      (setf bndg-size (@ expr-temp-storage-bndg n) [* (word-size) [length (@ expr-arguments n)]])
      (switch = (@ expr-contains-flag n)
        ((contains-with)
          [append (@ expr-temp-storage-bndg n) (& expr-binding-augs[get-parent-function n]) ..])
        ((contains-jump)
          (setf bndg-storage (@ expr-temp-storage-bndg n) (nil-storage)))
        ((contains-none) (begin
          (setf bndg-storage (@ expr-temp-storage-bndg n) (top-relative-storage))
          (setf bndg-offset (@ expr-temp-storage-bndg n) #0)))
        (begin))))
    
    (begin))
  
  {return n}))))

(function generate-load (bndg offset dest-reg scratch-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal [+ (@ bndg-offset bndg) offset] ..])
          [prepend (make-asmN (movq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage) (begin
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-mdb-to-reg) ([make-literal #0 ..] scratch-reg dest-reg) ..) c ..]))
        
      ((top-relative-storage)
        (let (op1 [make-literal [+ (@ bndg-offset bndg) offset] ..])
          [prepend (make-asmN (movq-mdb-to-reg) (op1 (make-asmN(rsp)()..) dest-reg) ..) c ..]))
          
      (begin))))

(function generate-store (src-reg bndg offset scratch-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op2 [make-literal [+ (@ bndg-offset bndg) offset] ..])
          [prepend (make-asmN (movq-reg-to-mdb) (src-reg op2 (make-asmN(rbp)()..)) ..) c ..]))
          
      ((absolute-storage) (begin
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-reg-to-mdb) (src-reg [make-literal #0 ..] scratch-reg) ..) c ..]))
        
      ((top-relative-storage)
        (let (op2 [make-literal [+ (@ bndg-offset bndg) offset] ..])
          [prepend (make-asmN (movq-reg-to-mdb) (src-reg op2 (make-asmN(rsp)()..)) ..) c ..]))
          
      (begin))))

(constrain generate-if (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-if (n c r handler)
  (substitute (.. r handler) (begin
    [generate-expression (@ expr-condition n) c ..]
    [prepend (make-asmN (orq-reg-to-reg) ((make-asmN(rax)()..) (make-asmN(rax)()..)) ..) c ..]
    (define (alternate-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug alternate-binding ..]) ..))
      [prepend (make-asmN (je-rel) (op1) ..) c ..])
    [generate-expression (@ expr-consequent n) c ..]
    (define (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug end-binding ..]) ..))
      [prepend (make-asmN (jmp-rel) (op1) ..) c ..])
    [prepend (make-asmN (label) ([use-binding-aug alternate-binding ..]) ..) c ..]
    [generate-expression (@ expr-alternate n) c ..]
    [prepend (make-asmN (label) ([use-binding-aug end-binding ..]) ..) c ..])))))

(function generate-load-address (bndg dest-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal (@ bndg-offset bndg) ..])
          [prepend (make-asmN (leaq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage)
        [prepend (make-asmN (movq-imm-to-reg) ([use-binding-aug bndg ..] dest-reg) ..) c ..])
        
      ((top-relative-storage)
        (let (op1 [make-literal (@ bndg-offset bndg) ..])
          [prepend (make-asmN (leaq-mdb-to-reg) (op1 (make-asmN(rsp)()..) dest-reg) ..) c ..]))
          
      (begin))))

(constrain generate-storage (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-storage (n c r handler)
  (substitute (.. r handler) (begin
    (storage offset-ref #0)
    (foreach (t (@ expr-arguments n)) (begin
      [generate-expression t c ..]
      [generate-store (make-asmN(rax)()..) (@ expr-binding-aug(@ expr-reference n)) $offset-ref (make-asmN(r11)()..) c ..]
      [set+ offset-ref (word-size)]))
    [generate-load-address (@ expr-binding-aug(@ expr-reference n)) (make-asmN(rax)()..) c ..])))

(constrain generate-symbol (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-symbol (n c r handler)
  (substitute (.. r handler)
    (let (def (@ bndg-definition(@ expr-binding-aug n)))
      (if (and (or [= (@ expr-type(@ expr-parent def)) (-function-)] [= (@ expr-type(@ expr-parent def)) (-continuation-)])
          (default wth (find (x (@ expr-parameters(@ expr-parent def))) [= x def] {wth (false)}) (true)))
        [generate-load (@ expr-binding-aug n) #0 (make-asmN(rax)()..) (make-asmN(r11)()..) c ..]
        [generate-load-address (@ expr-binding-aug n) (make-asmN(rax)()..) c ..]))))

(function generate-store-continuation (n c r handler)
  (substitute (.. r handler) (begin
    [generate-store (make-asmN(rbx)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-rbx) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r12)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r12) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r13)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r13) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r14)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r14) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r15)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r15) (make-asmN(r11)()..) c ..]
    [generate-load-address (@ expr-cont-instr-bndg n) (make-asmN(r10)()..) c ..]
    [generate-store (make-asmN(r10)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-cir) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(rbp)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-rbp) (make-asmN(r11)()..) c ..])))

(function cond-push-relative-storage (n c r handler) (substitute (.. r handler)
  (if [= (@ bndg-storage (@ expr-temp-storage-bndg n)) (top-relative-storage)]
    [prepend (make-asmN(subq-imm-to-reg) ([make-literal [* [length (@ expr-arguments n)] (word-size)] ..] (make-asmN(rsp)()..)) ..) c ..]
    (begin))))

(function cond-pop-relative-storage (n c r handler) (substitute (.. r handler)
  (if [= (@ bndg-storage (@ expr-temp-storage-bndg n)) (top-relative-storage)]
    [prepend (make-asmN(addq-imm-to-reg) ([make-literal [* [length (@ expr-arguments n)] (word-size)] ..] (make-asmN(rsp)()..)) ..) c ..]
    (begin))))

(function generate-args-to-buffer (n c r handler) (substitute (.. r handler) (begin
  (storage offset #0)
  (foreach (t (@ expr-arguments n)) (begin
    [generate-expression t c ..]
    [generate-store (make-asmN(rax)()..) (@ expr-temp-storage-bndg n) $offset (make-asmN(r10)()..) c ..]
    [set+ offset (word-size)])))))

(function generate-buffer-to-dest (n dest-reg offset c r handler) (substitute (.. r handler) (begin
  (storage src-offset #0)
  (storage dest-offset offset)
  (foreach (t (@ expr-arguments n)) (begin
    [generate-load (@ expr-temp-storage-bndg n) $src-offset (make-asmN(rax)()..) (make-asmN(r10)()..) c ..]
    [prepend (make-asmN(movq-reg-to-mdb) ((make-asmN(rax)()..) [make-literal $dest-offset ..] dest-reg) ..) c ..]
    [set+ src-offset (word-size)]
    [set+ dest-offset (word-size)])))))

(constrain generate-continuation (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-continuation (n c r handler)
  (substitute (.. r handler) (begin
    (if (@ expr-escapes n) (begin
      [generate-load-address (@ expr-binding-aug (@ expr-reference n)) (make-asmN(rax)()..) c ..]
      [generate-store-continuation n c ..])
      (begin))
    
    (define (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug after-binding ..]) ..)) ..) c ..]
    [prepend (make-asmN (label) ([use-binding-aug (@ expr-cont-instr-bndg n) ..]) ..) c ..]
    [generate-expression (@ expr-expression n) c ..]
    [prepend (make-asmN (label) ([use-binding-aug after-binding ..]) ..) c ..]))))

(constrain generate-with (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-with (n c r handler)
  (substitute (.. r handler) (begin
    (if (@ expr-escapes n) [generate-store-continuation n c ..] (begin))
    [generate-expression (@ expr-expression n) c ..]
    (define (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug end-binding ..]) ..))
      [prepend (make-asmN (jmp-rel) (op1) ..) c ..])
    [prepend (make-asmN (label) ([use-binding-aug (@ expr-cont-instr-bndg n) ..]) ..) c ..]
    [generate-load (@ expr-binding-aug[@car(@ expr-parameters n)]) #0 (make-asmN(rax)()..) (make-asmN(r10)()..) c ..]
    [prepend (make-asmN (label) ([use-binding-aug end-binding ..]) ..) c ..]))))

(constrain generate-jump (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-jump (n c r handler)
  (substitute (.. r handler)
    (if [not= (@ expr-short-circuit n) null-expr]
      (begin
        (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
          [generate-expression (@ expr-reference n) c ..]
          (begin))
        (if [length (@ expr-parameters(@ expr-short-circuit n))] (begin
          [cond-push-relative-storage n c ..]
          [generate-args-to-buffer n c ..]
          [generate-load-address (@ expr-binding-aug[@car (@ expr-parameters(@ expr-short-circuit n))]) (make-asmN(r11)()..) c ..]
          [generate-buffer-to-dest n (make-asmN(r11)()..) #0 c ..]
          [cond-pop-relative-storage n c ..])
          (begin))
        [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref)
          ([use-binding-aug (@ expr-cont-instr-bndg(@ expr-short-circuit n)) ..]) ..)) ..) c ..])
      (begin
        [cond-push-relative-storage n c ..]
        [generate-args-to-buffer n c ..]
        [generate-expression (@ expr-reference n) c ..]
        [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rax)()..) (make-asmN(r11)()..))..) c ..]
        [generate-buffer-to-dest n (make-asmN(r11)()..) (cont-size) c ..]
        [cond-pop-relative-storage n c ..]
        
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-rbx)..] (make-asmN(r11)()..) (make-asmN(rbx)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-r12)..] (make-asmN(r11)()..) (make-asmN(r12)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-r13)..] (make-asmN(r11)()..) (make-asmN(r13)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-r14)..] (make-asmN(r11)()..) (make-asmN(r14)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-r15)..] (make-asmN(r11)()..) (make-asmN(r15)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-cir)..] (make-asmN(r11)()..) (make-asmN(r10)()..))..) c ..]
        [prepend (make-asmN(movq-mdb-to-reg)([make-literal(cont-rbp)..] (make-asmN(r11)()..) (make-asmN(rbp)()..))..) c ..]
        [prepend (make-asmN(jmp-to-reg)((make-asmN(r10)()..))..) c ..]))))

(constrain generate-literal (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-literal (n c r handler) (substitute (.. r handler)
  [prepend (make-asmN(movq-imm-to-reg)([make-literal(@ expr-value n)..] (make-asmN(rax)()..))..) c ..]))

(function get-current-offset (func)
  (if [> [length (@ expr-binding-augs func)] #0]
    (@ bndg-offset [@car (@ expr-binding-augs func)])
    #0))

(constrain generate-function (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-function (n c r handler)
  (substitute (.. r handler) (begin
    [generate-load-address (@ expr-binding-aug(@ expr-reference n)) (make-asmN(rax)()..) c ..]
    
    (define (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr ..])
    [prepend (make-asmN(jmp-rel)((make-asmN(lnkr-sub-rip-to-ref)([use-binding-aug after-binding ..])..))..) c ..]
    [prepend (make-asmN(label)((@ expr-reference n))..) c ..]
    
    [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
    
    (;; Insert first 6 parameters onto stack)
    [prepend (make-asmN(pushq-reg)((make-asmN(r9)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(r8)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(rcx)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(rdx)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(rsi)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(rdi)()..))..) c ..]
    
    [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
    
    [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
    [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
    [prepend (make-asmN(subq-imm-to-reg)([make-literal [- #0 [get-current-offset n]] ..] (make-asmN(rsp)()..))..) c ..]
    
    (;; Execute the function body)
    [generate-expression (@ expr-expression n) c ..]
    
    [prepend (make-asmN(leave)()..) c ..]
    
    [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
    [prepend (make-asmN(addq-imm-to-reg)([make-literal [* #6(word-size)]..] (make-asmN(rsp)()..))..) c ..]
    [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
    [prepend (make-asmN(ret)()..) c ..]
    [prepend (make-asmN(label)([use-binding-aug after-binding ..])..) c ..]))))

(constrain generate-invoke (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-invoke (n c r handler)
  (substitute (.. r handler) (begin
    [cond-push-relative-storage n c ..]
    [generate-args-to-buffer n c ..]
    (if [= (@ expr-contains-flag n) (contains-with)]
      (loop move-args (offset [* [length (@ expr-arguments n)] (word-size)])
        (if offset (begin
          (define (offset [- offset (word-size)])
          [generate-load (@ expr-temp-storage-bndg n) offset (make-asmN(r11)()..) (make-asmN(r10)()..) c ..]
          [prepend (make-asmN(pushq-reg) ((make-asmN(r11)()..)) ..) c ..]
          {move-args offset}))
          (begin)))
      (begin))
    
    [generate-expression (@ expr-reference n) c ..]
    [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rax)()..) (make-asmN(r11)()..))..) c ..]
    
    (if [> [length (@ expr-arguments n)] #0]
      [prepend (make-asmN(popq-reg)((make-asmN(rdi)()..))..) c ..]
      (begin))
    (if [> [length (@ expr-arguments n)] #1]
      [prepend (make-asmN(popq-reg)((make-asmN(rsi)()..))..) c ..]
      (begin))
    (if [> [length (@ expr-arguments n)] #2]
      [prepend (make-asmN(popq-reg)((make-asmN(rdx)()..))..) c ..]
      (begin))
    (if [> [length (@ expr-arguments n)] #3]
      [prepend (make-asmN(popq-reg)((make-asmN(rcx)()..))..) c ..]
      (begin))
    (if [> [length (@ expr-arguments n)] #4]
      [prepend (make-asmN(popq-reg)((make-asmN(r8)()..))..) c ..]
      (begin))
    (if [> [length (@ expr-arguments n)] #5]
      [prepend (make-asmN(popq-reg)((make-asmN(r9)()..))..) c ..]
      (begin))
    
    [prepend (make-asmN(movq-imm-to-reg)([make-literal #0 ..] (make-asmN(rax)()..))..) c ..]
    [prepend (make-asmN(call-reg)((make-asmN(r11)()..))..) c ..]
    
    (if [> [length (@ expr-arguments n)] #6]
      (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
        [prepend (make-asmN(addq-imm-to-reg)([make-literal drop ..] (make-asmN(rsp)()..))..) c ..])
      (begin)))))

(constrain generate-begin (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-begin (n c r handler)
  (substitute (.. r handler)
    (foreach (t (@ expr-expressions n)) [generate-expression t c ..])))

(constrain generate-constrain (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-constrain (n c r handler)
  (substitute (.. r handler)
    [generate-expression (@ expr-expression n) c ..]))

(constrain generate-expression (\(r) (with-vars (a) (`(function (expr (ref (list expr)) buffer ,a) ())r)r)))

(function generate-expression (n c r handler)
  (substitute (.. r handler) [(switch = (@ expr-type n)
    ((-begin-) generate-begin)
    ((-continuation-) generate-continuation)
    ((-with-) generate-with)
    ((-jump-) generate-jump)
    ((-symbol-) generate-symbol)
    ((-storage-) generate-storage)
    ((-if-) generate-if)
    ((-literal-) generate-literal)
    ((-function-) generate-function)
    ((-invoke-) generate-invoke)
    ((-constrain-) generate-constrain)
    (begin)) n c ..]))

(constrain generate-program (\(r) (with-vars (a) (`(function (expr (ref (list bndg-aug)) buffer ,a) (list expr))r)r)))

(function generate-program (n bindings r handler) (with return
  (substitute (.. r handler) (begin
    [set bindings (@ expr-binding-augs n)]
    (storage c nil)
    [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
    [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
    [generate-expression (@ expr-expression n) c ..]
    [prepend (make-asmN(leave)()..) c ..]
    [prepend (make-asmN(ret)()..) c ..]
    {return [reverse $c ..]}))))

