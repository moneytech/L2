(ignore The constants to be used in x86-64-generator.l2)

(ignore x86-64 registers.)

  (function al (l r) [=## #0 (\ r (` expr-code r)) r])

  (function cl (l r) [=## #1 (\ r (` expr-code r)) r])

  (function dl (l r) [=## #2 (\ r (` expr-code r)) r])

  (function bl (l r) [=## #3 (\ r (` expr-code r)) r])

  (function ah (l r) [=## #4 (\ r (` expr-code r)) r])

  (function ch (l r) [=## #5 (\ r (` expr-code r)) r])

  (function dh (l r) [=## #6 (\ r (` expr-code r)) r])

  (function bh (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function ax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function cx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function dx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function bx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function sp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function bp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function si (l r) [=## #6 (\ r (` expr-code r)) r])

  (function di (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function eax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function ecx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function edx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function ebx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function esp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function ebp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function esi (l r) [=## #6 (\ r (` expr-code r)) r])

  (function edi (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function rax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function rcx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function rdx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function rbx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function rsp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function rbp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function rsi (l r) [=## #6 (\ r (` expr-code r)) r])

  (function rdi (l r) [=## #7 (\ r (` expr-code r)) r])

  (function r8 (l r) [=## #8 (\ r (` expr-code r)) r])

  (function r9 (l r) [=## #9 (\ r (` expr-code r)) r])

  (function r10 (l r) [=## #10 (\ r (` expr-code r)) r])

  (function r11 (l r) [=## #11 (\ r (` expr-code r)) r])

  (function r12 (l r) [=## #12 (\ r (` expr-code r)) r])

  (function r13 (l r) [=## #13 (\ r (` expr-code r)) r])

  (function r14 (l r) [=## #14 (\ r (` expr-code r)) r])

  (function r15 (l r) [=## #15 (\ r (` expr-code r)) r])

  (function rip (l r) [=## #16 (\ r (` expr-code r)) r])

(ignore x86-64 instruction opcodes.)

  (function leaq-mdb-to-reg (l r) [=## #17 (\ r (` expr-code r)) r])

  (function movq-reg-to-mdb (l r) [=## #18 (\ r (` expr-code r)) r])

  (function jmp-rel (l r) [=## #19 (\ r (` expr-code r)) r])

  (function movq-mdb-to-reg (l r) [=## #20 (\ r (` expr-code r)) r])

  (function pushq-reg (l r) [=## #21 (\ r (` expr-code r)) r])

  (function movq-reg-to-reg (l r) [=## #22 (\ r (` expr-code r)) r])

  (function subq-imm-to-reg (l r) [=## #23 (\ r (` expr-code r)) r])

  (function addq-imm-to-reg (l r) [=## #24 (\ r (` expr-code r)) r])

  (function popq-reg (l r) [=## #25 (\ r (` expr-code r)) r])

  (function leave (l r) [=## #26 (\ r (` expr-code r)) r])

  (function ret (l r) [=## #27 (\ r (` expr-code r)) r])

  (function jmp-to-reg (l r) [=## #28 (\ r (` expr-code r)) r])

  (function je-rel (l r) [=## #29 (\ r (` expr-code r)) r])

  (function orq-reg-to-reg (l r) [=## #30 (\ r (` expr-code r)) r])

  (function movq-imm-to-reg (l r) [=## #31 (\ r (` expr-code r)) r])

  (function call-reg (l r) [=## #32 (\ r (` expr-code r)) r])
  
  (function addq-reg-to-reg (l r) [=## #36 (\ r (` expr-code r)) r])
  
  (function subq-reg-to-reg (l r) [=## #37 (\ r (` expr-code r)) r])
  
  (function mulq-reg (l r) [=## #38 (\ r (` expr-code r)) r])
  
  (function shlq-cl-to-reg (l r) [=## #39 (\ r (` expr-code r)) r])
  
  (function shrq-cl-to-reg (l r) [=## #40 (\ r (` expr-code r)) r])
  
  (function andq-reg-to-reg (l r) [=## #41 (\ r (` expr-code r)) r])
  
  (function notq-reg (l r) [=## #42 (\ r (` expr-code r)) r])
  
  (function movb-mdb-to-reg (l r) [=## #43 (\ r (` expr-code r)) r])
  
  (function xorq-reg-to-reg (l r) [=## #44 (\ r (` expr-code r)) r])
  
  (function movw-mdb-to-reg (l r) [=## #45 (\ r (` expr-code r)) r])
  
  (function movl-mdb-to-reg (l r) [=## #46 (\ r (` expr-code r)) r])

(function label (l r) [=## #33 (\ r (` expr-code r)) r])

(function lnkr-add-off-to-ref (l r) [=## #34 (\ r (` expr-code r)) r])

(function lnkr-sub-rip-to-ref (l r) [=## #35 (\ r (` expr-code r)) r])

(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(constrain layout-frames (\ r (with-vars (a b) (`(function (expr (ref (list bndg-aug)) buffer ,a) ,b)r)r)))

(function layout-frames (n binding-augs r handler)
  (substitute (.. r handler)
    (switch = (@ expr-type n)
      ((-function-) (do
        [layout-frames (@ expr-expression n) (& expr-binding-augs n) ..]
        (let (parameter-offset-ref (storage _ [* #2 (word-size)])) (do
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset (@ expr-binding-aug t) $parameter-offset-ref)
          [set+ parameter-offset-ref (word-size)]))
          
        (let (binding-offset-ref (storage _ #0)) (do
        (foreach (u [reverse (@ expr-binding-augs n) ..]) (do
          [set- binding-offset-ref [pad-size (@ bndg-size u) (word-size)]]
          (setf bndg-offset u $binding-offset-ref)))))))))
      
      ((-continuation-) (-with-) (do
        [layout-frames (@ expr-expression n) binding-augs ..]
        (if (@ expr-escapes n) (do
          (setf bndg-size (@ expr-binding-aug(@ expr-reference n)) (cont-size))
          [append (@ expr-binding-aug(@ expr-reference n)) binding-augs ..])
          (ignore))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-size (@ expr-binding-aug t) (word-size))
          [append (@ expr-binding-aug t) binding-augs ..]))))
      
      ((-storage-) (do
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        (setf bndg-size (@ expr-binding-aug(@ expr-reference n)) [* [length (@ expr-arguments n)] (word-size)])
        [append (@ expr-binding-aug(@ expr-reference n)) binding-augs ..]))
      
      ((-jump-) (-invoke-) (do
        [layout-frames (@ expr-reference n) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        (setf bndg-size (@ expr-temp-storage-bndg n) [* (word-size) [length (@ expr-arguments n)]])
        (switch = (@ expr-contains-flag n)
          ((contains-with)
            [append (@ expr-temp-storage-bndg n) binding-augs ..])
          ((contains-jump)
            (setf bndg-storage (@ expr-temp-storage-bndg n) (nil-storage)))
          ((contains-none) (do
            (setf bndg-storage (@ expr-temp-storage-bndg n) (top-relative-storage))
            (setf bndg-offset (@ expr-temp-storage-bndg n) #0)))
          (ignore))))
      
      ((-if-) (do
        [layout-frames (@ expr-condition n) binding-augs ..]
        [layout-frames (@ expr-consequent n) binding-augs ..]
        [layout-frames (@ expr-alternate n) binding-augs ..]))
      
      ((-constrain-) [layout-frames (@ expr-expression n) binding-augs ..])
      
      (ignore))))

(constrain generator->function
  (\ r (with-vars (a) (`(function (generator)
    (function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ()))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a) (`(function
    ((function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())) generator)r)r)))

(function function->generator (x) [cast x])

(function generate-load (bndg offset dest-reg scratch-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage) (do
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset null-fragment null-expr ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-mdb-to-reg) ([make-literal #0 null-fragment null-expr ..] scratch-reg dest-reg) ..) c ..]))
        
      ((top-relative-storage)
        (let (op1 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-mdb-to-reg) (op1 (make-asmN(rsp)()..) dest-reg) ..) c ..]))
          
      (ignore))))

(function generate-store (src-reg bndg offset scratch-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op2 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-reg-to-mdb) (src-reg op2 (make-asmN(rbp)()..)) ..) c ..]))
          
      ((absolute-storage) (do
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset null-fragment null-expr ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-reg-to-mdb) (src-reg [make-literal #0 null-fragment null-expr ..] scratch-reg) ..) c ..]))
        
      ((top-relative-storage)
        (let (op2 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-reg-to-mdb) (src-reg op2 (make-asmN(rsp)()..)) ..) c ..]))
          
      (ignore))))

(constrain generate-if
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-if (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-if-)]
      {success (do
        [generate-expression (@ expr-condition n) gens c ..]
        [prepend (make-asmN (orq-reg-to-reg) ((make-asmN(rax)()..) (make-asmN(rax)()..)) ..) c ..]
        (let (alternate-binding
          [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug alternate-binding ..]) ..))
          [prepend (make-asmN (je-rel) (op1) ..) c ..])
        [generate-expression (@ expr-consequent n) gens c ..]
        (let (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug end-binding ..]) ..))
          [prepend (make-asmN (jmp-rel) (op1) ..) c ..])
        [prepend (make-asmN (label) ([use-binding-aug alternate-binding ..]) ..) c ..]
        [generate-expression (@ expr-alternate n) gens c ..]
        [prepend (make-asmN (label) ([use-binding-aug end-binding ..]) ..) c ..])))))}
      (ignore))))

(function generate-load-address (bndg dest-reg c r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal (@ bndg-offset bndg) null-fragment null-expr ..])
          [prepend (make-asmN (leaq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage)
        [prepend (make-asmN (movq-imm-to-reg) ([use-binding-aug bndg ..] dest-reg) ..) c ..])
        
      ((top-relative-storage)
        (let (op1 [make-literal (@ bndg-offset bndg) null-fragment null-expr ..])
          [prepend (make-asmN (leaq-mdb-to-reg) (op1 (make-asmN(rsp)()..) dest-reg) ..) c ..]))
          
      (ignore))))

(constrain generate-storage
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-storage (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-storage-)]
      {success (let (offset-ref (storage _ #0)) (do
        (foreach (t (@ expr-arguments n)) (do
          [generate-expression t gens c ..]
          [generate-store (make-asmN(rax)()..) (@ expr-binding-aug(@ expr-reference n)) $offset-ref (make-asmN(r11)()..) c ..]
          [set+ offset-ref (word-size)]))
        [generate-load-address (@ expr-binding-aug(@ expr-reference n)) (make-asmN(rax)()..) c ..]))}
      (ignore))))

(constrain generate-symbol
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-symbol (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-symbol-)]
      {success (let (target-expr (@ bndg-expression(@ expr-binding-aug n)))
        (if (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
            (not [nil? (find (x (@ expr-parameters target-expr)) [= x (@ bndg-symbol (@ expr-binding-aug n))])]))
          [generate-load (@ expr-binding-aug n) #0 (make-asmN(rax)()..) (make-asmN(r11)()..) c ..]
          [generate-load-address (@ expr-binding-aug n) (make-asmN(rax)()..) c ..]))}
      (ignore))))

(function generate-store-continuation (n c r handler)
  (substitute (.. r handler) (do
    [generate-store (make-asmN(rbx)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-rbx) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r12)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r12) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r13)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r13) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r14)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r14) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(r15)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-r15) (make-asmN(r11)()..) c ..]
    [generate-load-address (@ expr-cont-instr-bndg n) (make-asmN(r10)()..) c ..]
    [generate-store (make-asmN(r10)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-cir) (make-asmN(r11)()..) c ..]
    [generate-store (make-asmN(rbp)()..) (@ expr-binding-aug(@ expr-reference n)) (cont-rbp) (make-asmN(r11)()..) c ..])))

(function cond-push-relative-storage (n c r handler) (substitute (.. r handler)
  (if [= (@ bndg-storage (@ expr-temp-storage-bndg n)) (top-relative-storage)]
    [prepend (make-asmN(subq-imm-to-reg)
      ([make-literal [* [length (@ expr-arguments n)] (word-size)] null-fragment null-expr ..] (make-asmN(rsp)()..)) ..) c ..]
    (ignore))))

(function cond-pop-relative-storage (n c r handler) (substitute (.. r handler)
  (if [= (@ bndg-storage (@ expr-temp-storage-bndg n)) (top-relative-storage)]
    [prepend (make-asmN(addq-imm-to-reg)
      ([make-literal [* [length (@ expr-arguments n)] (word-size)] null-fragment null-expr ..] (make-asmN(rsp)()..)) ..) c ..]
    (ignore))))

(function generate-args-to-buffer (n gens c r handler) (substitute (.. r handler)
  (let (offset (storage _ #0))
  (foreach (t (@ expr-arguments n)) (do
    [generate-expression t gens c ..]
    [generate-store (make-asmN(rax)()..) (@ expr-temp-storage-bndg n) $offset (make-asmN(r10)()..) c ..]
    [set+ offset (word-size)])))))

(function generate-buffer-to-dest (n dest-reg offset c r handler) (substitute (.. r handler)
  (let (src-offset (storage _ #0))
  (let (dest-offset (storage _ offset))
  (foreach (t (@ expr-arguments n)) (do
    [generate-load (@ expr-temp-storage-bndg n) $src-offset (make-asmN(rax)()..) (make-asmN(r10)()..) c ..]
    [prepend (make-asmN(movq-reg-to-mdb) ((make-asmN(rax)()..) [make-literal $dest-offset null-fragment null-expr ..] dest-reg) ..) c ..]
    [set+ src-offset (word-size)]
    [set+ dest-offset (word-size)]))))))

(constrain generate-continuation
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-continuation (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-continuation-)] {success (do
      (if (@ expr-escapes n) (do
        [generate-load-address (@ expr-binding-aug (@ expr-reference n)) (make-asmN(rax)()..) c ..]
        [generate-store-continuation n c ..])
        (ignore))
      
      (let (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug after-binding ..]) ..)) ..) c ..]
      [prepend (make-asmN (label) ([use-binding-aug (@ expr-cont-instr-bndg n) ..]) ..) c ..]
      [generate-expression (@ expr-expression n) gens c ..]
      [prepend (make-asmN (label) ([use-binding-aug after-binding ..]) ..) c ..])))}
      (ignore))))

(constrain generate-with
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-with (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-with-)]
      {success (do
        (if (@ expr-escapes n) [generate-store-continuation n c ..] (ignore))
        [generate-expression (@ expr-expression n) gens c ..]
        (let (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (let (op1 (make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug end-binding ..]) ..))
          [prepend (make-asmN (jmp-rel) (op1) ..) c ..])
        [prepend (make-asmN (label) ([use-binding-aug (@ expr-cont-instr-bndg n) ..]) ..) c ..]
        [generate-load (@ expr-binding-aug[@car(@ expr-parameters n)]) #0 (make-asmN(rax)()..) (make-asmN(r10)()..) c ..]
        [prepend (make-asmN (label) ([use-binding-aug end-binding ..]) ..) c ..])))}
      (ignore))))

(constrain generate-jump
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-jump (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-jump-)] {success (do
      (if [not= (@ expr-short-circuit n) null-expr]
        (do
          (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
            [generate-expression (@ expr-reference n) gens c ..]
            (ignore))
          (if [length (@ expr-parameters(@ expr-short-circuit n))] (do
            [cond-push-relative-storage n c ..]
            [generate-args-to-buffer n gens c ..]
            [generate-load-address (@ expr-binding-aug[@car (@ expr-parameters(@ expr-short-circuit n))]) (make-asmN(r11)()..) c ..]
            [generate-buffer-to-dest n (make-asmN(r11)()..) #0 c ..]
            [cond-pop-relative-storage n c ..])
            (ignore))
          [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref)
            ([use-binding-aug (@ expr-cont-instr-bndg(@ expr-short-circuit n)) ..]) ..)) ..) c ..])
        (do
          [cond-push-relative-storage n c ..]
          [generate-args-to-buffer n gens c ..]
          [generate-expression (@ expr-reference n) gens c ..]
          [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rax)()..) (make-asmN(r11)()..))..) c ..]
          [generate-buffer-to-dest n (make-asmN(r11)()..) (cont-size) c ..]
          [cond-pop-relative-storage n c ..]
          
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-rbx) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(rbx)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r12) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r12)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r13) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r13)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r14) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r14)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r15) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r15)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-cir) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r10)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-rbp) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(rbp)()..))..) c ..]
          [prepend (make-asmN(jmp-to-reg)((make-asmN(r10)()..))..) c ..])))}
      (ignore))))

(constrain generate-literal
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-literal (n gens c success r handler) (substitute (.. r handler)
  (if [= (@ expr-type n) (-literal-)]
    {success
      [prepend (make-asmN(movq-imm-to-reg)([make-literal(@ expr-value n) null-fragment null-expr ..] (make-asmN(rax)()..))..) c ..]}
    (ignore))))

(function get-current-offset (func)
  (if [> [length (@ expr-binding-augs func)] #0]
    (@ bndg-offset [@car (@ expr-binding-augs func)])
    #0))

(constrain generate-function
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-function (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-function-)] {success (do
      [generate-load-address (@ expr-binding-aug(@ expr-reference n)) (make-asmN(rax)()..) c ..]
      
      (let (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      [prepend (make-asmN(jmp-rel)((make-asmN(lnkr-sub-rip-to-ref)([use-binding-aug after-binding ..])..))..) c ..]
      [prepend (make-asmN(label)((@ expr-reference n))..) c ..]
      
      [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
      
      (ignore Insert first 6 parameters onto stack)
      [prepend (make-asmN(pushq-reg)((make-asmN(r9)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(r8)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rcx)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rdx)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rsi)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rdi)()..))..) c ..]
      
      [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
      
      [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
      [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
      [prepend (make-asmN(subq-imm-to-reg)([make-literal [- #0 [get-current-offset n]] null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..]
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) gens c ..]
      
      [prepend (make-asmN(leave)()..) c ..]
      
      [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
      [prepend (make-asmN(addq-imm-to-reg)([make-literal [* #6(word-size)] null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
      [prepend (make-asmN(ret)()..) c ..]
      [prepend (make-asmN(label)([use-binding-aug after-binding ..])..) c ..])))}
      (ignore))))

(constrain generate-invoke
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-invoke (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-invoke-)] {success (do
      [cond-push-relative-storage n c ..]
      [generate-args-to-buffer n gens c ..]
      (if [= (@ expr-contains-flag n) (contains-with)]
        (loop move-args (offset [* [length (@ expr-arguments n)] (word-size)])
          (if offset
            (let (offset [- offset (word-size)]) (do
            [generate-load (@ expr-temp-storage-bndg n) offset (make-asmN(r11)()..) (make-asmN(r10)()..) c ..]
            [prepend (make-asmN(pushq-reg) ((make-asmN(r11)()..)) ..) c ..]
            {move-args offset}))
            (ignore)))
        (ignore))
      
      [generate-expression (@ expr-reference n) gens c ..]
      [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rax)()..) (make-asmN(r11)()..))..) c ..]
      
      (if [> [length (@ expr-arguments n)] #0]
        [prepend (make-asmN(popq-reg)((make-asmN(rdi)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #1]
        [prepend (make-asmN(popq-reg)((make-asmN(rsi)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #2]
        [prepend (make-asmN(popq-reg)((make-asmN(rdx)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #3]
        [prepend (make-asmN(popq-reg)((make-asmN(rcx)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #4]
        [prepend (make-asmN(popq-reg)((make-asmN(r8)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #5]
        [prepend (make-asmN(popq-reg)((make-asmN(r9)()..))..) c ..] (ignore))
      
      [prepend (make-asmN(movq-imm-to-reg)([make-literal #0 null-fragment null-expr ..] (make-asmN(rax)()..))..) c ..]
      [prepend (make-asmN(call-reg)((make-asmN(r11)()..))..) c ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-asmN(addq-imm-to-reg)([make-literal drop null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..])
        (ignore)))}
      (ignore))))

(constrain generate-constrain
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (continuation (())) buffer ,a) ())r)r)))

(function generate-constrain (n gens c success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-constrain-)]
      {success [generate-expression (@ expr-expression n) gens c ..]}
    (ignore))))

(constrain generate-expression (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) buffer ,a) ())r)r)))

(function generate-expression (n gens c r handler)
  (substitute (.. r handler) (with success (do
    (foreach (gen gens) [[generator->function gen] n gens c success ..])
    [generate-continuation n gens c success ..]
    [generate-with n gens c success ..]
    [generate-jump n gens c success ..]
    [generate-symbol n gens c success ..]
    [generate-storage n gens c success ..]
    [generate-if n gens c success ..]
    [generate-literal n gens c success ..]
    [generate-function n gens c success ..]
    [generate-invoke n gens c success ..]
    [generate-constrain n gens c success ..]))))

(constrain generate-program (\ r (with-vars (a) (`(function ((list expr) (list generator) buffer ,a) (list expr))r)r)))

(function generate-program (exprs gens r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (do
    [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
    [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
    (foreach (expr exprs) [generate-expression expr gens c ..])
    [prepend (make-asmN(leave)()..) c ..]
    [prepend (make-asmN(ret)()..) c ..]
    [reverse $c ..]))))

