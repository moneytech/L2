(ignore The constants to be used in x86-64-generator.l2)

(ignore x86-64 registers.)

  (function al (l r) [=## #0 (\ r (` expr-code r)) r])

  (function cl (l r) [=## #1 (\ r (` expr-code r)) r])

  (function dl (l r) [=## #2 (\ r (` expr-code r)) r])

  (function bl (l r) [=## #3 (\ r (` expr-code r)) r])

  (function ah (l r) [=## #4 (\ r (` expr-code r)) r])

  (function ch (l r) [=## #5 (\ r (` expr-code r)) r])

  (function dh (l r) [=## #6 (\ r (` expr-code r)) r])

  (function bh (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function ax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function cx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function dx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function bx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function sp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function bp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function si (l r) [=## #6 (\ r (` expr-code r)) r])

  (function di (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function eax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function ecx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function edx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function ebx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function esp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function ebp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function esi (l r) [=## #6 (\ r (` expr-code r)) r])

  (function edi (l r) [=## #7 (\ r (` expr-code r)) r])
  
  (function rax (l r) [=## #0 (\ r (` expr-code r)) r])

  (function rcx (l r) [=## #1 (\ r (` expr-code r)) r])

  (function rdx (l r) [=## #2 (\ r (` expr-code r)) r])

  (function rbx (l r) [=## #3 (\ r (` expr-code r)) r])

  (function rsp (l r) [=## #4 (\ r (` expr-code r)) r])

  (function rbp (l r) [=## #5 (\ r (` expr-code r)) r])

  (function rsi (l r) [=## #6 (\ r (` expr-code r)) r])

  (function rdi (l r) [=## #7 (\ r (` expr-code r)) r])

  (function r8 (l r) [=## #8 (\ r (` expr-code r)) r])

  (function r9 (l r) [=## #9 (\ r (` expr-code r)) r])

  (function r10 (l r) [=## #10 (\ r (` expr-code r)) r])

  (function r11 (l r) [=## #11 (\ r (` expr-code r)) r])

  (function r12 (l r) [=## #12 (\ r (` expr-code r)) r])

  (function r13 (l r) [=## #13 (\ r (` expr-code r)) r])

  (function r14 (l r) [=## #14 (\ r (` expr-code r)) r])

  (function r15 (l r) [=## #15 (\ r (` expr-code r)) r])

  (function rip (l r) [=## #16 (\ r (` expr-code r)) r])

(ignore x86-64 instruction opcodes.)

  (function leaq-mdb-to-reg (l r) [=## #17 (\ r (` expr-code r)) r])

  (function movq-reg-to-mdb (l r) [=## #18 (\ r (` expr-code r)) r])

  (function jmp-rel (l r) [=## #19 (\ r (` expr-code r)) r])

  (function movq-mdb-to-reg (l r) [=## #20 (\ r (` expr-code r)) r])

  (function pushq-reg (l r) [=## #21 (\ r (` expr-code r)) r])

  (function movq-reg-to-reg (l r) [=## #22 (\ r (` expr-code r)) r])

  (function subq-imm-to-reg (l r) [=## #23 (\ r (` expr-code r)) r])

  (function addq-imm-to-reg (l r) [=## #24 (\ r (` expr-code r)) r])

  (function popq-reg (l r) [=## #25 (\ r (` expr-code r)) r])

  (function leave (l r) [=## #26 (\ r (` expr-code r)) r])

  (function ret (l r) [=## #27 (\ r (` expr-code r)) r])

  (function jmp-to-reg (l r) [=## #28 (\ r (` expr-code r)) r])

  (function je-rel (l r) [=## #29 (\ r (` expr-code r)) r])

  (function orq-reg-to-reg (l r) [=## #30 (\ r (` expr-code r)) r])

  (function movq-imm-to-reg (l r) [=## #31 (\ r (` expr-code r)) r])

  (function call-reg (l r) [=## #32 (\ r (` expr-code r)) r])
  
  (function addq-reg-to-reg (l r) [=## #36 (\ r (` expr-code r)) r])
  
  (function subq-reg-to-reg (l r) [=## #37 (\ r (` expr-code r)) r])
  
  (function mulq-reg (l r) [=## #38 (\ r (` expr-code r)) r])
  
  (function shlq-cl-to-reg (l r) [=## #39 (\ r (` expr-code r)) r])
  
  (function shrq-cl-to-reg (l r) [=## #40 (\ r (` expr-code r)) r])
  
  (function andq-reg-to-reg (l r) [=## #41 (\ r (` expr-code r)) r])
  
  (function notq-reg (l r) [=## #42 (\ r (` expr-code r)) r])
  
  (function movb-mdb-to-reg (l r) [=## #43 (\ r (` expr-code r)) r])
  
  (function xorq-reg-to-reg (l r) [=## #44 (\ r (` expr-code r)) r])
  
  (function movw-mdb-to-reg (l r) [=## #45 (\ r (` expr-code r)) r])
  
  (function movl-mdb-to-reg (l r) [=## #46 (\ r (` expr-code r)) r])
  
  (function divq-reg (l r) [=## #47 (\ r (` expr-code r)) r])
  
  (function setz-reg (l r) [=## #48 (\ r (` expr-code r)) r])
  
  (function setc-reg (l r) [=## #49 (\ r (` expr-code r)) r])
  
  (function movb-reg-to-mdb (l r) [=## #50 (\ r (` expr-code r)) r])
  
  (function movw-reg-to-mdb (l r) [=## #51 (\ r (` expr-code r)) r])
  
  (function movl-reg-to-mdb (l r) [=## #52 (\ r (` expr-code r)) r])

(function label (l r) [=## #33 (\ r (` expr-code r)) r])

(function lnkr-add-off-to-ref (l r) [=## #34 (\ r (` expr-code r)) r])

(function lnkr-sub-rip-to-ref (l r) [=## #35 (\ r (` expr-code r)) r])

(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(constrain layout-frames (\ r (with-vars (a) (`(function (expr (ref (list bndg-aug)) buffer ,a) bndg-aug)r)r)))

(function layout-frames (n binding-augs r handler)
  (substitute (.. r handler) (do
    (switch = (@ expr-type n)
      ((-function-) (do
        [append [layout-frames (@ expr-expression n) (& expr-binding-augs n) ..] (& expr-binding-augs n) ..]
        (let (parameter-offset-ref (storage _ [* #2 (word-size)])) (do
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset (@ expr-symbol-binding-aug t) $parameter-offset-ref)
          [set+ parameter-offset-ref (word-size)]))))
        (let (binding-offset-ref (storage _ #0)) (do
        (foreach (u [reverse (@ expr-binding-augs n) ..]) (do
          [set- binding-offset-ref [pad-size (@ bndg-size u) (word-size)]]
          (setf bndg-offset u $binding-offset-ref)))))))
      
      ((-continuation-) (-with-) (do
        [append [layout-frames (@ expr-expression n) binding-augs ..] binding-augs ..]
        (if (@ expr-escapes n) (do
          (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-size))
          [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..])
          (ignore))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
          [append (@ expr-symbol-binding-aug t) binding-augs ..]))))
      
      ((-storage-) (do
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) #0)
        [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append (@ expr-binding-aug u) binding-augs ..])))
      
      ((-jump-) (-invoke-) (do
        [append [layout-frames (@ expr-reference n) binding-augs ..] binding-augs ..]
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        [append (@ expr-binding-aug (@ expr-reference n)) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append (@ expr-binding-aug u) binding-augs ..])))
      
      ((-if-) (do
        [append [layout-frames (@ expr-condition n) binding-augs ..] binding-augs ..]
        [append [layout-frames (@ expr-consequent n) binding-augs ..] binding-augs ..]
        [append [layout-frames (@ expr-alternate n) binding-augs ..] binding-augs ..]))
      
      ((-constrain-)
        [append [layout-frames (@ expr-expression n) binding-augs ..] binding-augs ..])
      
      (ignore))
      
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (@ expr-binding-aug n))))

(constrain generator->function
  (\ r (with-vars (a) (`(function (generator)
    (function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ()))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a) (`(function
    ((function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())) generator)r)r)))

(function function->generator (x) [cast x])

(function generate-load (bndg offset dest-reg scratch-reg c relocs r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage) (do
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset null-fragment null-expr ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-mdb-to-reg) ([make-literal #0 null-fragment null-expr ..] scratch-reg dest-reg) ..) c ..]))
          
      (ignore))))

(function generate-store (src-reg bndg offset scratch-reg c relocs r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op2 [make-literal [+ (@ bndg-offset bndg) offset] null-fragment null-expr ..])
          [prepend (make-asmN (movq-reg-to-mdb) (src-reg op2 (make-asmN(rbp)()..)) ..) c ..]))
          
      ((absolute-storage) (do
        (let (op1 (make-asmN (lnkr-add-off-to-ref) ([use-binding-aug bndg ..] [make-literal offset null-fragment null-expr ..]) ..))
          [prepend (make-asmN (movq-imm-to-reg) (op1 scratch-reg) ..) c ..])
        [prepend (make-asmN (movq-reg-to-mdb) (src-reg [make-literal #0 null-fragment null-expr ..] scratch-reg) ..) c ..]))
          
      (ignore))))

(function generate-move (bndg1 offset1 bndg2 offset2 scratch-reg1 scratch-reg2 c relocs r handler)
  (substitute (.. r handler) (do
    [generate-load bndg1 offset1 scratch-reg1 scratch-reg2 c relocs ..]
    [generate-store scratch-reg1 bndg2 offset2 scratch-reg2 c relocs ..])))

(constrain make-relative-relocation-immediate
  (\ r (with-vars (a b) (`(function (,a bndg-aug (ref (list reloc)) buffer ,b) expr)r)r)))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-literal #0 null-fragment null-expr ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-pc8))
          (#2 (r-x86-64-pc16))
          (#4 (r-x86-64-pc32))
          (#8 (r-x86-64-pc64))
          (ignore)) op bndg [- #0 size] ..] relocs ..]
      op))))

(constrain make-label (\ r (with-vars (a) (`(function (bndg-aug buffer ,a) expr)r)r)))

(function make-label (bndg r handler)
  (substitute (.. r handler)
    (let (lbl (make-asmN (label) ([use-binding-aug bndg ..]) ..)) (do
      (setf expr-instruction-binding lbl bndg)
      lbl))))

(constrain generate-if
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-if (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-if-)]
      {success (do
        [generate-expression (@ expr-condition n) gens c relocs ..]
        [generate-load (@ expr-binding-aug (@ expr-condition n)) #0 (make-asmN(rax)()..) (make-asmN(r11)()..) c relocs ..]
        [prepend (make-asmN (orq-reg-to-reg) ((make-asmN(rax)()..) (make-asmN(rax)()..)) ..) c ..]
        (let (alternate-binding
          [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [prepend (make-asmN (je-rel) ([make-relative-relocation-immediate #4 alternate-binding relocs ..]) ..) c ..]
        [generate-expression (@ expr-consequent n) gens c relocs ..]
        [generate-move (@ expr-binding-aug (@ expr-consequent n)) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..]
        (let (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [prepend (make-asmN (jmp-rel) ([make-relative-relocation-immediate #4 end-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-binding ..] c ..]
        [generate-expression (@ expr-alternate n) gens c relocs ..]
        [generate-move (@ expr-binding-aug (@ expr-alternate n)) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..]
        [prepend [make-label end-binding ..] c ..])))))}
      (ignore))))

(function generate-load-address (bndg dest-reg c relocs r handler)
  (substitute (.. r handler)
    (switch = (@ bndg-storage bndg)
      ((frame-relative-storage)
        (let (op1 [make-literal (@ bndg-offset bndg) null-fragment null-expr ..])
          [prepend (make-asmN (leaq-mdb-to-reg) (op1 (make-asmN(rbp)()..) dest-reg) ..) c ..]))
          
      ((absolute-storage)
        [prepend (make-asmN (movq-imm-to-reg) ([use-binding-aug bndg ..] dest-reg) ..) c ..])
          
      (ignore))))

(function generate-load-address-to-binding (bndg1 bndg2 scratch-reg1 scratch-reg2 c relocs r handler)
  (substitute (.. r handler) (do
    [generate-load-address bndg1 scratch-reg1 c relocs ..]
    [generate-store scratch-reg1 bndg2 #0 scratch-reg2 c relocs ..])))

(constrain generate-storage
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-storage (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-storage-)]
      {success (do
        (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
        [generate-load-address-to-binding (@ expr-symbol-binding-aug(@ expr-reference n)) (@ expr-binding-aug n) (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..])}
      (ignore))))

(constrain generate-symbol
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-symbol (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-symbol-)]
      {success (let (target-expr (@ bndg-expression(@ expr-symbol-binding-aug n)))
        (if (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
            (not [nil? (find (x (@ expr-parameters target-expr)) [= x (@ bndg-symbol (@ expr-symbol-binding-aug n))])]))
          [generate-move (@ expr-symbol-binding-aug n) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..) (make-asmN(r11)()..) c relocs ..]
          [generate-load-address-to-binding (@ expr-symbol-binding-aug n) (@ expr-binding-aug n) (make-asmN(r10)()..)
            (make-asmN(r11)()..) c relocs ..]))}
      (ignore))))

(function generate-store-continuation (n c relocs r handler)
  (substitute (.. r handler) (do
    [generate-store (make-asmN(rbx)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-rbx) (make-asmN(r11)()..) c relocs ..]
    [generate-store (make-asmN(r12)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-r12) (make-asmN(r11)()..) c relocs ..]
    [generate-store (make-asmN(r13)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-r13) (make-asmN(r11)()..) c relocs ..]
    [generate-store (make-asmN(r14)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-r14) (make-asmN(r11)()..) c relocs ..]
    [generate-store (make-asmN(r15)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-r15) (make-asmN(r11)()..) c relocs ..]
    [generate-load-address (@ expr-cont-instr-bndg n) (make-asmN(r10)()..) c relocs ..]
    [generate-store (make-asmN(r10)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-cir) (make-asmN(r11)()..) c relocs ..]
    [generate-store (make-asmN(rbp)()..) (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-rbp) (make-asmN(r11)()..) c relocs ..])))

(function generate-args-to-buffer (n gens c relocs r handler) (substitute (.. r handler)
  (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler) (substitute (.. r handler)
  (let (dest-offset (storage _ offset))
  (foreach (t (@ expr-arguments n)) (do
    [generate-load (@ expr-binding-aug t) #0 (make-asmN(rax)()..) (make-asmN(r10)()..) c relocs ..]
    [prepend (make-asmN(movq-reg-to-mdb) ((make-asmN(rax)()..) [make-literal $dest-offset null-fragment null-expr ..] dest-reg) ..) c ..]
    [set+ dest-offset (word-size)])))))

(constrain generate-continuation
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-continuation (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-continuation-)] {success (do
      (if (@ expr-escapes n) (do
        [generate-load-address-to-binding (@ expr-symbol-binding-aug (@ expr-reference n)) (@ expr-binding-aug n) (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..]
        [generate-store-continuation n c relocs ..])
        (ignore))
      
      (let (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref) ([use-binding-aug after-binding ..]) ..)) ..) c ..]
      [prepend (make-asmN (label) ([use-binding-aug (@ expr-cont-instr-bndg n) ..]) ..) c ..]
      [generate-expression (@ expr-expression n) gens c relocs ..]
      [prepend (make-asmN (label) ([use-binding-aug after-binding ..]) ..) c ..])))}
      (ignore))))

(constrain generate-with
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-with (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-with-)]
      {success (do
        (if (@ expr-escapes n) [generate-store-continuation n c relocs ..] (ignore))
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [generate-move (@ expr-binding-aug (@ expr-expression n)) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..) (make-asmN(r11)()..)
          c relocs ..]
        (let (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [prepend (make-asmN (jmp-rel) ([make-relative-relocation-immediate #4 end-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [generate-move (@ expr-symbol-binding-aug[@car(@ expr-parameters n)]) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..]
        [prepend [make-label end-binding ..] c ..])))}
      (ignore))))

(constrain generate-jump
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-jump (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-jump-)] {success (do
      (if [not= (@ expr-short-circuit n) null-expr]
        (do
          (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
            [generate-expression (@ expr-reference n) gens c relocs ..]
            (ignore))
          (if [length (@ expr-parameters(@ expr-short-circuit n))] (do
            [generate-args-to-buffer n gens c relocs ..]
            [generate-load-address (@ expr-symbol-binding-aug[@car (@ expr-parameters(@ expr-short-circuit n))]) (make-asmN(r11)()..) c relocs ..]
            [generate-buffer-to-dest n (make-asmN(r11)()..) #0 c relocs ..])
            (ignore))
          [prepend (make-asmN (jmp-rel) ((make-asmN (lnkr-sub-rip-to-ref)
            ([use-binding-aug (@ expr-cont-instr-bndg(@ expr-short-circuit n)) ..]) ..)) ..) c ..])
        (do
          [generate-args-to-buffer n gens c relocs ..]
          [generate-expression (@ expr-reference n) gens c relocs ..]
          [generate-load (@ expr-binding-aug (@ expr-reference n)) #0 (make-asmN(r11)()..) (make-asmN(r10)()..) c relocs ..]
          [generate-buffer-to-dest n (make-asmN(r11)()..) (cont-size) c relocs ..]
          
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-rbx) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(rbx)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r12) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r12)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r13) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r13)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r14) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r14)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-r15) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r15)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-cir) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(r10)()..))..) c ..]
          [prepend (make-asmN(movq-mdb-to-reg)
            ([make-literal(cont-rbp) null-fragment null-expr ..] (make-asmN(r11)()..) (make-asmN(rbp)()..))..) c ..]
          [prepend (make-asmN(jmp-to-reg)((make-asmN(r10)()..))..) c ..])))}
      (ignore))))

(constrain generate-literal
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-literal (n gens c relocs success r handler) (substitute (.. r handler)
  (if [= (@ expr-type n) (-literal-)]
    {success (do
      [prepend (make-asmN(movq-imm-to-reg)([make-literal(@ expr-value n) null-fragment null-expr ..] (make-asmN(rax)()..))..) c ..]
      [generate-store (make-asmN(rax)()..) (@ expr-binding-aug n) #0 (make-asmN(r10)()..) c relocs ..])}
    (ignore))))

(function get-current-offset (func)
  (if [> [length (@ expr-binding-augs func)] #0]
    (@ bndg-offset [@car (@ expr-binding-augs func)])
    #0))

(constrain generate-function
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-function (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-function-)] {success (do
      [generate-load-address-to-binding (@ expr-symbol-binding-aug(@ expr-reference n)) (@ expr-binding-aug n) (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..]
      
      (let (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      [prepend (make-asmN(jmp-rel)((make-asmN(lnkr-sub-rip-to-ref)([use-binding-aug after-binding ..])..))..) c ..]
      [prepend (make-asmN(label)((@ expr-reference n))..) c ..]
      
      [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
      
      (ignore Insert first 6 parameters onto stack)
      [prepend (make-asmN(pushq-reg)((make-asmN(r9)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(r8)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rcx)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rdx)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rsi)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(rdi)()..))..) c ..]
      
      [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
      
      [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
      [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
      [prepend (make-asmN(subq-imm-to-reg)([make-literal [- #0 [get-current-offset n]] null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..]
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) gens c relocs ..]
      [generate-load (@ expr-binding-aug (@ expr-expression n)) #0 (make-asmN(rax)()..) (make-asmN(r10)()..) c relocs ..]
      
      [prepend (make-asmN(leave)()..) c ..]
      
      [prepend (make-asmN(popq-reg)((make-asmN(r11)()..))..) c ..]
      [prepend (make-asmN(addq-imm-to-reg)([make-literal [* #6(word-size)] null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..]
      [prepend (make-asmN(pushq-reg)((make-asmN(r11)()..))..) c ..]
      [prepend (make-asmN(ret)()..) c ..]
      [prepend (make-asmN(label)([use-binding-aug after-binding ..])..) c ..])))}
      (ignore))))

(constrain generate-invoke
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-invoke (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-invoke-)] {success (do
      [generate-args-to-buffer n gens c relocs ..]
      (if (or [= (@ expr-contains-flag n) (contains-with)] [= (@ expr-contains-flag n) (contains-none)])
        (foreach (t [reverse (@ expr-arguments n) ..]) (do
          [generate-load (@ expr-binding-aug t) #0 (make-asmN(r11)()..) (make-asmN(r10)()..) c relocs ..]
          [prepend (make-asmN(pushq-reg) ((make-asmN(r11)()..)) ..) c ..]))
        (ignore))
      
      [generate-expression (@ expr-reference n) gens c relocs ..]
      [generate-load (@ expr-binding-aug (@ expr-reference n)) #0 (make-asmN(r11)()..) (make-asmN(r10)()..) c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #0]
        [prepend (make-asmN(popq-reg)((make-asmN(rdi)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #1]
        [prepend (make-asmN(popq-reg)((make-asmN(rsi)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #2]
        [prepend (make-asmN(popq-reg)((make-asmN(rdx)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #3]
        [prepend (make-asmN(popq-reg)((make-asmN(rcx)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #4]
        [prepend (make-asmN(popq-reg)((make-asmN(r8)()..))..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #5]
        [prepend (make-asmN(popq-reg)((make-asmN(r9)()..))..) c ..] (ignore))
      
      [prepend (make-asmN(movq-imm-to-reg)([make-literal #0 null-fragment null-expr ..] (make-asmN(rax)()..))..) c ..]
      [prepend (make-asmN(call-reg)((make-asmN(r11)()..))..) c ..]
      [generate-store (make-asmN(rax)()..) (@ expr-binding-aug n) #0 (make-asmN(r10)()..) c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-asmN(addq-imm-to-reg)([make-literal drop null-fragment null-expr ..] (make-asmN(rsp)()..))..) c ..])
        (ignore)))}
      (ignore))))

(constrain generate-constrain
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-constrain (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-constrain-)]
      {success (do
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [generate-move (@ expr-binding-aug (@ expr-expression n)) #0 (@ expr-binding-aug n) #0 (make-asmN(r10)()..)
          (make-asmN(r11)()..) c relocs ..])}
    (ignore))))

(constrain generate-expression
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list expr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-expression (n gens c relocs r handler)
  (substitute (.. r handler) (with success (do
    (foreach (gen gens) [[generator->function gen] n gens c relocs success ..])
    [generate-continuation n gens c relocs success ..]
    [generate-with n gens c relocs success ..]
    [generate-jump n gens c relocs success ..]
    [generate-symbol n gens c relocs success ..]
    [generate-storage n gens c relocs success ..]
    [generate-if n gens c relocs success ..]
    [generate-literal n gens c relocs success ..]
    [generate-function n gens c relocs success ..]
    [generate-invoke n gens c relocs success ..]
    [generate-constrain n gens c relocs success ..]))))

(constrain generate-program
  (\ r (with-vars (a b) (`(function ((list expr) (list generator) ,b buffer ,a) (values (list expr) (list reloc)))r)r)))

(function generate-program (exprs gens outs r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (do
    [prepend (make-asmN(pushq-reg)((make-asmN(rbp)()..))..) c ..]
    [prepend (make-asmN(movq-reg-to-reg)((make-asmN(rsp)()..) (make-asmN(rbp)()..))..) c ..]
    (foreach (expr exprs) [generate-expression expr gens c relocs ..])
    [prepend (make-asmN(leave)()..) c ..]
    [prepend (make-asmN(ret)()..) c ..]
    (values (use-storage outs) [reverse $c ..] $relocs)))))

