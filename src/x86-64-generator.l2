(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(constrain layout-frame-storages (\ r (with-vars (a) (`(function (expr ,a) ,a)r)r)))

(function layout-frame-storages (n offset)
  (switch = (@ expr-type n)
    ((-function-) (do
      (setf expr-frame-size n [layout-frame-storages (@ expr-expression n) [- #0 (word-size)]])
      offset))
    
    ((-constrain-)
      [layout-frame-storages (@ expr-expression n) offset])
    
    ((-invoke-) (-jump-)
      (let (offset [layout-frame-storages (@ expr-reference n) offset])
      (fold (offset offset) (u (@ expr-arguments n)) [layout-frame-storages u offset])))
    
    ((-if-)
      (let (offset [layout-frame-storages (@ expr-condition n) offset])
      (let (offset [layout-frame-storages (@ expr-consequent n) offset])
      (let (offset [layout-frame-storages (@ expr-alternate n) offset])
        offset))))
    
    ((-continuation-) (-with-)
      (if (@ expr-escapes n)
        (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]]) (do
        (let (offset-ref (storage _ offset))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset (@ expr-symbol-binding-aug t) $offset-ref)
          (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
          [set+ offset-ref (word-size)])))
        (let (cont-bndg (@ expr-symbol-binding-aug(@ expr-reference n)))
          (offset [- offset (cont-size)]) (do
        (setf bndg-size cont-bndg (cont-size))
        (setf bndg-offset cont-bndg offset)
        [layout-frame-storages (@ expr-expression n) offset]))))
        [layout-frame-storages (@ expr-expression n) offset]))
    
    ((-storage-)
      (let (storage-size [* [length (@ expr-arguments n)] (word-size)])
      (let (offset [- offset storage-size]) (do
      (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) storage-size)
      (setf bndg-offset (@ expr-symbol-binding-aug(@ expr-reference n)) offset)
      (let (offset-ref (storage _ offset))
      (foreach (u (@ expr-arguments n)) (do
        (setf bndg-offset (@ expr-binding-aug u) $offset-ref)
        [set+ offset-ref (word-size)])))
      (fold (offset offset) (u (@ expr-arguments n)) [layout-frame-storages u offset])))))
    
    offset))

(ignore
  Takes a binding, a register to assign it to, and a bit-vector indicating the registers
  already in use. Assigns the given binding to the given register if it is not already in
  use and returns an indication to that effect, otherwise it fails.)

(constrain try-binding-to-register (\ r (with-vars (a b c) (`(function (bndg-aug register ,a ,b) (values ,c ,a))r)r)))

(function try-binding-to-register (bndg reg in-use ret-val)
  (let (reg-idx [band reg (hex F)])
  (let (reg-occupied? [band [<< #1 reg-idx] in-use])
  (if reg-occupied?
    (values (use-storage ret-val) (false) in-use)
    (do
      (setf bndg-storage bndg (register-storage))
      (setf bndg-offset bndg reg)
      (values (use-storage ret-val) (true) [bor [<< #1 reg-idx] in-use]))))))

(ignore
  Takes a binding, the current offset in the stack frame, and a bit-vector indicating the
  registers that are currently in use. Returns the new stack offset and register usage
  bit-vector after the given bit-vector is placed.)

(constrain binding-to-register/memory (\ r (with-vars (a b) (`(function (bndg-aug ,a ,b) ,b)r)r)))

(function binding-to-register/memory (bndg offset in-use) (do
  (setf bndg-size bndg (word-size))
  (if [= in-use (hex FFFFFFFFFFFFFFFF)]
    (do
      (setf bndg-offset bndg [- offset (word-size)])
      in-use)
    (do
      (setf bndg-storage bndg (register-storage))
      (let (free-register-idx [lb [bnot in-use]])
      (let (free-register ($(loc (unit) free-register-idx x64-r64s)))
      (let (new-in-use [bor in-use [<< #1 free-register-idx]]) (do
      (setf bndg-offset bndg free-register)
      new-in-use))))))))

(constrain layout-frames (\ r (with-vars (a b c) (`(function (expr ,b ,c) (values ,b ,a))r)r)))

(function layout-frames (n offset ret-val) (do
  (setf bndg-size (@ expr-binding-aug n) (word-size))
  (switch = (@ expr-type n)
    ((-function-) (do
      (let (offset [- (@ expr-frame-size n) (word-size)])
      (bind (frame-size used-registers) [layout-frames (@ expr-expression n) offset bind] (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
      (setf expr-frame-size n frame-size)
      (fold (parameter-offset [* #2 (word-size)]) (t (@ expr-parameters n)) (do
        (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
        (setf bndg-offset (@ expr-symbol-binding-aug t) parameter-offset)
        [+ parameter-offset (word-size)])))))
      (values (use-storage ret-val) offset (hex FFFFFFFFFFFF0637))))
    
    ((-continuation-) (-with-)
      (let (offset (if (@ expr-escapes n) offset
          (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]]) (do
          (fold (offset offset) (t (@ expr-parameters n)) (do
            (setf bndg-offset (@ expr-symbol-binding-aug t) offset)
            (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
            [+ offset (word-size)]))
          (let (cont-bndg (@ expr-symbol-binding-aug(@ expr-reference n))) (do
          (setf bndg-size cont-bndg #0)
          (setf bndg-offset cont-bndg offset)
          offset))))))
        (let (offset [- offset (word-size)]) (do
        (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
        [layout-frames (@ expr-expression n) offset ret-val]))))
    
    ((-storage-)
      (fold (memory-state (values (use-storage ret-val) offset (hex FFFFFFFFFFFF0637))) (u (@ expr-arguments n))
        (bind (bottom-offset in-use) memory-state
        (bind (bottom-offset' in-use') [layout-frames u offset bind]
        (values (use-storage ret-val) [min bottom-offset bottom-offset'] [bor in-use in-use'])))))
    
    ((-jump-)
      (let (sub-expr-offset [- offset [* [+ [length (@ expr-arguments n)] #1] (word-size)]])
      (let (memory-state [layout-frames (@ expr-reference n) sub-expr-offset ret-val])
      (bind (bottom-offset in-use)
        (fold (memory-state memory-state) (u (@ expr-arguments n))
          (bind (bottom-offset in-use) memory-state
          (bind (bottom-offset' in-use') [layout-frames u sub-expr-offset bind]
          (values (use-storage ret-val) [min bottom-offset bottom-offset'] [bor in-use in-use']))))
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug(@ expr-reference n)) offset)
      (let (offset [- offset [* [length (@ expr-arguments n)] (word-size)]])
      (fold (offset offset) (u (@ expr-arguments n)) (do
        (setf bndg-offset (@ expr-binding-aug u) offset)
        [+ offset (word-size)])))
      (values (use-storage ret-val) bottom-offset in-use)))))))
    
    ((-invoke-)
      (bind (bottom-offset in-use)
        (let (sub-expr-offset [- offset [* [+ [length (@ expr-arguments n)] #1] (word-size)]])
        (let (memory-state [layout-frames (@ expr-reference n) sub-expr-offset ret-val])
        (fold (memory-state memory-state) (u (@ expr-arguments n))
          (bind (bottom-offset in-use) memory-state
          (bind (bottom-offset' in-use') [layout-frames u sub-expr-offset bind]
          (values storage [min bottom-offset bottom-offset'] [bor in-use in-use']))))))
          
      (let (arg-offset [- offset [* [+[length (@ expr-arguments n)]#1] (word-size)]])
      (let
        (in-use (if [< [length (@ expr-arguments n)] #1] in-use
          (let (arg1-binding (@ expr-binding-aug [@car (@ expr-arguments n)]))
          (bind (arg1-success? in-use) [try-binding-to-register arg1-binding (rdi) in-use bind]
            (where (if arg1-success? in-use [binding-to-register/memory arg1-binding [+ arg-offset [*(word-size)#0]] in-use])
        (in-use (if [< [length (@ expr-arguments n)] #2] in-use
          (let (arg2-binding (@ expr-binding-aug [@cadr (@ expr-arguments n)]))
          (bind (arg2-success? in-use) [try-binding-to-register arg2-binding (rsi) in-use bind]
            (where (if arg2-success? in-use [binding-to-register/memory arg2-binding [+ arg-offset [*(word-size)#1]] in-use])
        (in-use (if [< [length (@ expr-arguments n)] #3] in-use
          (let (arg3-binding (@ expr-binding-aug [@caddr (@ expr-arguments n)]))
          (bind (arg3-success? in-use) [try-binding-to-register arg3-binding (rdx) in-use bind]
            (where (if arg3-success? in-use [binding-to-register/memory arg3-binding [+ arg-offset [*(word-size)#2]] in-use])
        (in-use (if [< [length (@ expr-arguments n)] #4] in-use
          (let (arg4-binding (@ expr-binding-aug [@cadddr (@ expr-arguments n)]))
          (bind (arg4-success? in-use) [try-binding-to-register arg4-binding (rcx) in-use bind]
            (where (if arg4-success? in-use [binding-to-register/memory arg4-binding [+ arg-offset [*(word-size)#3]] in-use])
        (in-use (if [< [length (@ expr-arguments n)] #5] in-use
          (let (arg5-binding (@ expr-binding-aug [@caddddr (@ expr-arguments n)]))
          (bind (arg5-success? in-use) [try-binding-to-register arg5-binding (r8) in-use bind]
            (where (if arg5-success? in-use [binding-to-register/memory arg5-binding [+ arg-offset [*(word-size)#4]] in-use])
        (in-use (if [< [length (@ expr-arguments n)] #6] in-use
          (let (arg6-binding (@ expr-binding-aug [@cadddddr (@ expr-arguments n)]))
          (bind (arg6-success? in-use) [try-binding-to-register arg6-binding (r9) in-use bind]
            (if arg6-success? in-use [binding-to-register/memory arg6-binding [+ arg-offset [*(word-size)#5]] in-use]))))))))))))))))))))))))))))))
      
      (let (in-use
        (let (rem-offset [+ arg-offset [* #6 (word-size)]])
        (let (rem-args (if [< [length (@ expr-arguments n)] #6] nil [@cddddddr (@ expr-arguments n)]))
        (loop assign-args (offset rem-offset) (in-use in-use) (u rem-args)
          (if [nil? u] in-use
            {assign-args [+ offset (word-size)] [binding-to-register/memory (@ expr-binding-aug [@car u]) offset in-use] [@cdr u]})))))
      
      (let (ref-offset [- offset (word-size)])
      (let (in-use [binding-to-register/memory (@ expr-binding-aug(@ expr-reference n)) ref-offset in-use])
      (values (use-storage ret-val) bottom-offset in-use))))))))
    
    ((-if-)
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-condition n)) offset)
      (setf bndg-offset (@ expr-binding-aug (@ expr-consequent n)) offset)
      (setf bndg-offset (@ expr-binding-aug (@ expr-alternate n)) offset)
      (bind (bottom-offset in-use) [layout-frames (@ expr-condition n) offset bind]
      (bind (bottom-offset' in-use') [layout-frames (@ expr-consequent n) offset bind]
      (bind (bottom-offset'' in-use'') [layout-frames (@ expr-alternate n) offset bind]
      (values (use-storage ret-val)
        [min bottom-offset [min bottom-offset' bottom-offset'']]
        [bor in-use [bor in-use' in-use'']])))))))
    
    ((-constrain-)
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
      [layout-frames (@ expr-expression n) offset ret-val])))
    
    (values (use-storage ret-val) offset (hex FFFFFFFFFFFF0637)))))

(constrain generator->function
  (\ r (with-vars (a b) (`(function (generator)
    (function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a b) (`(function
    ((function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)) generator)r)r)))

(function function->generator (x) [cast x])

(constrain make-absolute-relocation-immediate
  (\ r (with-vars (a b c) (`(function (,a ,b bndg-aug (ref (list reloc)) buffer ,c) operand)r)r)))

(function make-absolute-relocation-immediate (size addend bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-8))
          (#2 (r-x86-64-16))
          (#4 (r-x86-64-32))
          (#8 (r-x86-64-64))
          (ignore)) op bndg addend
        (function _(ctx ofst size instr-pos instr-size) ctx) ..] relocs ..]
      op))))

(constrain make-relative-relocation-immediate
  (\ r (with-vars (a b) (`(function (,a bndg-aug (ref (list reloc)) buffer ,b) operand)r)r)))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-pc8))
          (#2 (r-x86-64-pc16))
          (#4 (r-x86-64-pc32))
          (#8 (r-x86-64-pc64))
          (ignore)) op bndg (ignore)
        (function _(ctx ofst size instr-pos instr-size)
          [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
      op))))

(constrain make-label (\ r (with-vars (a) (`(function (bndg-aug buffer ,a) instr)r)r)))

(function make-label (bndg r handler)
  (substitute (.. r handler)
    (let (lbl (make-instrN (label) () ..)) (do
      (setf instr-binding lbl bndg)
      lbl))))

(constrain bndg->partial-op (\ r (with-vars (a b) (`(function (,b bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->partial-op (op-size bndg relocs buf handler)
  (substitute (.. buf handler)
    (if [= (@ bndg-storage bndg) (absolute-storage)]
      (let (op [make-mem-op op-size (rip) (none) #0 #0 #4 ..]) (do
        [prepend [make-relocation (r-x86-64-pc32) op bndg (ignore)
          (function _(ctx ofst size instr-pos instr-size)
            [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
        op))
    
    (if (and [= (@ bndg-storage bndg) (frame-relative-storage)] [= (@ bndg-state bndg) (defined-state)])
      [make-mem-op op-size (rbp) (none) #0 (@ bndg-offset bndg) #4 ..]
    
    (if [= (@ bndg-storage bndg) (register-storage)]
      [make-reg-op
        [(switch = op-size
          (#1 reg-lower-8)
          (#2 reg-lower-16)
          (#4 reg-lower-32)
          (#8 reg-lower-64)
          (ignore)) (@ bndg-offset bndg)] ..]
    
      (ignore))))))

(constrain bndg->op (\ r (with-vars (a) (`(function (bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->op (bndg relocs buf handler)
  [bndg->partial-op (@ bndg-size bndg) bndg relocs buf handler])

(constrain generate-if
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-if (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-if-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (condition-val-bndg (@ expr-binding-aug (@ expr-condition n)))
          (consequent-val-bndg (@ expr-binding-aug (@ expr-consequent n)))
          (alternate-val-bndg (@ expr-binding-aug (@ expr-alternate n)))
          (alternate-instr-bndg [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [generate-expression (@ expr-condition n) gens c relocs ..]
        [prepend (make-instrN(x86-or)([bndg->op condition-val-bndg relocs ..][bndg->op condition-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-je) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]
        [generate-expression (@ expr-consequent n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op consequent-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-instr-bndg ..] c ..]
        [generate-expression (@ expr-alternate n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op alternate-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true))))))

(constrain generate-storage
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-storage (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-storage-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (storage-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n))) (do
        (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
        
        [prepend(make-instrN(x86-lea)
          ([bndg->op expr-val-bndg relocs ..][bndg->op storage-val-bndg relocs ..][make-reg-op(r10) ..])..) c ..]
        (true))))))

(constrain generate-symbol
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-symbol (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-symbol-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (symbol-val-bndg (@ expr-symbol-binding-aug n))
          (target-expr (@ bndg-expression(@ expr-symbol-binding-aug n))) (do
        (if (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
            (not [nil? (find (x (@ expr-parameters target-expr)) [= x (@ bndg-symbol (@ expr-symbol-binding-aug n))])]))
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r10)..]) ..) c ..]
          [prepend (make-instrN(x86-lea)
            ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r10)..])..) c ..])
        (true))))))

(constrain generate-store-continuation (\ r (with-vars (a) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-store-continuation (n c relocs r handler)
  (substitute (.. r handler) (let
      (cont-val-bndg (@ expr-symbol-binding-aug (@ expr-reference n)))
      (cont-instr-bndg (@ expr-cont-instr-bndg n)) (do
    [prepend (make-instrN (x86-lea) ([make-reg-op (r9) ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-rbx)#4 ..] [make-reg-op (rbx) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r12)#4 ..] [make-reg-op (r12) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r13)#4 ..] [make-reg-op (r13) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r14)#4 ..] [make-reg-op (r14) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r15)#4 ..] [make-reg-op (r15) ..]) ..) c ..]
    [prepend (make-instrN (x86-lea) ([make-mem-op(word-size)(r9)(none)#0(cont-cir)#4 ..] [bndg->op cont-instr-bndg relocs ..] [make-reg-op (r10) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-rbp)#4 ..] [make-reg-op (rbp) ..]) ..) c ..]))))

(constrain generate-buffer-to-dest
  (\ r (with-vars (a b) (`(function (expr register ,a (ref (list instr)) (ref (list reloc)) buffer ,b) ())r)r)))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler)
  (substitute (.. r handler)
    (let (dest-offset (storage _ offset))
      (foreach (t (@ expr-arguments n)) (let
          (arg-val-bndg (@ expr-binding-aug t)) (do
        [prepend (make-instrN (x86-mov)
          ([make-mem-op(word-size)dest-reg(none)#0 $dest-offset #4 ..][bndg->op arg-val-bndg relocs ..][make-reg-op(r10)..]) ..) c ..]
        [set+ dest-offset (word-size)]))))))

(constrain generate-continuation
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-continuation (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-continuation-)]
      (let
          (cont-val-bndg (@ expr-symbol-binding-aug (@ expr-reference n)))
          (expr-val-bndg (@ expr-binding-aug n))
          (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) (do
          [prepend (make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op cont-val-bndg relocs ..][make-reg-op (r10) ..]) ..) c ..]
          [generate-store-continuation n c relocs ..])
          (ignore))
        
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 after-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend [make-label after-binding ..] c ..]
        (true))))))

(constrain generate-with
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-with (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-with-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
          (param-val-bndg (@ expr-symbol-binding-aug[@car(@ expr-parameters n)]))
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) [generate-store-continuation n c relocs ..] (ignore))
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op body-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op param-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true))))))

(constrain generate-load-continuation
  (\ r (with-vars (a) (`(function (register (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-load-continuation (src-reg c relocs r handler)
  (substitute (.. r handler) (do
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbx) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbx)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r12) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r12)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r13) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r13)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r14) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r14)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r15) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r15)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [make-mem-op(word-size)src-reg(none)#0(cont-cir)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbp) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbp)#4 ..]) ..) c ..]
    [prepend (make-instrN(x86-jmp)([make-reg-op (r10) ..])..) c ..])))

(constrain generate-jump
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-jump (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-jump-)]
      (do (if [not= (@ expr-short-circuit n) null-expr]
        (let (cont-instr-bndg (@ expr-cont-instr-bndg(@ expr-short-circuit n))) (do
          (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
            [generate-expression (@ expr-reference n) gens c relocs ..]
            (ignore))
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          (foreach (t (@ expr-arguments n)) (u (@ expr-parameters(@ expr-short-circuit n)))
            (let (src-bndg (@ expr-binding-aug t)) (dest-bndg (@ expr-symbol-binding-aug u))
              [prepend (make-instrN(x86-mov)([bndg->op dest-bndg relocs ..][bndg->op src-bndg relocs ..][make-reg-op(r10)..])..) c ..]))
          [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 cont-instr-bndg relocs ..]) ..) c ..]))
          
        (let (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          [generate-expression (@ expr-reference n) gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r11) ..] [bndg->op ref-val-bndg relocs ..]) ..) c ..]
          [generate-buffer-to-dest n (r11) (cont-size) c relocs ..]
          [generate-load-continuation (r11) c relocs ..])))
          
        (true)))))

(constrain generate-literal
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-literal (n gens c relocs r handler) (substitute (.. r handler)
  (and [= (@ expr-type n) (-literal-)]
    (let (expr-val-bndg (@ expr-binding-aug n)) (do
      [prepend(make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][make-imm-op #8 (@ expr-value n)..][make-reg-op (r11)..])..) c ..]
      (true))))))

(constrain generate-function
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-function (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-function-)] (let
        (ref-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n)))
        (expr-val-bndg (@ expr-binding-aug n))
        (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
        (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      
      [prepend(make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op ref-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
      [prepend (make-instrN (x86-jmp)([make-relative-relocation-immediate #4 after-binding relocs ..])..) c ..]
      [prepend [make-label ref-val-bndg ..] c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      
      (ignore Insert first 6 parameters onto stack)
      [prepend (make-instrN(x86-push)([make-reg-op (r9) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r8) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rcx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rsi) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdi) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
      [prepend (make-instrN(x86-sub)([make-reg-op (rsp) ..] [make-imm-op #4 [- #0 (@ expr-frame-size n)] ..])..) c ..]
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) gens c relocs ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [bndg->op body-val-bndg relocs ..])..) c ..]
      
      [prepend (make-instrN(x86-leave)()..) c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 [* #6(word-size)] ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-ret)()..) c ..]
      [prepend [make-label after-binding ..] c ..]
      (true))))))

(constrain generate-invoke
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-invoke (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-invoke-)] (let
        (expr-val-bndg (@ expr-binding-aug n))
        (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
      (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
      (if (or [= (@ expr-contains-flag n) (contains-with)] [= (@ expr-contains-flag n) (contains-none)])
        (foreach (t [reverse (@ expr-arguments n) ..])
          (let (src-val-bndg (@ expr-binding-aug t))
            [prepend (make-instrN(x86-push) ([bndg->op src-val-bndg relocs ..]) ..) c ..]))
        (ignore))
      
      [generate-expression (@ expr-reference n) gens c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #0]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #1]
        [prepend (make-instrN(x86-pop)([make-reg-op (rsi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #2]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #3]
        [prepend (make-instrN(x86-pop)([make-reg-op (rcx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #4]
        [prepend (make-instrN(x86-pop)([make-reg-op (r8) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #5]
        [prepend (make-instrN(x86-pop)([make-reg-op (r9) ..])..) c ..] (ignore))
      
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [make-imm-op #8 #0 ..])..) c ..]
      [prepend (make-instrN(x86-call)([bndg->op ref-val-bndg relocs ..])..) c ..]
      [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..])..) c ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 drop ..])..) c ..])
        (ignore))
      (true))))))

(constrain generate-constrain
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-constrain (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-constrain-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n))) (do
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op body-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        (true))))))

(constrain generate-expression
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-expression (n gens c relocs r handler)
  (substitute (.. r handler) (or
    (fold (found? (false)) (gen gens) (or found? [[generator->function gen] n gens c relocs ..]))
    [generate-continuation n gens c relocs ..]
    [generate-with n gens c relocs ..]
    [generate-jump n gens c relocs ..]
    [generate-symbol n gens c relocs ..]
    [generate-storage n gens c relocs ..]
    [generate-if n gens c relocs ..]
    [generate-literal n gens c relocs ..]
    [generate-function n gens c relocs ..]
    [generate-invoke n gens c relocs ..]
    [generate-constrain n gens c relocs ..])))

(constrain generate-program
  (\ r (with-vars (a b) (`(function ((list expr) (list generator) ,b buffer ,a) (values (list instr) (list reloc)))r)r)))

(function generate-program (exprs gens outs r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (do
    [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
    [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
    (foreach (expr exprs) [generate-expression expr gens c relocs ..])
    [prepend (make-instrN(x86-leave)()..) c ..]
    [prepend (make-instrN(x86-ret)()..) c ..]
    (values (use-storage outs) [reverse $c ..] $relocs)))))

