(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(constrain layout-frame-storages (\ r (with-vars (a) (`(function (expr ,a) ,a)r)r)))

(function layout-frame-storages (n offset)
  (switch = (@ expr-type n)
    ((-function-) (do
      (setf expr-frame-size n [layout-frame-storages (@ expr-expression n) [- #0 (word-size)]])
      offset))
    
    ((-constrain-)
      [layout-frame-storages (@ expr-expression n) offset])
    
    ((-invoke-) (-jump-)
      (let (offset [layout-frame-storages (@ expr-reference n) offset])
      (fold (offset offset) (u (@ expr-arguments n)) [layout-frame-storages u offset])))
    
    ((-if-)
      (let (offset [layout-frame-storages (@ expr-condition n) offset])
      (let (offset [layout-frame-storages (@ expr-consequent n) offset])
      (let (offset [layout-frame-storages (@ expr-alternate n) offset])
        offset))))
    
    ((-continuation-) (-with-)
      (if (@ expr-escapes n)
        (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]]) (do
        (let (offset-ref (storage _ offset))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset (@ expr-symbol-binding-aug t) $offset-ref)
          (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
          [set+ offset-ref (word-size)])))
        (let (cont-bndg (@ expr-symbol-binding-aug(@ expr-reference n)))
          (offset [- offset (cont-size)]) (do
        (setf bndg-size cont-bndg (cont-size))
        (setf bndg-offset cont-bndg offset)
        [layout-frame-storages (@ expr-expression n) offset]))))
        [layout-frame-storages (@ expr-expression n) offset]))
    
    ((-storage-)
      (let (storage-size [* [length (@ expr-arguments n)] (word-size)])
      (let (offset [- offset storage-size]) (do
      (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) storage-size)
      (setf bndg-offset (@ expr-symbol-binding-aug(@ expr-reference n)) offset)
      (let (offset-ref (storage _ offset))
      (foreach (u (@ expr-arguments n)) (do
        (setf bndg-offset (@ expr-binding-aug u) $offset-ref)
        [set+ offset-ref (word-size)])))
      (fold (offset offset) (u (@ expr-arguments n)) [layout-frame-storages u offset])))))
    
    offset))

(constrain layout-frames (\ r (with-vars (b) (`(function (expr ,b) ,b)r)r)))

(function layout-frames (n offset) (do
  (setf bndg-size (@ expr-binding-aug n) (word-size))
  (switch = (@ expr-type n)
    ((-function-) (do
      (let (offset [- (@ expr-frame-size n) (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
      (setf expr-frame-size n [layout-frames (@ expr-expression n) offset])
      (let (parameter-offset-ref (storage _ [* #2 (word-size)]))
      (foreach (t (@ expr-parameters n)) (do
        (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
        (setf bndg-offset (@ expr-symbol-binding-aug t) $parameter-offset-ref)
        [set+ parameter-offset-ref (word-size)])))))
      offset))
    
    ((-continuation-) (-with-)
      (let (offset (if (@ expr-escapes n) offset
          (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]]) (do
          (let (offset-ref (storage _ offset))
          (foreach (t (@ expr-parameters n)) (do
            (setf bndg-offset (@ expr-symbol-binding-aug t) $offset-ref)
            (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
            [set+ offset-ref (word-size)])))
          (let (cont-bndg (@ expr-symbol-binding-aug(@ expr-reference n))) (do
          (setf bndg-size cont-bndg #0)
          (setf bndg-offset cont-bndg offset)
          offset))))))
        (let (offset [- offset (word-size)]) (do
        (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
        [layout-frames (@ expr-expression n) offset]))))
    
    ((-storage-)
      (fold (bottom-offset offset) (u (@ expr-arguments n))
        [min bottom-offset [layout-frames u offset]]))
    
    ((-jump-) (-invoke-)
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug(@ expr-reference n)) offset)
      (let (offset-ref (storage _ offset)) (do
      (foreach (u (@ expr-arguments n)) (do
        [set- offset-ref (word-size)]
        (setf bndg-offset (@ expr-binding-aug u) $offset-ref)))
      (let (bottom-offset [layout-frames (@ expr-reference n) $offset-ref])
      (fold (bottom-offset bottom-offset) (u (@ expr-arguments n))
        [min bottom-offset [layout-frames u $offset-ref]])))))))
    
    ((-if-)
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-condition n)) offset)
      (setf bndg-offset (@ expr-binding-aug (@ expr-consequent n)) offset)
      (setf bndg-offset (@ expr-binding-aug (@ expr-alternate n)) offset)
      [min [layout-frames (@ expr-condition n) offset]
      [min [layout-frames (@ expr-consequent n) offset]
        [layout-frames (@ expr-alternate n) offset]]])))
    
    ((-constrain-)
      (let (offset [- offset (word-size)]) (do
      (setf bndg-offset (@ expr-binding-aug (@ expr-expression n)) offset)
      [layout-frames (@ expr-expression n) offset])))
    
    offset)))

(constrain collect-static-bindings (\ r (with-vars (a) (`(function (expr (ref (list bndg-aug)) buffer ,a) bndg-aug)r)r)))

(function collect-static-bindings (n binding-augs r handler)
  (substitute (.. r handler) (do
    (switch = (@ expr-type n)
      ((-continuation-) (-with-) (do
        [append [collect-static-bindings (@ expr-expression n) binding-augs ..] binding-augs ..]
        (if (@ expr-escapes n)
          [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..] (ignore))
        (foreach (t (@ expr-parameters n))
          [append (@ expr-symbol-binding-aug t) binding-augs ..])))
      
      ((-storage-) (do
        [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append [collect-static-bindings u binding-augs ..] binding-augs ..])))
      
      ((-jump-) (-invoke-) (do
        [append [collect-static-bindings (@ expr-reference n) binding-augs ..] binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append [collect-static-bindings u binding-augs ..] binding-augs ..])))
      
      ((-if-) (do
        [append [collect-static-bindings (@ expr-condition n) binding-augs ..] binding-augs ..]
        [append [collect-static-bindings (@ expr-consequent n) binding-augs ..] binding-augs ..]
        [append [collect-static-bindings (@ expr-alternate n) binding-augs ..] binding-augs ..]))
      
      ((-constrain-)
        [append [collect-static-bindings (@ expr-expression n) binding-augs ..] binding-augs ..])
      
      (ignore))
      
    (@ expr-binding-aug n))))

(constrain generator->function
  (\ r (with-vars (a b) (`(function (generator)
    (function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a b) (`(function
    ((function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)) generator)r)r)))

(function function->generator (x) [cast x])

(constrain make-absolute-relocation-immediate
  (\ r (with-vars (a b c) (`(function (,a ,b bndg-aug (ref (list reloc)) buffer ,c) operand)r)r)))

(function make-absolute-relocation-immediate (size addend bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-8))
          (#2 (r-x86-64-16))
          (#4 (r-x86-64-32))
          (#8 (r-x86-64-64))
          (ignore)) op bndg addend
        (function _(ctx ofst size instr-pos instr-size) ctx) ..] relocs ..]
      op))))

(constrain make-relative-relocation-immediate
  (\ r (with-vars (a b) (`(function (,a bndg-aug (ref (list reloc)) buffer ,b) operand)r)r)))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-pc8))
          (#2 (r-x86-64-pc16))
          (#4 (r-x86-64-pc32))
          (#8 (r-x86-64-pc64))
          (ignore)) op bndg (ignore)
        (function _(ctx ofst size instr-pos instr-size)
          [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
      op))))

(constrain make-label (\ r (with-vars (a) (`(function (bndg-aug buffer ,a) instr)r)r)))

(function make-label (bndg r handler)
  (substitute (.. r handler)
    (let (lbl (make-instrN (label) () ..)) (do
      (setf instr-binding lbl bndg)
      lbl))))

(constrain bndg->partial-op (\ r (with-vars (a b) (`(function (,b bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->partial-op (op-size bndg relocs buf handler)
  (substitute (.. buf handler)
    (if [= (@ bndg-storage bndg) (absolute-storage)]
      (let (op [make-mem-op op-size (rip) (none) #0 #0 #4 ..]) (do
        [prepend [make-relocation (r-x86-64-pc32) op bndg (ignore)
          (function _(ctx ofst size instr-pos instr-size)
            [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
        op))
        
    (if (and [= (@ bndg-storage bndg) (frame-relative-storage)] [= (@ bndg-state bndg) (defined-state)])
      [make-mem-op op-size (rbp) (none) #0 (@ bndg-offset bndg) #4 ..]
      
      (ignore)))))

(constrain bndg->op (\ r (with-vars (a) (`(function (bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->op (bndg relocs buf handler)
  [bndg->partial-op (@ bndg-size bndg) bndg relocs buf handler])

(constrain generate-if
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-if (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-if-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (condition-val-bndg (@ expr-binding-aug (@ expr-condition n)))
          (consequent-val-bndg (@ expr-binding-aug (@ expr-consequent n)))
          (alternate-val-bndg (@ expr-binding-aug (@ expr-alternate n)))
          (alternate-instr-bndg [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [generate-expression (@ expr-condition n) gens c relocs ..]
        [prepend (make-instrN(x86-or)([bndg->op condition-val-bndg relocs ..][bndg->op condition-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-je) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]
        [generate-expression (@ expr-consequent n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op consequent-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-instr-bndg ..] c ..]
        [generate-expression (@ expr-alternate n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op alternate-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true))))))

(constrain generate-storage
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-storage (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-storage-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (storage-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n))) (do
        (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
        
        [prepend(make-instrN(x86-lea)
          ([bndg->op expr-val-bndg relocs ..][bndg->op storage-val-bndg relocs ..][make-reg-op(r10) ..])..) c ..]
        (true))))))

(constrain generate-symbol
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-symbol (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-symbol-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (symbol-val-bndg (@ expr-symbol-binding-aug n))
          (target-expr (@ bndg-expression(@ expr-symbol-binding-aug n))) (do
        (if (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
            (not [nil? (find (x (@ expr-parameters target-expr)) [= x (@ bndg-symbol (@ expr-symbol-binding-aug n))])]))
          [prepend (make-instrN(x86-mov)
            ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r10)..]) ..) c ..]
          [prepend (make-instrN(x86-lea)
            ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r10)..])..) c ..])
        (true))))))

(constrain generate-store-continuation (\ r (with-vars (a) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-store-continuation (n c relocs r handler)
  (substitute (.. r handler) (let
      (cont-val-bndg (@ expr-symbol-binding-aug (@ expr-reference n)))
      (cont-instr-bndg (@ expr-cont-instr-bndg n)) (do
    [prepend (make-instrN (x86-lea) ([make-reg-op (r9) ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-rbx)#4 ..] [make-reg-op (rbx) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r12)#4 ..] [make-reg-op (r12) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r13)#4 ..] [make-reg-op (r13) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r14)#4 ..] [make-reg-op (r14) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-r15)#4 ..] [make-reg-op (r15) ..]) ..) c ..]
    [prepend (make-instrN (x86-lea) ([make-mem-op(word-size)(r9)(none)#0(cont-cir)#4 ..] [bndg->op cont-instr-bndg relocs ..] [make-reg-op (r10) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(none)#0(cont-rbp)#4 ..] [make-reg-op (rbp) ..]) ..) c ..]))))

(constrain generate-buffer-to-dest
  (\ r (with-vars (a b) (`(function (expr register ,a (ref (list instr)) (ref (list reloc)) buffer ,b) ())r)r)))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler)
  (substitute (.. r handler)
    (let (dest-offset (storage _ offset))
      (foreach (t (@ expr-arguments n)) (let
          (arg-val-bndg (@ expr-binding-aug t)) (do
        [prepend (make-instrN (x86-mov)
          ([make-mem-op(word-size)dest-reg(none)#0 $dest-offset #4 ..][bndg->op arg-val-bndg relocs ..][make-reg-op(r10)..]) ..) c ..]
        [set+ dest-offset (word-size)]))))))

(constrain generate-continuation
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-continuation (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-continuation-)]
      (let
          (cont-val-bndg (@ expr-symbol-binding-aug (@ expr-reference n)))
          (expr-val-bndg (@ expr-binding-aug n))
          (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) (do
          [prepend (make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op cont-val-bndg relocs ..][make-reg-op (r10) ..]) ..) c ..]
          [generate-store-continuation n c relocs ..])
          (ignore))
        
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 after-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend [make-label after-binding ..] c ..]
        (true))))))

(constrain generate-with
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-with (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-with-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
          (param-val-bndg (@ expr-symbol-binding-aug[@car(@ expr-parameters n)]))
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) [generate-store-continuation n c relocs ..] (ignore))
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op body-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op param-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true))))))

(constrain generate-load-continuation
  (\ r (with-vars (a) (`(function (register (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-load-continuation (src-reg c relocs r handler)
  (substitute (.. r handler) (do
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbx) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbx)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r12) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r12)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r13) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r13)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r14) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r14)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r15) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r15)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [make-mem-op(word-size)src-reg(none)#0(cont-cir)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbp) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbp)#4 ..]) ..) c ..]
    [prepend (make-instrN(x86-jmp)([make-reg-op (r10) ..])..) c ..])))

(constrain generate-jump
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-jump (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-jump-)]
      (do (if [not= (@ expr-short-circuit n) null-expr]
        (let (cont-instr-bndg (@ expr-cont-instr-bndg(@ expr-short-circuit n))) (do
          (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
            [generate-expression (@ expr-reference n) gens c relocs ..]
            (ignore))
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          (foreach (t (@ expr-arguments n)) (u (@ expr-parameters(@ expr-short-circuit n)))
            (let (src-bndg (@ expr-binding-aug t)) (dest-bndg (@ expr-symbol-binding-aug u))
              [prepend (make-instrN(x86-mov)([bndg->op dest-bndg relocs ..][bndg->op src-bndg relocs ..][make-reg-op(r10)..])..) c ..]))
          [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 cont-instr-bndg relocs ..]) ..) c ..]))
          
        (let (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          [generate-expression (@ expr-reference n) gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r11) ..] [bndg->op ref-val-bndg relocs ..]) ..) c ..]
          [generate-buffer-to-dest n (r11) (cont-size) c relocs ..]
          [generate-load-continuation (r11) c relocs ..])))
          
        (true)))))

(constrain generate-literal
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-literal (n gens c relocs r handler) (substitute (.. r handler)
  (and [= (@ expr-type n) (-literal-)]
    (let (expr-val-bndg (@ expr-binding-aug n)) (do
      [prepend(make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][make-imm-op #8 (@ expr-value n)..][make-reg-op (r11)..])..) c ..]
      (true))))))

(constrain generate-function
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-function (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-function-)] (let
        (ref-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n)))
        (expr-val-bndg (@ expr-binding-aug n))
        (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
        (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
      
      [prepend(make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op ref-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
      [prepend (make-instrN (x86-jmp)([make-relative-relocation-immediate #4 after-binding relocs ..])..) c ..]
      [prepend [make-label ref-val-bndg ..] c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      
      (ignore Insert first 6 parameters onto stack)
      [prepend (make-instrN(x86-push)([make-reg-op (r9) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r8) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rcx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rsi) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdi) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
      [prepend (make-instrN(x86-sub)([make-reg-op (rsp) ..] [make-imm-op #4 [- #0 (@ expr-frame-size n)] ..])..) c ..]
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) gens c relocs ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [bndg->op body-val-bndg relocs ..])..) c ..]
      
      [prepend (make-instrN(x86-leave)()..) c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 [* #6(word-size)] ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-ret)()..) c ..]
      [prepend [make-label after-binding ..] c ..]
      (true))))))

(constrain generate-invoke
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-invoke (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-invoke-)] (let
        (expr-val-bndg (@ expr-binding-aug n))
        (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
      (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
      (if (or [= (@ expr-contains-flag n) (contains-with)] [= (@ expr-contains-flag n) (contains-none)])
        (foreach (t [reverse (@ expr-arguments n) ..])
          (let (src-val-bndg (@ expr-binding-aug t))
            [prepend (make-instrN(x86-push) ([bndg->op src-val-bndg relocs ..]) ..) c ..]))
        (ignore))
      
      [generate-expression (@ expr-reference n) gens c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #0]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #1]
        [prepend (make-instrN(x86-pop)([make-reg-op (rsi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #2]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #3]
        [prepend (make-instrN(x86-pop)([make-reg-op (rcx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #4]
        [prepend (make-instrN(x86-pop)([make-reg-op (r8) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #5]
        [prepend (make-instrN(x86-pop)([make-reg-op (r9) ..])..) c ..] (ignore))
      
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [make-imm-op #8 #0 ..])..) c ..]
      [prepend (make-instrN(x86-call)([bndg->op ref-val-bndg relocs ..])..) c ..]
      [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..])..) c ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 drop ..])..) c ..])
        (ignore))
      (true))))))

(constrain generate-constrain
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-constrain (n gens c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-constrain-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n))) (do
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][bndg->op body-val-bndg relocs ..][make-reg-op(r10)..])..) c ..]
        (true))))))

(constrain generate-expression
  (\ r (with-vars (a b) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-expression (n gens c relocs r handler)
  (substitute (.. r handler) (or
    (fold (found? (false)) (gen gens) (or found? [[generator->function gen] n gens c relocs ..]))
    [generate-continuation n gens c relocs ..]
    [generate-with n gens c relocs ..]
    [generate-jump n gens c relocs ..]
    [generate-symbol n gens c relocs ..]
    [generate-storage n gens c relocs ..]
    [generate-if n gens c relocs ..]
    [generate-literal n gens c relocs ..]
    [generate-function n gens c relocs ..]
    [generate-invoke n gens c relocs ..]
    [generate-constrain n gens c relocs ..])))

(constrain generate-program
  (\ r (with-vars (a b) (`(function ((list expr) (list generator) ,b buffer ,a) (values (list instr) (list reloc)))r)r)))

(function generate-program (exprs gens outs r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (do
    [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
    [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
    (foreach (expr exprs) [generate-expression expr gens c relocs ..])
    [prepend (make-instrN(x86-leave)()..) c ..]
    [prepend (make-instrN(x86-ret)()..) c ..]
    (values (use-storage outs) [reverse $c ..] $relocs)))))

