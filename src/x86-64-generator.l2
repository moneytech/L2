(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(constrain layout-frames (\ r (with-vars (a) (`(function (expr (ref (list bndg-aug)) buffer ,a) bndg-aug)r)r)))

(function layout-frames (n binding-augs r handler)
  (substitute (.. r handler) (do
    (switch = (@ expr-type n)
      ((-function-) (do
        [append [layout-frames (@ expr-expression n) (& expr-binding-augs n) ..] (& expr-binding-augs n) ..]
        (let (parameter-offset-ref (storage _ [* #2 (word-size)])) (do
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset (@ expr-symbol-binding-aug t) $parameter-offset-ref)
          [set+ parameter-offset-ref (word-size)]))))
        (let (binding-offset-ref (storage _ #0)) (do
        (foreach (u [reverse (@ expr-binding-augs n) ..]) (do
          [set- binding-offset-ref [pad-size (@ bndg-size u) (word-size)]]
          (setf bndg-offset u $binding-offset-ref)))))))
      
      ((-continuation-) (-with-) (do
        [append [layout-frames (@ expr-expression n) binding-augs ..] binding-augs ..]
        (if (@ expr-escapes n) (do
          (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) (cont-size))
          [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..])
          (ignore))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-size (@ expr-symbol-binding-aug t) (word-size))
          [append (@ expr-symbol-binding-aug t) binding-augs ..]))))
      
      ((-storage-) (do
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        (setf bndg-size (@ expr-symbol-binding-aug(@ expr-reference n)) #0)
        [append (@ expr-symbol-binding-aug(@ expr-reference n)) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append (@ expr-binding-aug u) binding-augs ..])))
      
      ((-jump-) (-invoke-) (do
        [append [layout-frames (@ expr-reference n) binding-augs ..] binding-augs ..]
        (foreach (u (@ expr-arguments n)) [layout-frames u binding-augs ..])
        [append (@ expr-binding-aug (@ expr-reference n)) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [append (@ expr-binding-aug u) binding-augs ..])))
      
      ((-if-) (do
        [append [layout-frames (@ expr-condition n) binding-augs ..] binding-augs ..]
        [append [layout-frames (@ expr-consequent n) binding-augs ..] binding-augs ..]
        [append [layout-frames (@ expr-alternate n) binding-augs ..] binding-augs ..]))
      
      ((-constrain-)
        [append [layout-frames (@ expr-expression n) binding-augs ..] binding-augs ..])
      
      (ignore))
      
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (@ expr-binding-aug n))))

(constrain generator->function
  (\ r (with-vars (a) (`(function (generator)
    (function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ()))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a) (`(function
    ((function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())) generator)r)r)))

(function function->generator (x) [cast x])

(constrain make-absolute-relocation-immediate
  (\ r (with-vars (a b c) (`(function (,a ,b bndg-aug (ref (list reloc)) buffer ,c) operand)r)r)))

(function make-absolute-relocation-immediate (size addend bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-8))
          (#2 (r-x86-64-16))
          (#4 (r-x86-64-32))
          (#8 (r-x86-64-64))
          (ignore)) op bndg addend ..] relocs ..]
      op))))

(constrain make-relative-relocation-immediate
  (\ r (with-vars (a b) (`(function (,a bndg-aug (ref (list reloc)) buffer ,b) operand)r)r)))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-pc8))
          (#2 (r-x86-64-pc16))
          (#4 (r-x86-64-pc32))
          (#8 (r-x86-64-pc64))
          (ignore)) op bndg [- #0 size] ..] relocs ..]
      op))))

(constrain make-label (\ r (with-vars (a) (`(function (bndg-aug buffer ,a) instr)r)r)))

(function make-label (bndg r handler)
  (substitute (.. r handler)
    (let (lbl (make-instrN (label) () ..)) (do
      (setf instr-binding lbl bndg)
      lbl))))

(constrain bndg->op (\ r (with-vars (a) (`(function (bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->op (bndg relocs buf handler)
  (substitute (.. buf handler)
    (let (op-size (@ bndg-size bndg))
      (if (and [= (@ bndg-storage bndg) (absolute-storage)] [= (@ bndg-storage bndg) (instruction-storage)])
        (let (op [make-mem-op op-size (rip) (n/a) #0 #0 #4 ..]) (do
          [prepend [make-relocation (r-x86-64-pc32) op bndg
            (function _(ofst size instr)
              (let (ibndg (@ instr-binding instr))
                [- ofst [+ (@ bndg-offset ibndg) (@ bndg-size ibndg)]])) ..] relocs ..]
          op))
      
      (if (and [= (@ bndg-storage bndg) (absolute-storage)] [= (@ bndg-storage bndg) (instruction-storage)]
          [= (@ bndg-state bndg) (defined-state)])
        [make-mem-op op-size (rip) (n/a) #0 (@ bndg-offset bndg) #4 ..]
          
      (if (and [= (@ bndg-storage bndg) (frame-relative-storage)] [= (@ bndg-state bndg) (defined-state)])
        [make-mem-op op-size (rbp) (n/a) #0 (@ bndg-offset bndg) #4 ..]
        
        (ignore)))))))

(constrain generate-if
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-if (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-if-)]
      {success (let
          (expr-val-bndg (@ expr-binding-aug n))
          (condition-val-bndg (@ expr-binding-aug (@ expr-condition n)))
          (consequent-val-bndg (@ expr-binding-aug (@ expr-consequent n)))
          (alternate-val-bndg (@ expr-binding-aug (@ expr-alternate n)))
          (alternate-instr-bndg [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        [generate-expression (@ expr-condition n) gens c relocs ..]
        [prepend (make-instrN (x86-or) ([bndg->op condition-bndg relocs ..] [bndg->op condition-bndg relocs ..]) ..) c ..]
        [prepend (make-instrN (x86-je) ([make-relative-relocation-immediate #4 alternate-binding relocs ..]) ..) c ..]
        [generate-expression (@ expr-consequent n) gens c relocs ..]
        [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op consequent-val-bndg relocs ..]) ..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-binding ..] c ..]
        [generate-expression (@ expr-alternate n) gens c relocs ..]
        [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op alternate-val-bndg relocs ..]) ..) c ..]
        [prepend [make-label end-binding ..] c ..]))}
      (ignore))))

(constrain generate-storage
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-storage (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-storage-)]
      {success (let
          (expr-val-bndg (@ expr-binding-aug n))
          (storage-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n))) (do
        (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
        [prepend (make-instrN (x86-lea) ([bndg->op expr-val-bndg relocs ..] [bndg->op storage-val-bndg relocs ..]) ..) c ..]))}
      (ignore))))

(constrain generate-symbol
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-symbol (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-symbol-)]
      {success (let
          (expr-val-bndg (@ expr-binding-aug n))
          (symbol-val-bndg (@ expr-symbol-binding-aug n))
          (target-expr (@ bndg-expression(@ expr-symbol-binding-aug n)))
        (if (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
            (not [nil? (find (x (@ expr-parameters target-expr)) [= x (@ bndg-symbol (@ expr-symbol-binding-aug n))])]))
          [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op symbol-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-lea) ([bndg->op expr-val-bndg relocs ..] [bndg->op symbol-val-bndg relocs ..]) ..) c ..]))}
      (ignore))))

(constrain generate-store-continuation (\ r (with-vars (a) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-store-continuation (n c relocs r handler)
  (substitute (.. r handler) (let
      (cont-val-bndg (@ expr-symbol-binding-aug n))
      (cont-instr-bndg (@ expr-cont-instr-bndg n)) (do
    [prepend (make-instrN (x86-lea) ([make-reg-op (r9) ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-rbx)#4 ..] [make-reg-op (rbx) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-r12)#4 ..] [make-reg-op (r12) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-r13)#4 ..] [make-reg-op (r13) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-r14)#4 ..] [make-reg-op (r14) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-r15)#4 ..] [make-reg-op (r15) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-cir)#4 ..] [bndg->op cont-instr-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r9)(n/a)#0(cont-rbp)#4 ..] [make-reg-op (rbp) ..]) ..) c ..]))))

(constrain generate-buffer-to-dest
  (\ r (with-vars (a b) (`(function (expr register ,a (ref (list instr)) (ref (list reloc)) buffer ,b) ())r)r)))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler)
  (substitute (.. r handler)
    (let (dest-offset (storage _ offset))
      (foreach (t (@ expr-arguments n)) (let
          (arg-val-bndg (@ expr-binding-aug t)) (do
        [prepend (make-instrN (x86-mov)
          ([make-mem-op(word-size)dest-reg(n/a)#0 $dest-offset #4 ..] [bndg->op arg-val-bndg relocs ..]) ..) c ..]
        [set+ dest-offset (word-size)]))))))

(constrain generate-continuation
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-continuation (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-continuation-)] {success
      (let
          (cont-val-bndg (@ expr-symbol-binding-aug (@ expr-reference n)))
          (expr-val-bndg (@ expr-binding-aug n))
          (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) (do
          [prepend (make-instrN (x86-lea) ([bndg->op expr-val-bndg relocs ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
          [generate-store-continuation n c relocs ..])
          (ignore))
        
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 after-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend [make-label after-binding ..] c ..]))}
      (ignore))))

(constrain generate-with
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-with (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-with-)]
      {success (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
          (param-val-bndg (@ expr-symbol-binding-aug[@car(@ expr-parameters n)]))
          (end-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        (if (@ expr-escapes n) [generate-store-continuation n c relocs ..] (ignore))
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op body-val-bndg relocs ..]) ..) c ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op param-val-bndg relocs ..]) ..) c ..]
        [prepend [make-label end-binding ..] c ..]))}
      (ignore))))

(constrain generate-load-continuation
  (\ r (with-vars (a) (`(function (register (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-load-continuation (src-reg c relocs r handler)
  (substitute (.. r handler) (do
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbx) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-rbx)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r12) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-r12)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r13) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-r13)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r14) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-r14)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r15) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-r15)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r10) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-cir)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbp) ..] [make-mem-op(word-size)src-reg(n/a)#0(cont-rbp)#4 ..]) ..) c ..]
    [prepend (make-instrN(x86-jmp)([make-reg-op (r10) ..])..) c ..])))

(constrain generate-jump
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-jump (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-jump-)] {success
      (if [not= (@ expr-short-circuit n) null-expr]
        (let (cont-instr-bndg (@ expr-cont-instr-bndg(@ expr-short-circuit n))) (do
          (if [= (@ expr-type(@ expr-reference n)) (-continuation-)]
            [generate-expression (@ expr-reference n) gens c relocs ..]
            (ignore))
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          (foreach (t (@ expr-arguments n)) (u (@ expr-parameters(@ expr-short-circuit n)))
            (let (src-bndg (@ expr-binding-aug t)) (dest-bndg (@ expr-symbol-binding-aug u))
              [prepend (make-instrN (x86-mov) ([bndg->op dest-bndg relocs ..] [bndg->op src-bndg relocs ..]) ..) c ..]))
          [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 cont-instr-bndg relocs ..]) ..) c ..]))
          
        (let (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
          (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
          [generate-expression (@ expr-reference n) gens c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (r11) ..] [bndg->op ref-val-bndg relocs ..]) ..) c ..]
          [generate-buffer-to-dest n (r11) (cont-size) c relocs ..]
          [generate-load-continuation (r11) c relocs ..])))}
      (ignore))))

(constrain generate-literal
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-literal (n gens c relocs success r handler) (substitute (.. r handler)
  (if [= (@ expr-type n) (-literal-)]
    {success (let (expr-val-bndg (@ expr-binding-aug n))
      [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [make-imm-op #8 (@ expr-value n) ..]) ..) c ..])}
    (ignore))))

(function get-current-offset (func)
  (if [> [length (@ expr-binding-augs func)] #0]
    (@ bndg-offset [@car (@ expr-binding-augs func)])
    #0))

(constrain generate-function
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-function (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-function-)] {success (let
        (ref-val-bndg (@ expr-symbol-binding-aug(@ expr-reference n)))
        (expr-val-bndg (@ expr-binding-aug n))
        (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
        (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-expr null-expr ..]) (do
        
      [prepend (make-instrN (x86-lea) ([bndg->op expr-val-bndg relocs ..] [bndg->op ref-val-bndg relocs ..]) ..) c ..]
      [prepend (make-instrN (x86-jmp)([make-relative-relocation-immediate #4 after-binding relocs ..])..) c ..]
      [prepend [make-label ref-val-bndg ..] c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      
      (ignore Insert first 6 parameters onto stack)
      [prepend (make-instrN(x86-push)([make-reg-op (r9) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r8) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rcx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdx) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rsi) ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rdi) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      
      [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
      [prepend (make-instrN(x86-sub)([make-reg-op (rsp) ..] [make-imm-op #4 [- #0 [get-current-offset n]] ..])..) c ..]
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) gens c relocs ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [bndg->op body-val-bndg relocs ..])..) c ..]
      
      [prepend (make-instrN(x86-leave)()..) c ..]
      
      [prepend (make-instrN(x86-pop)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 [* #6(word-size)] ..])..) c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (r11) ..])..) c ..]
      [prepend (make-instrN(x86-ret)()..) c ..]
      [prepend [make-label after-binding ..] c ..]))}
      (ignore))))

(constrain generate-invoke
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-invoke (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-invoke-)] {success (let
        (expr-val-bndg (@ expr-binding-aug n))
        (ref-val-bndg (@ expr-binding-aug (@ expr-reference n))) (do
      (foreach (t (@ expr-arguments n)) [generate-expression t gens c relocs ..])
      (if (or [= (@ expr-contains-flag n) (contains-with)] [= (@ expr-contains-flag n) (contains-none)])
        (foreach (t [reverse (@ expr-arguments n) ..])
          (let (src-val-bndg (@ expr-binding-aug t))
            [prepend (make-instrN(x86-push) ([bndg->op src-val-bndg relocs ..]) ..) c ..]))
        (ignore))
      
      [generate-expression (@ expr-reference n) gens c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #0]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #1]
        [prepend (make-instrN(x86-pop)([make-reg-op (rsi) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #2]
        [prepend (make-instrN(x86-pop)([make-reg-op (rdx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #3]
        [prepend (make-instrN(x86-pop)([make-reg-op (rcx) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #4]
        [prepend (make-instrN(x86-pop)([make-reg-op (r8) ..])..) c ..] (ignore))
      (if [> [length (@ expr-arguments n)] #5]
        [prepend (make-instrN(x86-pop)([make-reg-op (r9) ..])..) c ..] (ignore))
      
      [prepend (make-instrN(x86-mov)([make-reg-op (rax) ..] [make-imm-op #8 #0 ..])..) c ..]
      [prepend (make-instrN(x86-call)(ref-val-bndg)..) c ..]
      [prepend (make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..] [make-reg-op (rax) ..])..) c ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 drop ..])..) c ..])
        (ignore))))}
      (ignore))))

(constrain generate-constrain
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) (continuation (())) buffer ,a) ())r)r)))

(function generate-constrain (n gens c relocs success r handler)
  (substitute (.. r handler)
    (if [= (@ expr-type n) (-constrain-)]
      {success (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n))) (do
        [generate-expression (@ expr-expression n) gens c relocs ..]
        [prepend (make-instrN (x86-mov) ([bndg->op expr-val-bndg relocs ..] [bndg->op body-val-bndg relocs ..]) ..) c ..]))}
    (ignore))))

(constrain generate-expression
  (\ r (with-vars (a) (`(function (expr (list generator) (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-expression (n gens c relocs r handler)
  (substitute (.. r handler) (with success (do
    (foreach (gen gens) [[generator->function gen] n gens c relocs success ..])
    [generate-continuation n gens c relocs success ..]
    [generate-with n gens c relocs success ..]
    [generate-jump n gens c relocs success ..]
    [generate-symbol n gens c relocs success ..]
    [generate-storage n gens c relocs success ..]
    [generate-if n gens c relocs success ..]
    [generate-literal n gens c relocs success ..]
    [generate-function n gens c relocs success ..]
    [generate-invoke n gens c relocs success ..]
    [generate-constrain n gens c relocs success ..]))))

(constrain generate-program
  (\ r (with-vars (a b) (`(function ((list expr) (list generator) ,b buffer ,a) (values (list instr) (list reloc)))r)r)))

(function generate-program (exprs gens outs r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (do
    [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
    [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
    (foreach (expr exprs) [generate-expression expr gens c relocs ..])
    [prepend (make-instrN(x86-leave)()..) c ..]
    [prepend (make-instrN(x86-ret)()..) c ..]
    (values (use-storage outs) [reverse $c ..] $relocs)))))

