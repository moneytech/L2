(function word-size (l r) [=# #8 r])

(ignore Offsets for the register contents in the continuation buffer.)

  (function cont-size (l r) [=# [* #7 (word-size)] r])

  (function cont-r15 (l r) [=# [* #6 (word-size)] r])

  (function cont-r12 (l r) [=# [* #5 (word-size)] r])

  (function cont-rbx (l r) [=# [* #4 (word-size)] r])

  (function cont-r13 (l r) [=# [* #3 (word-size)] r])

  (function cont-r14 (l r) [=# [* #2 (word-size)] r])

  (function cont-cir (l r) [=# [* #1 (word-size)] r])

  (function cont-rbp (l r) [=# [* #0 (word-size)] r])

(function callee-saved-x64-r64s-len (l r) [=# #5 r])

(storage callee-saved-x64-r64s (rbx)(r12)(r13)(r14)(r15))

(constrain place-perm-bindings (\ r (with-vars (a) (`(function (expr ,a) ,a)r)r)))

(function place-perm-bindings (n offset)
  (switch = (@ expr-type n)
    ((-function-) (do
      (setf expr-frame-size n [place-perm-bindings (@ expr-expression n) [- #0 [* (callee-saved-x64-r64s-len)(word-size)]]])
      offset))
    
    ((-constrain-)
      [place-perm-bindings (@ expr-expression n) offset])
    
    ((-invoke-) (-jump-)
      (let (offset [place-perm-bindings (@ expr-target n) offset])
      (fold (offset offset) (u (@ expr-arguments n)) [place-perm-bindings u offset])))
    
    ((-if-)
      (let (offset [place-perm-bindings (@ expr-condition n) offset])
      (let (offset [place-perm-bindings (@ expr-consequent n) offset])
      (let (offset [place-perm-bindings (@ expr-alternate n) offset])
        offset))))
    
    ((-continuation-) (-with-)
      (if (@ expr-escapes n)
        (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]]) (do
        (let (offset-ref (storage _ offset))
        (foreach (t (@ expr-parameters n)) (do
          (setf bndg-offset t $offset-ref)
          (setf bndg-size t (word-size))
          [set+ offset-ref (word-size)])))
        (let (cont-bndg (@ expr-reference n))
          (offset [- offset (cont-size)]) (do
        (setf bndg-size cont-bndg (cont-size))
        (setf bndg-offset cont-bndg offset)
        [place-perm-bindings (@ expr-expression n) offset]))))
        [place-perm-bindings (@ expr-expression n) offset]))
    
    ((-storage-)
      (let (storage-size [* [length (@ expr-arguments n)] (word-size)])
      (let (offset [- offset storage-size]) (do
      (setf bndg-size (@ expr-reference n) storage-size)
      (setf bndg-offset (@ expr-reference n) offset)
      (let (offset-ref (storage _ offset))
      (foreach (u (@ expr-arguments n)) (do
        (setf bndg-size (@ expr-binding-aug u) (word-size))
        (setf bndg-offset (@ expr-binding-aug u) $offset-ref)
        [set+ offset-ref (word-size)])))
      (fold (offset offset) (u (@ expr-arguments n)) [place-perm-bindings u offset])))))
    
    offset))

(ignore
  Checks whether the given register is in use according to the given register usage
  vector.)

(constrain register-in-use? (\ r (`(function (register reg-use-vec) ())r)))

(function register-in-use? (reg reg-use-vec)
  (let (reg-idx [band reg (hex F)])
  (if [band [<< #1 reg-idx] reg-use-vec] (true) (false))))

(ignore
  Takes a binding, a register to assign it to, and a bit-vector indicating the registers
  already in use. Assigns the given binding to the given register if it is not already in
  use and returns an indication to that effect, otherwise it fails.)

(constrain try-binding-to-register (\ r (with-vars (b c) (`(function (bndg-aug register reg-use-vec ,b) (values ,c reg-use-vec))r)r)))

(function try-binding-to-register (bndg reg in-use ret-val)
  (let (reg-idx [band reg (hex F)])
  (let (reg-occupied? [band [<< #1 reg-idx] in-use])
  (if reg-occupied?
    (values (use-storage ret-val) (false) in-use)
    (do
      (setf bndg-size bndg (word-size))
      (setf bndg-storage bndg (register-storage))
      (setf bndg-offset bndg reg)
      (values (use-storage ret-val) (true) [bor [<< #1 reg-idx] in-use]))))))

(ignore
  Takes a binding, the current offset in the stack frame, and a bit-vector indicating the
  registers that are currently in use. Returns the new stack offset and register usage
  bit-vector after the given bit-vector is placed.)

(constrain binding-to-register/memory (\ r (with-vars (a) (`(function (bndg-aug ,a reg-use-vec) reg-use-vec)r)r)))

(function binding-to-register/memory (bndg offset in-use)
    (do
      (setf bndg-size bndg (word-size))
      (setf bndg-offset bndg offset)
      in-use)
    )

(function expr-to-register/memory (n offset in-use)
  [binding-to-register/memory (@ expr-binding-aug n) offset in-use])

(constrain initializer->function
  (\ r (with-vars (b c) (`(function (initializer)
    (function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c))r)r)))

(function initializer->function (x) [cast x])

(constrain function->initializer
  (\ r (with-vars (b c) (`(function
    ((function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)) initializer)r)r)))

(function function->initializer (x) [cast x])

(constrain generate-function
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-function (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-function-)] (let
        (ref-val-bndg (@ expr-reference n))
        (expr-val-bndg (@ expr-binding-aug n))
        (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
        (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..]) (do
      
      [prepend(make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op ref-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
      [prepend (make-instrN (x86-jmp)([make-relative-relocation-immediate #4 after-binding relocs ..])..) c ..]
      [prepend [make-label ref-val-bndg ..] c ..]
      [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
      [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
      [prepend (make-instrN(x86-sub)([make-reg-op (rsp) ..] [make-imm-op #4 [- #0 (@ expr-frame-size n)] ..])..) c ..]
      
      (let (save-offset [- #0 [* (callee-saved-x64-r64s-len)(word-size)]])
      (until (i #0) [= i (callee-saved-x64-r64s-len)] [+ i #1]
        (let (current-register ($(loc(word-size)i callee-saved-x64-r64s)))
          (if [register-in-use? current-register (@ expr-registers-used n)]
            [prepend (make-instrN (x86-mov)
              ([make-mem-op(word-size)(rbp)(none)#0[+ save-offset[* i(word-size)]]#4 ..]
              [make-reg-op current-register ..]) ..) c ..]
            (ignore)))))
       
      (ignore Move first 6 parameters to their slots)
      (and [> [length (@ expr-parameters n)] #0] (do
        [generate-bndg-register-move [@car(@ expr-parameters n)] (rdi) c relocs ..]
      (and [> [length (@ expr-parameters n)] #1] (do
        [generate-bndg-register-move [@cadr(@ expr-parameters n)] (rsi) c relocs ..]
      (and [> [length (@ expr-parameters n)] #2] (do
        [generate-bndg-register-move [@caddr(@ expr-parameters n)] (rdx) c relocs ..]
      (and [> [length (@ expr-parameters n)] #3] (do
        [generate-bndg-register-move [@cadddr(@ expr-parameters n)] (rcx) c relocs ..]
      (and [> [length (@ expr-parameters n)] #4] (do
        [generate-bndg-register-move [@caddddr(@ expr-parameters n)] (r8) c relocs ..]
      (and [> [length (@ expr-parameters n)] #5]
        [generate-bndg-register-move [@cadddddr(@ expr-parameters n)] (r9) c relocs ..])))))))))))
      
      (let (rem-offset [* #2(word-size)])
      (let (rem-params (if [>= [length (@ expr-parameters n)] #6] [@cddddddr (@ expr-parameters n)] nil))
      (fold (offset rem-offset) (u rem-params) (do
        [prepend (make-instrN(x86-mov)
          ([bndg->op u relocs ..][make-mem-op(word-size)(rbp)(none)#0 offset #4 ..][make-reg-op(r11)..])..) c ..]
        [+ offset (word-size)]))))
      
      (ignore Execute the function body)
      [generate-expression (@ expr-expression n) c relocs ..]
      [generate-register-bndg-move (rax) body-val-bndg c relocs ..]
      
      (let (save-offset [- #0 [* (callee-saved-x64-r64s-len)(word-size)]])
      (until (i #0) [= i (callee-saved-x64-r64s-len)] [+ i #1]
        (let (current-register ($(loc(word-size)i callee-saved-x64-r64s)))
          (if [register-in-use? current-register (@ expr-registers-used n)]
            [prepend (make-instrN (x86-mov)
              ([make-reg-op current-register ..]
              [make-mem-op(word-size)(rbp)(none)#0[+ save-offset[* i(word-size)]]#4 ..]) ..) c ..]
            (ignore)))))
            
      [prepend (make-instrN(x86-leave)()..) c ..]
      [prepend (make-instrN(x86-ret)()..) c ..]
      [prepend [make-label after-binding ..] c ..]
      (true))))))

(constrain initialize-function (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-function (n offset inits ret-val)
  (and [= (@ expr-type n) (-function-)] (do
    (let (sub-expr-offset [- (@ expr-frame-size n) [* #7(word-size)]])
    (bind (frame-size in-use) [initialize-expression (@ expr-expression n) sub-expr-offset inits bind]
    (let (in-use [bor in-use (hex FFFFFFFFFFFF0831)])
    (let (param-offset [- (@ expr-frame-size n) [* #6(word-size)]])
    (let
      (in-use (if [< [length (@ expr-parameters n)] #1] in-use
        (let (param1-binding [@car (@ expr-parameters n)])
        (bind (param1-success? in-use) [try-binding-to-register param1-binding (rdi) in-use bind]
          (where (if param1-success? in-use [binding-to-register/memory param1-binding [+ param-offset [*(word-size)#0]] in-use])
      (in-use (if [< [length (@ expr-parameters n)] #2] in-use
        (let (param2-binding [@cadr (@ expr-parameters n)])
        (bind (param2-success? in-use) [try-binding-to-register param2-binding (rsi) in-use bind]
          (where (if param2-success? in-use [binding-to-register/memory param2-binding [+ param-offset [*(word-size)#1]] in-use])
      (in-use (if [< [length (@ expr-parameters n)] #3] in-use
        (let (param3-binding [@caddr (@ expr-parameters n)])
        (bind (param3-success? in-use) [try-binding-to-register param3-binding (rdx) in-use bind]
          (where (if param3-success? in-use [binding-to-register/memory param3-binding [+ param-offset [*(word-size)#2]] in-use])
      (in-use (if [< [length (@ expr-parameters n)] #4] in-use
        (let (param4-binding [@cadddr (@ expr-parameters n)])
        (bind (param4-success? in-use) [try-binding-to-register param4-binding (rcx) in-use bind]
          (where (if param4-success? in-use [binding-to-register/memory param4-binding [+ param-offset [*(word-size)#3]] in-use])
      (in-use (if [< [length (@ expr-parameters n)] #5] in-use
        (let (param5-binding [@caddddr (@ expr-parameters n)])
        (bind (param5-success? in-use) [try-binding-to-register param5-binding (r8) in-use bind]
          (where (if param5-success? in-use [binding-to-register/memory param5-binding [+ param-offset [*(word-size)#4]] in-use])
      (in-use (if [< [length (@ expr-parameters n)] #6] in-use
        (let (param6-binding [@cadddddr (@ expr-parameters n)])
        (bind (param6-success? in-use) [try-binding-to-register param6-binding (r9) in-use bind]
          (if param6-success? in-use [binding-to-register/memory param6-binding [+ param-offset [*(word-size)#5]] in-use]))))))))))))))))))))))))))))))
    
    (let (in-use
      (let (rem-offset [* #2(word-size)])
      (let (rem-params (if [>= [length (@ expr-parameters n)] #6] [@cddddddr (@ expr-parameters n)] nil))
      (loop assign-params (offset rem-offset) (in-use in-use) (u rem-params)
        (if [nil? u] in-use
          {assign-params [+ offset (word-size)]
            [binding-to-register/memory [@car u] offset in-use] [@cdr u]})))))
    
    (let (in-use [expr-to-register/memory (@ expr-expression n) sub-expr-offset in-use]) (do
    (setf expr-registers-used n in-use)
    (setf expr-frame-size n frame-size)
    (foreach (t (@ expr-parameters n)) (setf bndg-size t (word-size)))))))))))
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-function])
    (values (use-storage ret-val) offset (hex 0000000000000800))
    (true))))

(constrain generate-store-continuation (\ r (with-vars (a) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-store-continuation (n c relocs r handler)
  (substitute (.. r handler) (let
      (cont-val-bndg (@ expr-reference n))
      (cont-instr-bndg (@ expr-cont-instr-bndg n)) (do
    [prepend (make-instrN (x86-lea) ([make-reg-op (r11) ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-rbx)#4 ..] [make-reg-op (rbx) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-r12)#4 ..] [make-reg-op (r12) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-r13)#4 ..] [make-reg-op (r13) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-r14)#4 ..] [make-reg-op (r14) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-r15)#4 ..] [make-reg-op (r15) ..]) ..) c ..]
    [prepend (make-instrN (x86-lea) ([make-mem-op(word-size)(r11)(none)#0(cont-cir)#4 ..] [bndg->op cont-instr-bndg relocs ..] [make-reg-op (r10) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#0(cont-rbp)#4 ..] [make-reg-op (rbp) ..]) ..) c ..]))))

(constrain generate-continuation
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-continuation (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-continuation-)]
      (let
          (cont-val-bndg (@ expr-reference n))
          (expr-val-bndg (@ expr-binding-aug n))
          (after-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..]) (do
        (if (@ expr-escapes n) (do
          [prepend (make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op cont-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
          [generate-store-continuation n c relocs ..])
          (ignore))
        
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 after-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
        [generate-expression (@ expr-expression n) c relocs ..]
        [prepend [make-label after-binding ..] c ..]
        (true))))))

(constrain initialize-continuation (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-continuation (n offset inits ret-val)
  (and [= (@ expr-type n) (-continuation-)]
    (let (bottom-offset [- offset [* [+ [length (@ expr-parameters n)] #1] (word-size)]])
    (bind (frame-size in-use) [initialize-expression (@ expr-expression n) bottom-offset inits bind]
    (let (in-use [bor (hex FFFFFFFFFFFF0C38) in-use])
    (let (in-use [expr-to-register/memory (@ expr-expression n) bottom-offset in-use]) (do
    (let (in-use
      (if (@ expr-escapes n) in-use
        (let (offset [- offset [* [length (@ expr-parameters n)] (word-size)]])
        (let (cont-bndg (@ expr-reference n)) (do
        (setf bndg-size cont-bndg #0)
        (setf bndg-offset cont-bndg offset)
        (loop assign-args (offset offset) (in-use in-use) (u (@ expr-parameters n))
          (if [nil? u] in-use
            {assign-args [+ offset (word-size)]
              [binding-to-register/memory [@car u] offset in-use] [@cdr u]}))))))) (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-continuation])
    (values (use-storage ret-val) frame-size in-use)
    (true))))))))))

(constrain generate-with
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-with (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-with-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n)))
          (param-val-bndg [@car(@ expr-parameters n)])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..]) (do
        (if (@ expr-escapes n) [generate-store-continuation n c relocs ..] (ignore))
        [generate-expression (@ expr-expression n) c relocs ..]
        (if (@ expr-escapes n)
          (do
            [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
            [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..]
            [generate-bndg-bndg-move expr-val-bndg param-val-bndg (r11) c relocs ..]
            [prepend [make-label end-instr-binding ..] c ..])
          [prepend [make-label (@ expr-cont-instr-bndg n) ..] c ..])
        (true))))))

(constrain initialize-with (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-with (n offset inits ret-val)
  (and (or [= (@ expr-type n) (-with-)]) (do
    (setf expr-binding-aug (@ expr-expression n) (@ expr-binding-aug n))
    (bind (frame-size in-use) [initialize-expression (@ expr-expression n) offset inits bind] (do
    (if (@ expr-escapes n) (ignore)
      (let (cont-bndg (@ expr-reference n)) (do
      (setf bndg-size cont-bndg #0)
      (setf bndg-offset cont-bndg offset)
      [set (& car (@ expr-parameters n)) (@ expr-binding-aug n)])))
    (let (in-use [bor (hex FFFFFFFFFFFF0C38) in-use]) (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-with])
    (values (use-storage ret-val) frame-size in-use)
    (true))))))))

(constrain generate-storage
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-storage (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-storage-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (storage-val-bndg (@ expr-reference n)) (do
        (foreach (t (@ expr-arguments n)) [generate-expression t c relocs ..])
        [prepend(make-instrN(x86-lea)
          ([bndg->op expr-val-bndg relocs ..][bndg->op storage-val-bndg relocs ..][make-reg-op(r11) ..])..) c ..]
        (true))))))

(constrain initialize-storage (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-storage (n offset inits ret-val)
  (and [= (@ expr-type n) (-storage-)] (do
    (fold (memory-state (values (use-storage ret-val) offset (hex 0000000000000800))) (u (@ expr-arguments n))
      (bind (bottom-offset in-use) memory-state
      (bind (bottom-offset' in-use') [initialize-expression u offset inits bind]
      (values (use-storage ret-val) [min bottom-offset bottom-offset'] [bor in-use in-use']))))
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-storage])
    (true))))

(constrain generate-buffer-to-dest
  (\ r (with-vars (a b) (`(function (expr register ,a (ref (list instr)) (ref (list reloc)) buffer ,b) ())r)r)))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler)
  (substitute (.. r handler)
    (let (dest-offset (storage _ offset))
      (foreach (t (@ expr-arguments n)) (let
          (arg-val-bndg (@ expr-binding-aug t)) (do
        [prepend (make-instrN (x86-mov)
          ([make-mem-op(word-size)dest-reg(none)#0 $dest-offset #4 ..][bndg->op arg-val-bndg relocs ..][make-reg-op(r11)..]) ..) c ..]
        [set+ dest-offset (word-size)]))))))

(constrain generate-load-continuation
  (\ r (with-vars (a) (`(function (register (ref (list instr)) (ref (list reloc)) buffer ,a) ())r)r)))

(function generate-load-continuation (src-reg c relocs r handler)
  (substitute (.. r handler) (do
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbx) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbx)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r12) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r12)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r13) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r13)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r14) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r14)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r15) ..] [make-mem-op(word-size)src-reg(none)#0(cont-r15)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r11) ..] [make-mem-op(word-size)src-reg(none)#0(cont-cir)#4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbp) ..] [make-mem-op(word-size)src-reg(none)#0(cont-rbp)#4 ..]) ..) c ..]
    [prepend (make-instrN(x86-jmp)([make-reg-op (r11) ..])..) c ..])))

(constrain generate-jump
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-jump (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-jump-)] (do
      (if (and [= (@ expr-type (@ expr-target n)) (-continuation-)] (not (@ expr-escapes (@ expr-target n))))
        (let (cont (@ expr-target n)) (do
          (foreach (t (@ expr-arguments n)) [generate-expression t c relocs ..])
          (foreach (t (@ expr-arguments n)) (u (@ expr-parameters cont))
            (let (src-bndg (@ expr-binding-aug t)) (dest-bndg u)
              [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
          [prepend [make-label (@ expr-cont-instr-bndg cont) ..] c ..]
          [generate-expression (@ expr-expression cont) c relocs ..]))
      
      (if (let (cont (@ expr-short-circuit n))
          (and [not= cont null-expr] [= (@ expr-type cont) (-with-)] (not (@ expr-escapes (@ expr-target n)))
            (loop enter (current (@ expr-expression cont))
              (if [= n current]
                (true)
              (if (and [= (@ expr-type current) (-jump-)] [= (@ expr-type (@ expr-target current)) (-continuation-)])
                {enter (@ expr-expression (@ expr-target current))}
                (false))))))
        (let (dest-bndg [@car (@ expr-parameters (@ expr-short-circuit n))])
            (src-bndg (@ expr-binding-aug [@car (@ expr-arguments n)])) (do
          [generate-expression [@car (@ expr-arguments n)] c relocs ..]
          [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
      
      (if [not= (@ expr-short-circuit n) null-expr]
        (let (cont-instr-bndg (@ expr-cont-instr-bndg(@ expr-short-circuit n))) (do
          (if [= (@ expr-type(@ expr-target n)) (-continuation-)]
            [generate-expression (@ expr-target n) c relocs ..]
            (ignore))
          (foreach (t (@ expr-arguments n)) [generate-expression t c relocs ..])
          (foreach (t (@ expr-arguments n)) (u (@ expr-parameters(@ expr-short-circuit n)))
            (let (src-bndg (@ expr-binding-aug t)) (dest-bndg u)
              [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
          [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 cont-instr-bndg relocs ..]) ..) c ..]))
          
        (let (ref-val-bndg (@ expr-binding-aug (@ expr-target n))) (do
          (foreach (t (@ expr-arguments n)) [generate-expression t c relocs ..])
          [generate-expression (@ expr-target n) c relocs ..]
          [generate-register-bndg-move (r10) ref-val-bndg c relocs ..]
          [generate-buffer-to-dest n (r10) (cont-size) c relocs ..]
          [generate-load-continuation (r10) c relocs ..])))))
          
        (true)))))

(constrain initialize-jump (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-jump (n offset inits ret-val)
  (and [= (@ expr-type n) (-jump-)]
    (let (sub-expr-offset [- offset [* [+ [length (@ expr-arguments n)] #1] (word-size)]])
    (let (memory-state [initialize-expression (@ expr-target n) sub-expr-offset inits ret-val])
    (bind (bottom-offset in-use)
      (fold (memory-state memory-state) (u (@ expr-arguments n))
        (bind (bottom-offset in-use) memory-state
        (bind (bottom-offset' in-use') [initialize-expression u sub-expr-offset inits bind]
        (values (use-storage ret-val) [min bottom-offset bottom-offset'] [bor in-use in-use']))))
    (let (in-use [bor in-use (hex FFFFFFFFFFFF0C30)])
    (let (offset [- offset (word-size)])
    (let (in-use [expr-to-register/memory (@ expr-target n) offset in-use])
    (let (offset [- offset [* [length (@ expr-arguments n)] (word-size)]])
    (let (in-use
      (loop assign-args (offset offset) (in-use in-use) (u (@ expr-arguments n))
        (if [nil? u]
          in-use
          {assign-args [+ offset (word-size)]
            [expr-to-register/memory [@car u] offset in-use] [@cdr u]}))) (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-jump])
    (values (use-storage ret-val) bottom-offset in-use)
    (true))))))))))))

(constrain generate-invoke
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-invoke (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-invoke-)] (let
        (expr-val-bndg (@ expr-binding-aug n))
        (ref-expr (@ expr-target n))
        (ref-val-bndg (@ expr-binding-aug (@ expr-target n))) (do
      (ignore If the invoke expression's reference is not an absolute symbol, then put the
        target address into a register and then emit a call on that register.)
      (if (and [= (@ expr-type ref-expr) (-symbol-)] [absolute-reference-symbol? ref-expr])
        (ignore)
        [generate-expression (@ expr-target n) c relocs ..])
      (foreach (t (@ expr-arguments n)) [generate-expression t c relocs ..])
      (foreach (t [reverse (if [> [length (@ expr-arguments n)] #6] [@cddddddr(@ expr-arguments n)] nil) ..])
        (let (src-val-bndg (@ expr-binding-aug t))
          [prepend (make-instrN(x86-push) ([bndg->op src-val-bndg relocs ..]) ..) c ..]))
      
      (and [> [length (@ expr-arguments n)] #0] (do
        [generate-register-bndg-move (rdi) (@ expr-binding-aug [@car(@ expr-arguments n)]) c relocs ..]
      (and [> [length (@ expr-arguments n)] #1] (do
        [generate-register-bndg-move (rsi) (@ expr-binding-aug [@cadr(@ expr-arguments n)]) c relocs ..]
      (and [> [length (@ expr-arguments n)] #2] (do
        [generate-register-bndg-move (rdx) (@ expr-binding-aug [@caddr(@ expr-arguments n)]) c relocs ..]
      (and [> [length (@ expr-arguments n)] #3] (do
        [generate-register-bndg-move (rcx) (@ expr-binding-aug [@cadddr(@ expr-arguments n)]) c relocs ..]
      (and [> [length (@ expr-arguments n)] #4] (do
        [generate-register-bndg-move (r8) (@ expr-binding-aug [@caddddr(@ expr-arguments n)]) c relocs ..]
      (and [> [length (@ expr-arguments n)] #5]
        [generate-register-bndg-move (r9) (@ expr-binding-aug [@cadddddr(@ expr-arguments n)]) c relocs ..])))))))))))
      
      [prepend (make-instrN(x86-xor)([make-reg-op (rax) ..] [make-reg-op (rax) ..])..) c ..]
      (if (and [= (@ expr-type ref-expr) (-symbol-)] [absolute-reference-symbol? ref-expr])
        (let (ref-sym-bndg (@ expr-reference ref-expr))
          [prepend (make-instrN(x86-call)([make-relative-relocation-immediate #4 ref-sym-bndg relocs ..])..) c ..])
        [prepend (make-instrN(x86-call)([bndg->op ref-val-bndg relocs ..])..) c ..])
      [generate-bndg-register-move expr-val-bndg (rax) c relocs ..]
      
      (if [> [length (@ expr-arguments n)] #6]
        (let (drop [*(word-size)[-[length(@ expr-arguments n)]#6]])
          [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #4 drop ..])..) c ..])
        (ignore))
      (true))))))

(constrain initialize-invoke (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-invoke (n offset inits ret-val)
  (and [= (@ expr-type n) (-invoke-)]
    (bind (bottom-offset in-use)
      (let (sub-expr-offset [- offset [* [+ [length (@ expr-arguments n)] #1] (word-size)]])
      (let (memory-state [initialize-expression (@ expr-target n) sub-expr-offset inits bind])
      (fold (memory-state memory-state) (u (@ expr-arguments n))
        (bind (bottom-offset in-use) memory-state
        (bind (bottom-offset' in-use') [initialize-expression u sub-expr-offset inits bind]
        (values storage [min bottom-offset bottom-offset'] [bor in-use in-use']))))))
    
    (let (in-use [bor in-use (hex FFFFFFFFFFFF0031)])
    (let (arg-offset [- offset [* [+[length (@ expr-arguments n)]#1] (word-size)]])
    (let
      (in-use (if [< [length (@ expr-arguments n)] #1] in-use
        (let (arg1 [@car (@ expr-arguments n)])
        (let (arg1-binding (@ expr-binding-aug arg1))
        (bind (arg1-success? in-use) [try-binding-to-register arg1-binding (rdi) in-use bind]
          (where (if arg1-success? in-use [expr-to-register/memory arg1 [+ arg-offset [*(word-size)#0]] in-use])
      (in-use (if [< [length (@ expr-arguments n)] #2] in-use
        (let (arg2 [@cadr (@ expr-arguments n)])
        (let (arg2-binding (@ expr-binding-aug arg2))
        (bind (arg2-success? in-use) [try-binding-to-register arg2-binding (rsi) in-use bind]
          (where (if arg2-success? in-use [expr-to-register/memory arg2 [+ arg-offset [*(word-size)#1]] in-use])
      (in-use (if [< [length (@ expr-arguments n)] #3] in-use
        (let (arg3 [@caddr (@ expr-arguments n)])
        (let (arg3-binding (@ expr-binding-aug arg3))
        (bind (arg3-success? in-use) [try-binding-to-register arg3-binding (rdx) in-use bind]
          (where (if arg3-success? in-use [expr-to-register/memory arg3 [+ arg-offset [*(word-size)#2]] in-use])
      (in-use (if [< [length (@ expr-arguments n)] #4] in-use
        (let (arg4 [@cadddr (@ expr-arguments n)])
        (let (arg4-binding (@ expr-binding-aug arg4))
        (bind (arg4-success? in-use) [try-binding-to-register arg4-binding (rcx) in-use bind]
          (where (if arg4-success? in-use [expr-to-register/memory arg4 [+ arg-offset [*(word-size)#3]] in-use])
      (in-use (if [< [length (@ expr-arguments n)] #5] in-use
        (let (arg5 [@caddddr (@ expr-arguments n)])
        (let (arg5-binding (@ expr-binding-aug arg5))
        (bind (arg5-success? in-use) [try-binding-to-register arg5-binding (r8) in-use bind]
          (where (if arg5-success? in-use [expr-to-register/memory arg5 [+ arg-offset [*(word-size)#4]] in-use])
      (in-use (if [< [length (@ expr-arguments n)] #6] in-use
        (let (arg6 [@cadddddr (@ expr-arguments n)])
        (let (arg6-binding (@ expr-binding-aug arg6))
        (bind (arg6-success? in-use) [try-binding-to-register arg6-binding (r9) in-use bind]
          (if arg6-success? in-use [expr-to-register/memory arg6 [+ arg-offset [*(word-size)#5]] in-use]))))))))))))))))))))))))))))))))))))
    
    (let (in-use
      (let (rem-offset [+ arg-offset [* #6 (word-size)]])
      (let (rem-args (if [>= [length (@ expr-arguments n)] #6] [@cddddddr (@ expr-arguments n)] nil))
      (loop assign-args (offset rem-offset) (in-use in-use) (u rem-args)
        (if [nil? u] in-use
          {assign-args [+ offset (word-size)] [expr-to-register/memory [@car u] offset in-use] [@cdr u]})))))
    
    (let (ref-offset [- offset (word-size)])
    (let (in-use [expr-to-register/memory (@ expr-target n) ref-offset in-use]) (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-invoke])
    (values (use-storage ret-val) bottom-offset [bor in-use (hex FFFFFFFFFFFF0FF7)])
    (true)))))))))))

(constrain generate-if
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-if (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-if-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (condition-val-bndg (@ expr-binding-aug (@ expr-condition n)))
          (consequent-val-bndg (@ expr-binding-aug (@ expr-consequent n)))
          (alternate-val-bndg (@ expr-binding-aug (@ expr-alternate n)))
          (alternate-instr-bndg [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..])
          (end-instr-binding [make-binding-aug (absolute-storage) (local-scope) (defined-state) null-string null-frag null-expr ..]) (do
        [generate-expression (@ expr-condition n) c relocs ..]
        [prepend (make-instrN(x86-or)([bndg->op condition-val-bndg relocs ..][bndg->op condition-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
        [prepend (make-instrN (x86-je) ([make-relative-relocation-immediate #4 alternate-instr-bndg relocs ..]) ..) c ..]
        [generate-expression (@ expr-consequent n) c relocs ..]
        [generate-bndg-bndg-move expr-val-bndg consequent-val-bndg (r11) c relocs ..]
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label alternate-instr-bndg ..] c ..]
        [generate-expression (@ expr-alternate n) c relocs ..]
        [generate-bndg-bndg-move expr-val-bndg alternate-val-bndg (r11) c relocs ..]
        [prepend [make-label end-instr-binding ..] c ..]
        (true))))))

(constrain initialize-if (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-if (n offset inits ret-val)
  (and [= (@ expr-type n) (-if-)] (do
    (setf expr-binding-aug (@ expr-condition n) (@ expr-binding-aug n))
    (setf expr-binding-aug (@ expr-consequent n) (@ expr-binding-aug n))
    (setf expr-binding-aug (@ expr-alternate n) (@ expr-binding-aug n))
    (bind (bottom-offset in-use) [initialize-expression (@ expr-condition n) offset inits bind]
    (bind (bottom-offset' in-use') [initialize-expression (@ expr-consequent n) offset inits bind]
    (bind (bottom-offset'' in-use'') [initialize-expression (@ expr-alternate n) offset inits bind]
    (let (in-use [bor in-use [bor in-use' [bor in-use'' (hex FFFFFFFFFFFF0830)]]]) (do
    (setf expr-generator n [function->generator generate-if])
    (values (use-storage ret-val)
      [min bottom-offset [min bottom-offset' bottom-offset'']] in-use)
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (true)))))))))

(constrain generate-constrain
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-constrain (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-constrain-)]
      (let
          (expr-val-bndg (@ expr-binding-aug n))
          (body-val-bndg (@ expr-binding-aug (@ expr-expression n))) (do
        [generate-expression (@ expr-expression n) c relocs ..]
        [generate-bndg-bndg-move expr-val-bndg body-val-bndg (r11) c relocs ..]
        (true))))))

(constrain initialize-constrain (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-constrain (n offset inits ret-val)
  (and [= (@ expr-type n) (-constrain-)]
    (let (offset [- offset (word-size)])
    (bind (bottom-offset in-use) [initialize-expression (@ expr-expression n) offset inits ret-val]
    (let (in-use
      [expr-to-register/memory (@ expr-expression n) offset [bor in-use (hex FFFFFFFFFFFF0830)]]) (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-constrain])
    (values (use-storage ret-val) bottom-offset in-use)
    (true)))))))

(ignore
  Checks if a symbol is a value symbol, that is, a symbol that is bound to a function/
  continuation parameter.)

(constrain value-symbol? (\ r (with-vars (a) (`(function (expr) ,a)r)r)))

(function value-symbol? (n)
  (let (symbol-val-bndg (@ expr-reference n))
  (let (target-expr (@ bndg-expression symbol-val-bndg))
  (and (or [= (@ expr-type target-expr) (-function-)] [= (@ expr-type target-expr) (-continuation-)])
    [contains symbol-val-bndg (@ expr-parameters target-expr)]))))

(ignore
  Checks if a symbol is a reference symbol. A reference symbol is a symbol that is not
  a value symbol.)

(constrain reference-symbol? (\ r (with-vars (a) (`(function (expr) ,a)r)r)))

(function reference-symbol? (n) (not [value-symbol? n]))

(ignore
  Checks if a symbol is a reference symbol that is bound to an absolute location in
  memory.)

(constrain absolute-reference-symbol? (\ r (with-vars (a) (`(function (expr) ,a)r)r)))

(function absolute-reference-symbol? (n)
  (and [reference-symbol? n] [= (@ bndg-storage (@ expr-reference n)) (absolute-storage)]))

(constrain generate-symbol
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-symbol (n c relocs r handler)
  (substitute (.. r handler)
    (and [= (@ expr-type n) (-symbol-)]
      (let (expr-val-bndg (@ expr-binding-aug n))
          (symbol-val-bndg (@ expr-reference n)) (do
        (if [value-symbol? n]
          [generate-bndg-bndg-move expr-val-bndg symbol-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-lea)
            ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r11)..])..) c ..])
        (true))))))

(constrain initialize-symbol (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-symbol (n offset inits ret-val)
  (and [= (@ expr-type n) (-symbol-)] (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-symbol])
    (values (use-storage ret-val) offset (hex 0000000000000800))
    (true))))

(constrain generate-literal
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-literal (n c relocs r handler) (substitute (.. r handler)
  (and [= (@ expr-type n) (-literal-)]
    (let (expr-val-bndg (@ expr-binding-aug n)) (do
      [prepend(make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][make-imm-op #8 (@ expr-value n)..][make-reg-op (r11)..])..) c ..]
      (true))))))

(constrain initialize-literal (\ r (with-vars (b c) (`(function (expr ,b (list initializer) (values ,b reg-use-vec)) ,c)r)r)))

(function initialize-literal (n offset inits ret-val)
  (and [= (@ expr-type n) (-literal-)] (do
    (setf bndg-size (@ expr-binding-aug n) (word-size))
    (setf expr-generator n [function->generator generate-literal])
    (values (use-storage ret-val) offset (hex 0000000000000800))
    (true))))

(constrain initialize-expression (\ r (with-vars (b c) (`(function (expr ,b (list initializer) ,c) (values ,b reg-use-vec))r)r)))

(function initialize-expression (n offset inits ret-val) (do (or
  (fold (found? (false)) (init inits) (or found? [[initializer->function init] n offset inits ret-val]))
  [initialize-function n offset inits ret-val]
  [initialize-continuation n offset inits ret-val]
  [initialize-with n offset inits ret-val]
  [initialize-storage n offset inits ret-val]
  [initialize-jump n offset inits ret-val]
  [initialize-invoke n offset inits ret-val]
  [initialize-if n offset inits ret-val]
  [initialize-constrain n offset inits ret-val]
  [initialize-symbol n offset inits ret-val]
  [initialize-literal n offset inits ret-val])
  ret-val))

(constrain generator->function
  (\ r (with-vars (a b) (`(function (generator)
    (function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b))r)r)))

(function generator->function (x) [cast x])

(constrain function->generator
  (\ r (with-vars (a b) (`(function
    ((function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)) generator)r)r)))

(function function->generator (x) [cast x])

(constrain make-absolute-relocation-immediate
  (\ r (with-vars (a b c) (`(function (,a ,b bndg-aug (ref (list reloc)) buffer ,c) operand)r)r)))

(function make-absolute-relocation-immediate (size addend bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-8))
          (#2 (r-x86-64-16))
          (#4 (r-x86-64-32))
          (#8 (r-x86-64-64))
          (ignore)) op bndg addend
        (function _(ctx ofst size instr-pos instr-size) ctx) ..] relocs ..]
      op))))

(constrain make-relative-relocation-immediate
  (\ r (with-vars (a b) (`(function (,a bndg-aug (ref (list reloc)) buffer ,b) operand)r)r)))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (substitute (.. r handler)
    (let (op [make-imm-op size #0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#1 (r-x86-64-pc8))
          (#2 (r-x86-64-pc16))
          (#4 (r-x86-64-pc32))
          (#8 (r-x86-64-pc64))
          (ignore)) op bndg (ignore)
        (function _(ctx ofst size instr-pos instr-size)
          [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
      op))))

(constrain make-label (\ r (with-vars (a) (`(function (bndg-aug buffer ,a) instr)r)r)))

(function make-label (bndg r handler)
  (substitute (.. r handler)
    (let (lbl (make-instrN (label) () ..)) (do
      (setf instr-binding lbl bndg)
      lbl))))

(constrain bndg->partial-op (\ r (with-vars (a b) (`(function (,b bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->partial-op (op-size bndg relocs buf handler)
  (substitute (.. buf handler)
    (if [= (@ bndg-storage bndg) (absolute-storage)]
      (let (op [make-mem-op op-size (rip) (none) #0 #0 #4 ..]) (do
        [prepend [make-relocation (r-x86-64-pc32) op bndg (ignore)
          (function _(ctx ofst size instr-pos instr-size)
            [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
        op))
    
    (if (and [= (@ bndg-storage bndg) (frame-relative-storage)] [= (@ bndg-state bndg) (defined-state)])
      [make-mem-op op-size (rbp) (none) #0 (@ bndg-offset bndg) #4 ..]
    
    (if [= (@ bndg-storage bndg) (register-storage)]
      [make-reg-op
        [(switch = op-size
          (#1 reg-lower-8)
          (#2 reg-lower-16)
          (#4 reg-lower-32)
          (#8 reg-lower-64)
          (ignore)) (@ bndg-offset bndg)] ..]
    
      (ignore))))))

(constrain bndg->op (\ r (with-vars (a) (`(function (bndg-aug (ref (list reloc)) buffer ,a) operand)r)r)))

(function bndg->op (bndg relocs buf handler)
  [bndg->partial-op (@ bndg-size bndg) bndg relocs buf handler])

(constrain generate-bndg-bndg-move
  (\ r (with-vars (a b) (`(function (bndg-aug bndg-aug register (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-bndg-bndg-move (dst src tmp c relocs r handler)
  (substitute (.. r handler)
    (if (and [= (@ bndg-storage dst) (@ bndg-storage src)]
        [= (@ bndg-offset dst) (@ bndg-offset src)]
        [= (@ bndg-size dst) (@ bndg-size src)])
      (ignore)
      [prepend (make-instrN(x86-mov)([bndg->op dst relocs ..][bndg->op src relocs ..][make-reg-op tmp ..])..) c ..])))

(constrain generate-register-bndg-move
  (\ r (with-vars (a b) (`(function (register bndg-aug (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-register-bndg-move (dst src c relocs r handler)
  (substitute (.. r handler)
    (if (and [= (@ bndg-storage src) (register-storage)] [= dst (@ bndg-offset src)])
      (ignore)
      [prepend (make-instrN(x86-mov)([make-reg-op dst ..][bndg->op src relocs ..])..) c ..])))

(constrain generate-bndg-register-move
  (\ r (with-vars (a b) (`(function (bndg-aug register (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-bndg-register-move (dst src c relocs r handler)
  (substitute (.. r handler)
    (if (and [= (@ bndg-storage dst) (register-storage)] [= src (@ bndg-offset dst)])
      (ignore)
      [prepend (make-instrN(x86-mov)([bndg->op dst relocs ..][make-reg-op src ..])..) c ..])))

(constrain generate-expression
  (\ r (with-vars (a b) (`(function (expr (ref (list instr)) (ref (list reloc)) buffer ,a) ,b)r)r)))

(function generate-expression (n c relocs r handler)
  (substitute (.. r handler)
    [[generator->function (@ expr-generator n)] n c relocs ..]))

(constrain generate-program
  (\ r (with-vars (a b) (`(function ((list expr) ,b buffer ,a) (values (list instr) (list reloc)))r)r)))

(function generate-program (exprs outs r handler)
  (substitute (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (do
    [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
    [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
    (foreach (expr exprs) [generate-expression expr c relocs ..])
    [prepend (make-instrN(x86-leave)()..) c ..]
    [prepend (make-instrN(x86-ret)()..) c ..]
    (values (use-storage outs) [reverse $c ..] $relocs)))))

