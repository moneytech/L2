(;; Takes two lists of the same length and produces a list of pairs of which the
  first element comes from the first list and the second element comes from the
  second list. a is the list from which the first elements of the zip will
  come from. b is the list from which the second elements of the zip will come
  from.)

(function meta:zip (a b r) (with return
  {(continuation aux (output a b)
    (if (not [emt? a])
      {aux [lst [llst [@fst a] [@fst b] emt r] output r] [@rst a] [@rst b]}
      {return [meta:reverse output r]})) emt a b}))

(;; A zipped foreach macro. The syntax is as follows:
  (foreach (v1 l1) (v2 l2) ... (vN lN) expr) where l1, l2, ..., lN must have the same size.)

(function foreach (s r)
  (let (bindings [meta:reverse [@rst [meta:reverse s r]] r]) (body [@fst [meta:reverse s r]])
  (let (labels [meta:label bindings (` foreach:v r) r])
    (`(with foreach:return (,[llst (` jump r)
      [llllst (` continuation r) (` foreach:loop r) labels
        (`(if (not [nil? foreach:v])
          (,[lllst (` do r)
            [lst (` let r) [meta:reverse [lst body [meta:map2 [meta:zip [meta:map bindings @fst r] labels r]
                r (function make-binding (a r) (`((,[@fst a]) [@car (,[@frst a])])r))r]r]r]r]
            [llst (` jump r) (` foreach:loop r) [meta:map2 labels r (function make-update (a r) (`[@cdr ,a]r))r] r] emt r])
          {foreach:return (undefined)})r) emt r] [meta:map bindings @frst r]r]))r))))

(;; Like a C-array initializer, but for lists. Does the following transformation:
  (list (expr1 expr2 ... exprN) r handler)
  ->
  [cons expr1 [cons expr2 [... [cons exprN nil r handler] ...] r handler] r handler])

(function list (l r)
  (loop add-item (out (` nil r)) (in [meta:reverse [@fst l] r])
    (if [emt? in]
      out
      {add-item [llllst (` invoke r) (` cons r) [@fst in] out [@rst l] r] [@rst in]})))

(;; A macro to do a reverse map. Does the following transformation:
  (reverse-map (x l) expr ctx ...)
  ->
  (with reverse-map:return
    {(continuation reverse-map:loop (reverse-map:l reverse-map:acc)
      (if [nil? reverse-map:l]
        {reverse-map:return reverse-map:acc}
        {reverse-map:loop
          [@cdr reverse-map:l]
          [cons (let (x [@car reverse-map:l]) expr) reverse-map:acc ctx ...]})) l nil}))

(function reverse-map (l r)
  (`(with reverse-map:return
    {(continuation reverse-map:loop (reverse-map:l reverse-map:acc)
      (if [nil? reverse-map:l]
        {reverse-map:return reverse-map:acc}
        {reverse-map:loop
          [@cdr reverse-map:l]
          (,[llllst (` invoke r) (` cons r) (`(let ((,[@ffst l]) [@car reverse-map:l]) (,[@frst l]))r) (` reverse-map:acc r)
            [@rrst l] r])})) (,[@frfst l]) nil})r))

(;; A macro to do a reverse filter. Does the following transformation:
  (reverse-filter (x l) expr ctx ...)
  ->
  (with reverse-filter:return
    {(continuation reverse-filter:loop (reverse-filter:l reverse-filter:acc)
      (if [nil? reverse-filter:l]
        {reverse-filter:return reverse-filter:acc}
        {reverse-filter:loop
          [@cdr reverse-filter:l]
          (if (let (x [@car reverse-filter:l]) expr)
            [cons [@car reverse-filter:l] reverse-filter:acc ctx ...]
            reverse-filter:acc)})) l nil}))

(function reverse-filter (l r)
  (`(with reverse-filter:return
    {(continuation reverse-filter:loop (reverse-filter:l reverse-filter:acc)
      (if [nil? reverse-filter:l]
        {reverse-filter:return reverse-filter:acc}
        {reverse-filter:loop
          [@cdr reverse-filter:l]
          (if (let ((,[@ffst l]) [@car reverse-filter:l]) (,[@frst l]))
            (,[llllst (` invoke r) (` cons r) (`[@car reverse-filter:l]r) (` reverse-filter:acc r) [@rrst l] r])
            reverse-filter:acc)})) (,[@frfst l]) nil})r))

(;; A macro to do a reverse map. Does the following transformation:
  (fold (y acc) (x l) expr)
  ->
  (with fold:return
    {(continuation fold:loop (fold:acc fold:l)
      (if [nil? fold:l]
        {fold:return fold:acc}
        {fold:loop
          (let (y fold:acc) (x [@car fold:l]) expr)
          [@cdr fold:l]})) acc l}))

(function fold (l r)
  (`(with fold:return
    {(continuation fold:loop (fold:acc fold:l)
      (if [nil? fold:l]
        {fold:return fold:acc}
        {fold:loop
          (let ((,[@ffst l]) fold:acc) ((,[@ffrst l]) [@car fold:l]) (,[@frrst l]))
          [@cdr fold:l]})) (,[@frfst l]) (,[@frfrst l])})r))

(;; A macro to do a find. Does the following transformation:
  (find (x l) expr)
  ->
  (with find:return
    {(continuation find:loop (find:l)
      (if [nil? find:l]
        {find:return nil}
        (if (let (x [@car find:l]) expr)
          {find:return find:l}
          {find:loop [@cdr find:l]}))) l}))

(function find (l r)
  (`(with find:return
    {(continuation find:loop (find:l)
      (if [nil? find:l]
        {find:return nil}
        (if (let ((,[@ffst l]) [@car find:l]) (,[@frst l]))
          {find:return find:l}
          {find:loop [@cdr find:l]}))) (,[@frfst l])})r))

(function list-struct (l r) [mk# r #16])

(function car (l r) [property #0 8b (\(r) (with-vars (a) (`(list ,a)r)r)) (\(s r) [@frst s]) l r])

(function cdr (l r) [property #8 8b (\(r) (with-vars (a) (`(list ,a)r)r)) (\(s r) s) l r])

(;; Convenience functions for accessing elements of program internal lists.
  Note that the @fst and @rst functions are list accessor functions only for
  the fragments supplied to macros.)

(function @car (l) (@ car l))

(function @cdr (l) (@ cdr l))

(function @cddr (l) [@cdr [@cdr l]])

(function @cdddr (l) [@cdr [@cddr l]])

(function @cddddr (l) [@cdr [@cdddr l]])

(function @cdddddr (l) [@cdr [@cddddr l]])

(function @cddddddr (l) [@cdr [@cdddddr l]])

(function @cadr (l) [@car [@cdr l]])

(function @caddr (l) [@car [@cddr l]])

(function @cadddr (l) [@car [@cdddr l]])

(function @caddddr (l) [@car [@cddddr l]])

(function @cadddddr (l) [@car [@cdddddr l]])

(constrain nil (\(r) (with-vars (et) (`(list ,et)r)r)))

(storage nil nil nil)

(constrain nil? (\(r) (with-vars (a b) (`(function ((list ,a)) ,b)r)r)))

(function nil? (l) [= l nil])

(;; Appends an item to the given list. data is the data that is to be appended.
  l is a reference to the list that is to be appended to. r is the buffer into
  which the extension is being placed.)

(constrain append (\(r) (with-vars (et b) (`(function (,et (ref (list ,et)) buffer ,b) (ref ,et))r)r)))

(function append (data l r handler)
  (loop next (l l)
    (if (not [nil? $l])
      {next (& cdr $l)}
      (do
        [set l [buffer-alloc (list-struct) r handler]]
        (setf car $l data)
        (setf cdr $l nil)
        (& car $l)))))

(;; Makes a new list with the given head and tail. data is what is going to be
  put at the head. rest is the list that will be the tail of the new list. r
  is the buffer into which the extension is being placed. Return value is the
  new list.)

(constrain cons (\(r) (with-vars (et a) (`(function (,et (list ,et) buffer ,a) (list ,et))r)r)))

(function cons (data rest r handler)
  (let (l [buffer-alloc (list-struct) r handler]) (do
    (setf car l data)
    (setf cdr l rest)
    l)))

(;; Appends the second list onto the first list. fst-ref is a reference to the
  list that will be appended to. snd is the list that will be appended.)

(constrain append-list (\(r) (with-vars (et) (`(function ((ref (list ,et)) (list ,et)) ())r)r)))

(function append-list (fst-ref snd)
  (loop next (fst-ref fst-ref)
    (if [nil? $fst-ref]
      [set fst-ref snd]
      {next (& cdr $fst-ref)})))

(;; Analogous to append above.)

(constrain prepend (\(r) (with-vars (et a) (`(function (,et (ref (list ,et)) buffer ,a) ())r)r)))

(function prepend (data l-ref r handler)
  (let (ret [buffer-alloc (list-struct) r handler]) (do
    (setf car ret data)
    (setf cdr ret $l-ref)
    [set l-ref ret])))

(;; Computes the length of the given list. l is the list whose length will be
  computed.)

(constrain length (\(r) (with-vars (et nt) (`(function ((list ,et)) ,nt)r)r)))

(function length (l)
  (loop next (l l) (size #0)
    (if [nil? l]
      size
      {next [@cdr l] [+ #1 size]})))

(;; Constructs a reverse of the given list. l is the list that is to be reversed.
  r is the buffer into which the reversed list should be placed. Return value
  is the reversed list.)

(constrain reverse (\(r) (with-vars (et a) (`(function ((list ,et) buffer ,a) (list ,et))r)r)))

(function reverse (l r handler) (reverse-map (x l) x r handler))

