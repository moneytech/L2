(ignore The constants to be used in x86-64-assembler.l2)

(function instr-mod (l r) [=# #6 r])

(function instr-reg (l r) [=# #3 r])

(function instr-rm (l r) [=# #0 r])

(function instr-base (l r) [=# #0 r])

(function instr-index (l r) [=# #3 r])

(function instr-ss (l r) [=# #6 r])

(function rex-w (l r) [=# #3 r])

(function rex-r (l r) [=# #2 r])

(function rex-x (l r) [=# #1 r])

(function rex-b (l r) [=# #0 r])

(function write-elf-sh-count (l r) [=# #7 r])

(function write-elf-alignment (l r) [=# #8 r])

(function write-elf-max-instr-len (l r) [=# #15 r])

(function write-elf-max-instr-fields (l r) [=# #2 r])

(constrain mem-write (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function mem-write (mem idx bytes cnt)
  (let (end [+ $idx cnt])
  (loop write-bytes (bytes bytes)
    (if [= $idx end] (ignore) (do
      [setb [+ mem $idx] [getb bytes]]
      [set+ idx #1]
      {write-bytes [+ bytes #1]})))))

(constrain write-mr-instr (\ r (with-vars (a b c d e f g) (`(function (,a (ref ,b) ,c ,d ,e ,f ,g) ())r)r)))

(function write-mr-instr (bin pos opcode reg rm m rexw)
  (let (mod (if m #2 #3))
  (let (modrm [lor [<< mod (instr-mod)] [lor [<< [land reg (hex 7)] (instr-reg)] [<< [land rm (hex 7)] (instr-rm)]]])
  (let (has-sib (and m (or [= rm (rsp)] [= rm (r12)])))
  (let (sib (if has-sib [lor [<< #4 (instr-index)] [lor [<< [land rm (hex 7)] (instr-base)] [<< #0 (instr-ss)]]] (ignore)))
  (let (rex [<< #4 #4])
  (let (rex (if rexw [lor rex [<< #1 (rex-w)]] rex))
  (let (rex (if [land reg (hex 8)] [lor rex [<< #1 (rex-r)]] rex))
  (let (rex [lor rex [<< #0 (rex-x)]])
  (let (rex (if [land rm (hex 8)] [lor rex [<< #1 (rex-b)]] rex)) (do
  [mem-write bin pos (storage _ rex) #1]
  [mem-write bin pos (storage _ opcode) #1]
  [mem-write bin pos (storage _ modrm) #1]
  (if has-sib [mem-write bin pos (storage _ sib) #1] (ignore)))))))))))))

(constrain write-static-value (\ r (with-vars (a b c d e f) (`(function (,a (ref ,b) ,c ,d ,e ,f) ())r)r)))

(function write-static-value (bin pos expr bytes symtab relas)
  (if [= (@ expr-type expr) (-literal-)]
    [mem-write bin pos (storage _(@ expr-value expr)) bytes]
    
  (if (and [= (@ expr-type expr) (-symbol-)] [= bytes #8]) (do
    (setf r-offset $relas $pos)
    (setf r-info $relas (elf64-r-info [/[- (@ bndg-context(@ expr-binding-aug expr)) symtab](elf64-sym)] (r-x86-64-64)))
    (setf r-addend $relas #0)
    [set+ relas (elf64-rela)]
    [mem-write bin pos (storage _ #0) bytes])
    
  (if (and [= (@ expr-type expr) (-assembly-)] [= (@ expr-code expr) (lnkr-add-off-to-ref)] [= bytes #8])
    (let (ref [@car(@ expr-arguments expr)])
    (let (offset [@cadr(@ expr-arguments expr)]) (do
    (setf r-offset $relas $pos)
    (setf r-info $relas (elf64-r-info [/[- (@ bndg-context(@ expr-binding-aug ref)) symtab](elf64-sym)] (r-x86-64-64)))
    (setf r-addend $relas (@ expr-value offset))
    [set+ relas (elf64-rela)]
    [mem-write bin pos (storage _ #0) bytes])))
    
  (if (and [= (@ expr-type expr) (-assembly-)] [= (@ expr-code expr) (lnkr-sub-rip-to-ref)] [= bytes #4])
    (let (ref [@car(@ expr-arguments expr)]) (do
    (setf r-offset $relas $pos)
    (setf r-info $relas (elf64-r-info [/[- (@ bndg-context(@ expr-binding-aug ref)) symtab](elf64-sym)] (r-x86-64-pc32)))
    (setf r-addend $relas [- #0 bytes])
    [set+ relas (elf64-rela)]
    [mem-write bin pos (storage _ #0) bytes]))
    
    (ignore))))))

(constrain write-o-instr (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function write-o-instr (bin pos opcode reg)
  (let (rd [land (hex 7) reg])
  (let (opcoderd [+ opcode rd])
  (let (rex [<< #4 #4])
  (let (rex [lor rex [<< #0 (rex-w)]])
  (let (rex [lor rex [<< #0 (rex-r)]])
  (let (rex [lor rex [<< #0 (rex-x)]]) (do
  (if [land reg (hex 8)]
    (let (rex [lor rex [<< #1 (rex-b)]]) [mem-write bin pos (storage _ rex) #1])
    (ignore))
  [mem-write bin pos (storage _ opcoderd) #1]))))))))

(constrain assemble (\ r (with-vars (a b c d) (`(function ((list expr) ,a (ref ,b) ,c ,d) ())r)r)))

(function assemble (generated-expressions bin pos symtab relas) (do
  [set pos #0]
  (foreach (n generated-expressions)
    (switch = (@ expr-code n)
      ((label)
        (let (label-ref [@car(@ expr-arguments n)]) (do
        (setf bndg-offset (@ expr-binding-aug label-ref) $pos)
        (setf st-value (@ bndg-context(@ expr-binding-aug label-ref)) $pos))))
        
      ((leaq-mdb-to-reg)
        (let (opcode (hex 8D))
        (let (reg (@ expr-code [@caddr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@cadr (@ expr-arguments n)])) (do
        [write-mr-instr bin pos opcode reg rm (true) (true)]
        [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab relas])))))
        
      ((movq-reg-to-mdb)
        (let (opcode (hex 89))
        (let (reg (@ expr-code [@car (@ expr-arguments n)]))
        (let (rm (@ expr-code [@caddr (@ expr-arguments n)])) (do
        [write-mr-instr bin pos opcode reg rm (true) (true)]
        [write-static-value bin pos [@cadr (@ expr-arguments n)] #4 symtab relas])))))
        
      ((jmp-rel)
        (let (opcode (hex E9)) (do
        [mem-write bin pos (storage _ opcode) #1]
        [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab relas])))
        
      ((movq-mdb-to-reg)
        (let (opcode (hex 8B))
        (let (reg (@ expr-code [@caddr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@cadr (@ expr-arguments n)])) (do
        [write-mr-instr bin pos opcode reg rm (true) (true)]
        [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab relas])))))
        
      ((pushq-reg)
        (let (opcode (hex 50))
        (let (reg (@ expr-code [@car (@ expr-arguments n)]))
        [write-o-instr bin pos opcode reg])))
        
      ((movq-reg-to-reg)
        (let (opcode (hex 8B))
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
        
      ((subq-imm-to-reg)
        (let (opcode (hex 81))
        (let (reg #5)
        (let (rm (@ expr-code [@cadr (@ expr-arguments n)])) (do
        [write-mr-instr bin pos opcode reg rm (false) (true)]
        [mem-write bin pos (& expr-value [@car (@ expr-arguments n)]) #4])))))
        
      ((addq-imm-to-reg)
        (let (opcode (hex 81))
        (let (reg #0)
        (let (rm (@ expr-code [@cadr (@ expr-arguments n)])) (do
        [write-mr-instr bin pos opcode reg rm (false) (true)]
        [mem-write bin pos (& expr-value [@car (@ expr-arguments n)]) #4])))))
        
      ((popq-reg)
        (let (opcode (hex 58))
        (let (reg (@ expr-code [@car (@ expr-arguments n)]))
        [write-o-instr bin pos opcode reg])))
        
      ((leave) [mem-write bin pos (storage opcode (hex C9)) #1])
        
      ((ret) [mem-write bin pos (storage opcode (hex C3)) #1])
        
      ((jmp-to-reg)
        (let (opcode (hex FF))
        (let (reg #4)
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (false)]))))
        
      ((je-rel) (do
        [mem-write bin pos (storage opcode1 (hex 0F)) #1]
        [mem-write bin pos (storage opcode2 (hex 84)) #1]
        [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab relas]))
        
      ((orq-reg-to-reg)
        (let (opcode (hex 0B))
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((andq-reg-to-reg)
        (let (opcode (hex 23))
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((addq-reg-to-reg)
        (let (opcode (hex 03))
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((subq-reg-to-reg)
        (let (opcode (hex 2B))
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((mulq-reg)
        (let (opcode (hex F7))
        (let (reg (hex 04))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((notq-reg)
        (let (opcode (hex F7))
        (let (reg (hex 02))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((shlq-cl-to-reg)
        (let (opcode (hex D3))
        (let (reg (hex 04))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((shrq-cl-to-reg)
        (let (opcode (hex D3))
        (let (reg (hex 05))
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (true)]))))
      
      ((movq-imm-to-reg)
        (let (opcode (hex B8))
        (let (imm-expr [@car (@ expr-arguments n)])
        (let (reg (@ expr-code [@cadr (@ expr-arguments n)]))
        (let (rd [land (hex 7) reg])
        (let (opcoderd [+ opcode rd])
        (let (rex [<< #4 #4])
        (let (rex [lor rex [<< #1 (rex-w)]])
        (let (rex [lor rex [<< #0 (rex-r)]])
        (let (rex [lor rex [<< #0 (rex-x)]])
        (let (rex (if [land reg (hex 8)] [lor rex [<< #1 (rex-b)]] rex)) (do
        [mem-write bin pos (storage _ rex) #1]
        [mem-write bin pos (storage _ opcoderd) #1]
        [write-static-value bin pos imm-expr #8 symtab relas]))))))))))))
        
      ((call-reg)
        (let (opcode (hex FF))
        (let (reg #2)
        (let (rm (@ expr-code [@car (@ expr-arguments n)]))
        [write-mr-instr bin pos opcode reg rm (false) (false)]))))
      
      (ignore)))))

(storage shstrtab ("(nul).shstrtab(nul).text(nul).strtab(nul).symtab(nul).bss(nul).rela.text(nul)))

(constrain measure-strtab (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-strtab (generated-expressions undefined-bindings static-bindings)
  (let (undefined-bindings-len (fold (acc #0) (sym undefined-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (static-bindings-len (fold (acc #0) (sym static-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (generated-expressions-len (fold (acc #0) (e generated-expressions)
        [+ acc (if [= (@ expr-code e) (label)]
          (let (label-str (@ expr-name [@car (@ expr-arguments e)]))
            (if [not= label-str null-string] [+ [strlen label-str] #1] #0))
          #0)]))
    [+ #1 [+ undefined-bindings-len [+ static-bindings-len generated-expressions-len]]]))

(constrain measure-symtab (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-symtab (generated-expressions undefined-bindings static-bindings)
  (let (generated-expressions-len
        (fold (acc #0) (e generated-expressions) [+ acc (if [= (@ expr-code e) (label)] #1 #0)]))
    [+ #1 [+ generated-expressions-len [+ [length undefined-bindings] [length static-bindings]]]]))

(constrain max-elf-size (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function max-elf-size (generated-expressions undefined-bindings static-bindings)
  [+ (elf64-ehdr) [+ [* (elf64-shdr) (write-elf-sh-count)] [+ [pad-size [strvlen $shstrtab] (write-elf-alignment)]
    [+ [pad-size [* (write-elf-max-instr-len) [length generated-expressions]] (write-elf-alignment)]
    [+ [pad-size [measure-strtab generated-expressions undefined-bindings static-bindings] (write-elf-alignment)]
    [+ [* (elf64-sym) [measure-symtab generated-expressions undefined-bindings static-bindings]]
    [* (elf64-rela) [* (write-elf-max-instr-fields) [length generated-expressions]]]]]]]]])

(ignore
  Takes assembly code and a list of symbols as constructs an object file.
  generated-expressions is a list of assembly expressions. symbols is a list of the static
  symbols used in the assembly expressions. reg is the buffer into which the generated
  object code should be put. Returns a pair containing a reference to the generated object
  code and the size of the generated object code.)

(constrain write-elf (\ r (with-vars (a b c d) (`(function ((list expr) (list bndg-aug) (list bndg-aug) ,a buffer ,c)
  (values ,b ,d))r)r)))

(function write-elf (generated-expressions undefined-bindings static-bindings outs reg handler)
  (let (temp-buf [create-buffer #0 handler])
    (fallthrough
      (do
        (let (pos (storage _ #0))
        (let (bin [buffer-alloc [max-elf-size generated-expressions undefined-bindings static-bindings] reg cleanup])
        
        (let (ehdr [buffer-alloc (elf64-ehdr) temp-buf cleanup]) (do
        (setf ei-mag0 (& e-ident ehdr) (elfmag0))
        (setf ei-mag1 (& e-ident ehdr) (elfmag1))
        (setf ei-mag2 (& e-ident ehdr) (elfmag2))
        (setf ei-mag3 (& e-ident ehdr) (elfmag3))
        (setf ei-class (& e-ident ehdr) (elfclass64))
        (setf ei-data (& e-ident ehdr) (elfdata2lsb))
        (setf ei-version (& e-ident ehdr) #1)
        (setf ei-osabi (& e-ident ehdr) (elfosabi-sysv))
        (setf ei-abiversion (& e-ident ehdr) #0)
    
        (until (i #7) [= i (ei-nident)] [+ i #1] [setb (loc(byte)i(& e-ident ehdr)) #0])
    
        (setf e-type ehdr (et-rel))
        (setf e-machine ehdr (em-x86-64))
        (setf e-version ehdr #1)
        (setf e-entry ehdr #0)
        (setf e-phoff ehdr #0)
        (setf e-shoff ehdr (elf64-ehdr))
        (setf e-flags ehdr #0)
        (setf e-ehsize ehdr (elf64-ehdr))
        (setf e-phentsize ehdr #0)
        (setf e-phnum ehdr #0)
        (setf e-shentsize ehdr (elf64-shdr))
        (setf e-shnum ehdr (write-elf-sh-count))
        (setf e-shstrndx ehdr #1)
        [mem-write bin pos ehdr (elf64-ehdr)]
        
        (let (strtab-len [measure-strtab generated-expressions undefined-bindings static-bindings])
        (let (sym-count [measure-symtab generated-expressions undefined-bindings static-bindings])
    
        (let (syms [buffer-alloc [* sym-count (elf64-sym)] temp-buf cleanup])
        (let (sym-ptr (storage _ syms)) (do
        (ignore Mandatory undefined symbol)
        (setf st-name $sym-ptr #0)
        (setf st-value $sym-ptr #0)
        (setf st-size $sym-ptr #0)
        (setf st-info $sym-ptr #0)
        (setf st-other $sym-ptr #0)
        (setf st-shndx $sym-ptr (shn-undef))
        [set+ sym-ptr (elf64-sym)]
    
        (let (strtab-padded-len [pad-size strtab-len (write-elf-alignment)])
        (let (strtab [buffer-alloc strtab-padded-len temp-buf cleanup])
        (let (strtabptr (storage _ strtab)) (do
        [setb $strtabptr #0]
        [set+ strtabptr #1]
    
        (let (bss-ptr (storage _ #0)) (do
    
        (foreach (sym static-bindings)
          (if [= (@ bndg-scope sym) (local-scope)] (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)]
            [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]])
            (ignore)))
    
        (foreach (e generated-expressions)
          (if (and [= (@ expr-code e) (label)]
              [= (@ bndg-scope(@ expr-binding-aug[@car(@ expr-arguments e)])) (local-scope)])
            (let (ref (storage _ [@car(@ expr-arguments e)])) (do
            (if [not= (@ expr-name $ref) null-string]
              (do
                [strcpy $strtabptr (@ expr-name $ref)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ expr-name $ref)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr #0)
            (setf st-size $sym-ptr #0)
            (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #2)
            (setf bndg-context (@ expr-binding-aug $ref) $sym-ptr)
            [set+ sym-ptr (elf64-sym)]))
            (ignore)))
    
        (let (local-symbol-count [/[- $sym-ptr syms](elf64-sym)]) (do
    
        (foreach (sym static-bindings)
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (defined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)]
            [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]])
            (ignore)))
    
        (foreach (sym undefined-bindings)
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (undefined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr #0)
            (setf st-size $sym-ptr #0)
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr (shn-undef))
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore)))
    
        (foreach (e generated-expressions)
          (if (and [= (@ expr-code e) (label)]
              [= (@ bndg-scope(@ expr-binding-aug[@car(@ expr-arguments e)])) (global-scope)])
            (let (ref (storage _ [@car(@ expr-arguments e)])) (do
            (if [not= (@ expr-name $ref) null-string]
              (do
                [strcpy $strtabptr (@ expr-name $ref)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ expr-name $ref)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr #0)
            (setf st-size $sym-ptr #0)
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #2)
            (setf bndg-context (@ expr-binding-aug $ref) $sym-ptr)
            [set+ sym-ptr (elf64-sym)]))
            (ignore)))
    
        (let (text-len (storage _ (ignore)))
        (let (max-text-sec-len [pad-size [* (write-elf-max-instr-len) [length generated-expressions]] (write-elf-alignment)])
        (let (max-rela-sec-len [* (write-elf-max-instr-fields) [* [length generated-expressions] (elf64-rela)]])
        
        (let (text [buffer-alloc max-text-sec-len temp-buf cleanup])
        (let (relas [buffer-alloc max-rela-sec-len temp-buf cleanup])
        (let (rela-ptr (storage _ relas)) (do
        
        [assemble generated-expressions text text-len syms rela-ptr]
        
        (ignore Mandatory undefined section)
        (let (undef-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name undef-shdr #0)
        (setf sh-type undef-shdr (sht-null))
        (setf sh-flags undef-shdr #0)
        (setf sh-addr undef-shdr #0)
        (setf sh-offset undef-shdr #0)
        (setf sh-size undef-shdr #0)
        (setf sh-link undef-shdr (shn-undef))
        (setf sh-info undef-shdr #0)
        (setf sh-addralign undef-shdr #0)
        (setf sh-entsize undef-shdr #0)
        [mem-write bin pos undef-shdr (elf64-shdr)]
    
        (let (shstrtab-padded-len [pad-size [strvlen $shstrtab] (write-elf-alignment)])
        (let (shstrtab-padded [buffer-alloc shstrtab-padded-len temp-buf cleanup]) (do
        [memcpy shstrtab-padded $shstrtab [strvlen $shstrtab]]
    
        (let (shstrtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name shstrtab-shdr #1)
        (setf sh-type shstrtab-shdr (sht-strtab))
        (setf sh-flags shstrtab-shdr #0)
        (setf sh-addr shstrtab-shdr #0)
        (setf sh-offset shstrtab-shdr [+ (elf64-ehdr) [* (write-elf-sh-count) (elf64-shdr)]])
        (setf sh-size shstrtab-shdr [strvlen $shstrtab])
        (setf sh-link shstrtab-shdr (shn-undef))
        (setf sh-info shstrtab-shdr #0)
        (setf sh-addralign shstrtab-shdr #0)
        (setf sh-entsize shstrtab-shdr #0)
        [mem-write bin pos shstrtab-shdr (elf64-shdr)]
    
        (let (text-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name text-shdr [+ (@ sh-name shstrtab-shdr) [+ [strlen(" .shstrtab)] #1]])
        (setf sh-type text-shdr (sht-progbits))
        (setf sh-flags text-shdr [lor (shf-alloc) (shf-execinstr)])
        (setf sh-addr text-shdr #0)
        (setf sh-offset text-shdr [+ (@ sh-offset shstrtab-shdr) shstrtab-padded-len])
        (setf sh-size text-shdr $text-len)
        (setf sh-link text-shdr (shn-undef))
        (setf sh-info text-shdr #0)
        (setf sh-addralign text-shdr #1)
        (setf sh-entsize text-shdr #0)
        [mem-write bin pos text-shdr (elf64-shdr)]
    
        (let (strtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name strtab-shdr [+ (@ sh-name text-shdr) [+ [strlen(" .text)] #1]])
        (setf sh-type strtab-shdr (sht-strtab))
        (setf sh-flags strtab-shdr #0)
        (setf sh-addr strtab-shdr #0)
        (setf sh-offset strtab-shdr [+ (@ sh-offset text-shdr) max-text-sec-len])
        (setf sh-size strtab-shdr strtab-len)
        (setf sh-link strtab-shdr (shn-undef))
        (setf sh-info strtab-shdr #0)
        (setf sh-addralign strtab-shdr #0)
        (setf sh-entsize strtab-shdr #0)
        [mem-write bin pos strtab-shdr (elf64-shdr)]
    
        (let (symtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name symtab-shdr [+ (@ sh-name strtab-shdr) [+ [strlen(" .strtab)] #1]])
        (setf sh-type symtab-shdr (sht-symtab))
        (setf sh-flags symtab-shdr #0)
        (setf sh-addr symtab-shdr #0)
        (setf sh-offset symtab-shdr [+ (@ sh-offset strtab-shdr) strtab-padded-len])
        (setf sh-size symtab-shdr [* sym-count (elf64-sym)])
        (setf sh-link symtab-shdr #3)
        (setf sh-info symtab-shdr local-symbol-count)
        (setf sh-addralign symtab-shdr #0)
        (setf sh-entsize symtab-shdr (elf64-sym))
        [mem-write bin pos symtab-shdr (elf64-shdr)]
    
        (let (bss-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name bss-shdr [+ (@ sh-name symtab-shdr) [+ [strlen(" .symtab)] #1]])
        (setf sh-type bss-shdr (sht-nobits))
        (setf sh-flags bss-shdr [lor (shf-write) (shf-alloc)])
        (setf sh-addr bss-shdr #0)
        (setf sh-offset bss-shdr [+ (@ sh-offset symtab-shdr) (@ sh-size symtab-shdr)])
        (setf sh-size bss-shdr $bss-ptr)
        (setf sh-link bss-shdr (shn-undef))
        (setf sh-info bss-shdr #0)
        (setf sh-addralign bss-shdr (word-size))
        (setf sh-entsize bss-shdr #0)
        [mem-write bin pos bss-shdr (elf64-shdr)]
    
        (let (rela-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name rela-shdr [+ (@ sh-name bss-shdr) [+ [strlen(" .bss)] #1]])
        (setf sh-type rela-shdr (sht-rela))
        (setf sh-flags rela-shdr #0)
        (setf sh-addr rela-shdr #0)
        (setf sh-offset rela-shdr [+ (@ sh-offset bss-shdr) #0])
        (setf sh-size rela-shdr [- $rela-ptr relas])
        (setf sh-link rela-shdr #4)
        (setf sh-info rela-shdr #2)
        (setf sh-addralign rela-shdr #0)
        (setf sh-entsize rela-shdr (elf64-rela))
        [mem-write bin pos rela-shdr (elf64-shdr)]
    
        [mem-write bin pos shstrtab-padded shstrtab-padded-len]
        [mem-write bin pos text max-text-sec-len]
        [mem-write bin pos strtab strtab-padded-len]
        [mem-write bin pos syms [* sym-count (elf64-sym)]]
        [mem-write bin pos relas [- $rela-ptr relas]]
        
        (storage _ no-error bin $pos)))))))))))))))))))))))))))))))))))))))))))
        
      (cleanup err (do [destroy-buffer temp-buf return-cont] err))
      
      (return-cont err (if [= (@0 err) no-error] (values (use-storage outs) (@1 err) (@2 err)) {handler err})))))

(ignore
  Converts the offsets of the static bindings associated with L2 source code that has now
  been loaded into addresses. asms is a list of assembly expressions containing bindings
  that need to be converted. bindings is a list of augmented bindings corresponding to the
  assembly expressions that also need to be converted.)

(constrain binding-offsets-to-addresses (\ r (`(function ((list expr) (list bndg-aug) obj) ())r)))

(function binding-offsets-to-addresses (asms static-bindings obj) (do
  (foreach (sym static-bindings)
    (if (and [= (@ bndg-storage sym) (absolute-storage)] [= (@ bndg-state sym) (defined-state)])
      (setf bndg-offset sym [+ (@ bndg-offset sym) [segment obj (" .bss)]])
      (ignore)))
  
  (foreach (l asms)
    (if [= (@ expr-code l) (label)]
      (let (sym (@ expr-binding-aug[@car(@ expr-arguments l)]))
        (setf bndg-offset sym [+ (@ bndg-offset sym) [segment obj (" .text)]]))
      (ignore)))))

