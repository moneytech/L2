(ignore The constants to be used in x86-64-assembler.l2)

(function write-elf-sh-count (l r) [=# #7 r])

(function write-elf-alignment (l r) [=# #8 r])

(function write-elf-max-instr-len (l r) [=# #15 r])

(function write-elf-max-instr-fields (l r) [=# #2 r])

(ignore A representation of an object code relocation.)

  (function relocation (l r) [=# #40 r])

  (function reloc-type (l r) [property #0 #8 (\ r (` reloc r)) (\ s r (` reloc-type r)) l r])

  (function reloc-operand (l r) [property #8 #8 (\ r (` reloc r)) (\ s r (` operand r)) l r])

  (function reloc-binding (l r) [property #16 #8 (\ r (` reloc r)) (\ s r (` bndg-aug r)) l r])
  
  (function reloc-context (l r) [property #24 #8 (\ r (` reloc r)) (\ s r [var r]) l r])
  
  (ignore
    reloc-addend-func takes as its arguments context, operand location, operand size,
    instruction location, instruction size, and computes an addend for the relocation.)
    
  (function reloc-addend-func (l r)
    [property #32 #8 (\ r (` reloc r)) (\ s r (with-vars (a b c d e f) (`(function (,f ,b ,c ,d ,e) ,a)r)r)) l r])

(ignore A representation of an instruction.)

  (function instruction (l r) [=# #24 r])

  (function instr-code (l r) [property #0 #8 (\ r (` instr r)) (\ s r (` instr-code r)) l r])
  
  (function instr-operands (l r) [property #8 #8 (\ r (` instr r)) (\ s r (` (list operand) r)) l r])
  
  (function instr-binding (l r) [property #16 #8 (\ r (` instr r)) (\ s r (` bndg-aug r)) l r])

(ignore x86-64 instruction codes.)
  
  (function label (l r) [=## #33 (\ r (` instr-code r)) r])

  (function x86-lea (l r) [=## #17 (\ r (` instr-code r)) r])

  (function x86-mov (l r) [=## #18 (\ r (` instr-code r)) r])

  (function x86-jmp (l r) [=## #19 (\ r (` instr-code r)) r])
  
  (function x86-movzx (l r) [=## #20 (\ r (` instr-code r)) r])

  (function x86-push (l r) [=## #21 (\ r (` instr-code r)) r])

  (function x86-sub (l r) [=## #23 (\ r (` instr-code r)) r])

  (function x86-add (l r) [=## #24 (\ r (` instr-code r)) r])

  (function x86-pop (l r) [=## #25 (\ r (` instr-code r)) r])

  (function x86-leave (l r) [=## #26 (\ r (` instr-code r)) r])

  (function x86-ret (l r) [=## #27 (\ r (` instr-code r)) r])

  (function x86-je (l r) [=## #29 (\ r (` instr-code r)) r])

  (function x86-or (l r) [=## #30 (\ r (` instr-code r)) r])

  (function x86-call (l r) [=## #32 (\ r (` instr-code r)) r])
  
  (function x86-mul (l r) [=## #38 (\ r (` instr-code r)) r])
  
  (function x86-shl (l r) [=## #39 (\ r (` instr-code r)) r])
  
  (function x86-shr (l r) [=## #40 (\ r (` instr-code r)) r])
  
  (function x86-and (l r) [=## #41 (\ r (` instr-code r)) r])
  
  (function x86-not (l r) [=## #42 (\ r (` instr-code r)) r])
  
  (function x86-xor (l r) [=## #44 (\ r (` instr-code r)) r])
  
  (function x86-div (l r) [=## #47 (\ r (` instr-code r)) r])
  
  (function x86-setz (l r) [=## #48 (\ r (` instr-code r)) r])
  
  (function x86-setc (l r) [=## #49 (\ r (` instr-code r)) r])

(ignore A representation of an operand.)
  
  (function operand (l r) [=# #64 r])
  
  (function op-type (l r) [property #0 #8 (\ r (` operand r)) (\ s r (` operand-type r)) l r])
  
  (function op-size (l r) [property #8 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-locations (l r) [property #16 #8 (\ r (` operand r)) (\ s r (with-vars (a b c d) (`(list (values ,a ,b ,c ,d))r)r)) l r])

(ignore Only for type(s) (register-operand))

  (function op-register (l r) [property #24 #8 (\ r (` operand r)) (\ s r (` register r)) l r])

(ignore Only for type(s) (immediate-operand))

  (function op-immediate (l r) [property #24 #8 (\ r (` operand r)) (\ s r [var r]) l r])

(ignore Only for type(s) (memory-operand))

  (function op-base (l r) [property #24 #8 (\ r (` operand r)) (\ s r (` register r)) l r])
  
  (function op-index (l r) [property #32 #8 (\ r (` operand r)) (\ s r (` register r)) l r])
  
  (function op-scale (l r) [property #40 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-disp (l r) [property #48 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-disp-size (l r) [property #56 #8 (\ r (` operand r)) (\ s r [var r]) l r])

(ignore x86-64 operand types.)

  (function register-operand (l r) [=## #0 (\ r (` operand-type r)) r])
  
  (function immediate-operand (l r) [=## #1 (\ r (` operand-type r)) r])
  
  (function memory-operand (l r) [=## #2 (\ r (` operand-type r)) r])
  
  (function none-operand (l r) [=## #3 (\ r (` operand-type r)) r])

(ignore x86-64 registers.)
  
  (function r/m8 (l r) [=# [<< #1 #5] r])
  
  (function r/m16 (l r) [=# [<< #1 #6] r])
  
  (function r/m32 (l r) [=# [<< #1 #7] r])
  
  (function r/m64 (l r) [=# [<< #1 #8] r])
  
  (function w/rex (l r) [=# [<< #1 #9] r])
  
  (function w/orex (l r) [=# [<< #1 #10] r])
  
  (function none (l r) [=## #17 (\ r (` register r)) r])
  
  (function x86-/0 (l r) [=## [lor #0(r/m32)] (\ r (` register r)) r])

  (function x86-/1 (l r) [=## [lor #1(r/m32)] (\ r (` register r)) r])

  (function x86-/2 (l r) [=## [lor #2(r/m32)] (\ r (` register r)) r])

  (function x86-/3 (l r) [=## [lor #3(r/m32)] (\ r (` register r)) r])

  (function x86-/4 (l r) [=## [lor #4(r/m32)] (\ r (` register r)) r])

  (function x86-/5 (l r) [=## [lor #5(r/m32)] (\ r (` register r)) r])

  (function x86-/6 (l r) [=## [lor #6(r/m32)] (\ r (` register r)) r])

  (function x86-/7 (l r) [=## [lor #7(r/m32)] (\ r (` register r)) r])

  (function al (l r) [=## [lor #0(r/m8)] (\ r (` register r)) r])

  (function cl (l r) [=## [lor #1(r/m8)] (\ r (` register r)) r])

  (function dl (l r) [=## [lor #2(r/m8)] (\ r (` register r)) r])

  (function bl (l r) [=## [lor #3(r/m8)] (\ r (` register r)) r])

  (function ah (l r) [=## [lor #4(r/m8)] (\ r (` register r)) r])

  (function ch (l r) [=## [lor #5(r/m8)] (\ r (` register r)) r])

  (function dh (l r) [=## [lor #6(r/m8)] (\ r (` register r)) r])

  (function bh (l r) [=## [lor #7(r/m8)] (\ r (` register r)) r])
  
  (function spl (l r) [=## [lor #4(r/m8)] (\ r (` register r)) r])

  (function bpl (l r) [=## [lor #5(r/m8)] (\ r (` register r)) r])

  (function sil (l r) [=## [lor #6(r/m8)] (\ r (` register r)) r])

  (function dil (l r) [=## [lor #7(r/m8)] (\ r (` register r)) r])

  (function r8l (l r) [=## [lor #8(r/m8)] (\ r (` register r)) r])

  (function r9l (l r) [=## [lor #9(r/m8)] (\ r (` register r)) r])

  (function r10l (l r) [=## [lor #10(r/m8)] (\ r (` register r)) r])

  (function r11l (l r) [=## [lor #11(r/m8)] (\ r (` register r)) r])

  (function r12l (l r) [=## [lor #12(r/m8)] (\ r (` register r)) r])

  (function r13l (l r) [=## [lor #13(r/m8)] (\ r (` register r)) r])

  (function r14l (l r) [=## [lor #14(r/m8)] (\ r (` register r)) r])

  (function r15l (l r) [=## [lor #15(r/m8)] (\ r (` register r)) r])
  
  (function ax (l r) [=## [lor #0(r/m16)] (\ r (` register r)) r])

  (function cx (l r) [=## [lor #1(r/m16)] (\ r (` register r)) r])

  (function dx (l r) [=## [lor #2(r/m16)] (\ r (` register r)) r])

  (function bx (l r) [=## [lor #3(r/m16)] (\ r (` register r)) r])

  (function sp (l r) [=## [lor #4(r/m16)] (\ r (` register r)) r])

  (function bp (l r) [=## [lor #5(r/m16)] (\ r (` register r)) r])

  (function si (l r) [=## [lor #6(r/m16)] (\ r (` register r)) r])

  (function di (l r) [=## [lor #7(r/m16)] (\ r (` register r)) r])
  
  (function r8w (l r) [=## [lor #8(r/m16)] (\ r (` register r)) r])

  (function r9w (l r) [=## [lor #9(r/m16)] (\ r (` register r)) r])

  (function r10w (l r) [=## [lor #10(r/m16)] (\ r (` register r)) r])

  (function r11w (l r) [=## [lor #11(r/m16)] (\ r (` register r)) r])

  (function r12w (l r) [=## [lor #12(r/m16)] (\ r (` register r)) r])

  (function r13w (l r) [=## [lor #13(r/m16)] (\ r (` register r)) r])

  (function r14w (l r) [=## [lor #14(r/m16)] (\ r (` register r)) r])

  (function r15w (l r) [=## [lor #15(r/m16)] (\ r (` register r)) r])
  
  (function eax (l r) [=## [lor #0(r/m32)] (\ r (` register r)) r])

  (function ecx (l r) [=## [lor #1(r/m32)] (\ r (` register r)) r])

  (function edx (l r) [=## [lor #2(r/m32)] (\ r (` register r)) r])

  (function ebx (l r) [=## [lor #3(r/m32)] (\ r (` register r)) r])

  (function esp (l r) [=## [lor #4(r/m32)] (\ r (` register r)) r])

  (function ebp (l r) [=## [lor #5(r/m32)] (\ r (` register r)) r])

  (function esi (l r) [=## [lor #6(r/m32)] (\ r (` register r)) r])

  (function edi (l r) [=## [lor #7(r/m32)] (\ r (` register r)) r])
  
  (function r8d (l r) [=## [lor #8(r/m32)] (\ r (` register r)) r])

  (function r9d (l r) [=## [lor #9(r/m32)] (\ r (` register r)) r])

  (function r10d (l r) [=## [lor #10(r/m32)] (\ r (` register r)) r])

  (function r11d (l r) [=## [lor #11(r/m32)] (\ r (` register r)) r])

  (function r12d (l r) [=## [lor #12(r/m32)] (\ r (` register r)) r])

  (function r13d (l r) [=## [lor #13(r/m32)] (\ r (` register r)) r])

  (function r14d (l r) [=## [lor #14(r/m32)] (\ r (` register r)) r])

  (function r15d (l r) [=## [lor #15(r/m32)] (\ r (` register r)) r])
  
  (function rax (l r) [=## [lor #0(r/m64)] (\ r (` register r)) r])

  (function rcx (l r) [=## [lor #1(r/m64)] (\ r (` register r)) r])

  (function rdx (l r) [=## [lor #2(r/m64)] (\ r (` register r)) r])

  (function rbx (l r) [=## [lor #3(r/m64)] (\ r (` register r)) r])

  (function rsp (l r) [=## [lor #4(r/m64)] (\ r (` register r)) r])

  (function rbp (l r) [=## [lor #5(r/m64)] (\ r (` register r)) r])

  (function rsi (l r) [=## [lor #6(r/m64)] (\ r (` register r)) r])

  (function rdi (l r) [=## [lor #7(r/m64)] (\ r (` register r)) r])

  (function r8 (l r) [=## [lor #8(r/m64)] (\ r (` register r)) r])

  (function r9 (l r) [=## [lor #9(r/m64)] (\ r (` register r)) r])

  (function r10 (l r) [=## [lor #10(r/m64)] (\ r (` register r)) r])

  (function r11 (l r) [=## [lor #11(r/m64)] (\ r (` register r)) r])

  (function r12 (l r) [=## [lor #12(r/m64)] (\ r (` register r)) r])

  (function r13 (l r) [=## [lor #13(r/m64)] (\ r (` register r)) r])

  (function r14 (l r) [=## [lor #14(r/m64)] (\ r (` register r)) r])

  (function r15 (l r) [=## [lor #15(r/m64)] (\ r (` register r)) r])
  
  (function rip (l r) [=## [lor #16(r/m64)] (\ r (` register r)) r])

(ignore Usage (make-instrN opcode (ops ...) buf handler))

(function make-instrN (l r)
  [llllst (` invoke r) (` make-instruction r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(constrain make-instruction (\ r (with-vars (b) (`(function (instr-code (list operand) buffer ,b) instr)r)r)))

(function make-instruction (code operands reg handler)
  (let (u [buffer-alloc (instruction) reg handler]) (do
    (setf instr-code u code)
    (setf instr-operands u operands)
    (setf instr-binding u null-binding)
    u)))

(constrain make-relocation (\ r (with-vars (a b c) (`(function (reloc-type operand bndg-aug ,c ,a buffer ,b) reloc)r)r)))

(function make-relocation (type operand binding ctx addend-func buf handler)
  (substitute (.. buf handler)
    (let (r [buffer-alloc (relocation) ..]) (do
      (setf reloc-type r type)
      (setf reloc-operand r operand)
      (setf reloc-binding r binding)
      (setf reloc-context r ctx)
      (setf reloc-addend-func r addend-func)
      r))))

(constrain register-size (\ r (with-vars (a) (`(function (register) ,a)r)r)))

(function register-size (reg)
  (if [land reg(r/m8)] #1
  (if [land reg(r/m16)] #2
  (if [land reg(r/m32)] #4
  (if [land reg(r/m64)] #8
    (ignore))))))

(constrain make-reg-op (\ r (with-vars (a) (`(function (register buffer ,a) operand)r)r)))

(function make-reg-op (reg buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (register-operand))
      (setf op-size op [register-size reg])
      (setf op-register op reg)
      (setf op-locations op nil)
      op))))

(constrain make-imm-op (\ r (with-vars (a b c) (`(function (,b ,c buffer ,a) operand)r)r)))

(function make-imm-op (op-size imm buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (immediate-operand))
      (setf op-size op op-size)
      (setf op-immediate op imm)
      (setf op-locations op nil)
      op))))

(constrain make-none-op (\ r (with-vars (a) (`(function (buffer ,a) operand)r)r)))

(function make-none-op (buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (none-operand))
      (setf op-size op #0)
      op))))

(constrain make-mem-op (\ r (with-vars (a b c d e) (`(function (,a register register ,b ,c ,d buffer ,e) operand)r)r)))

(function make-mem-op (op-size base index scale disp disp-size buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (memory-operand))
      (setf op-size op op-size)
      (setf op-base op base)
      (setf op-index op index)
      (setf op-scale op scale)
      (setf op-disp op disp)
      (setf op-disp-size op disp-size)
      (setf op-locations op nil)
      op))))

(constrain reg-lower-8 (\ r (`(function (register) register)r)))

(function reg-lower-8 (reg) (switch = reg
  ((ah)(ah)) ((bh)(bh)) ((ch)(ch)) ((dh)(dh)) ((al)(al)) ((bl)(bl)) ((cl)(cl)) ((dl)(dl))
  ((dil)(dil)) ((sil)(sil)) ((bpl) (bpl)) ((spl)(spl)) ((r8l)(r8l)) ((r9l)(r9l)) ((r10l)(r10l))
  ((r11l)(r11l)) ((r12l)(r12l)) ((r13l)(r13l)) ((r14l)(r14l)) ((r15l)(r15l)) ((ax)(al))
  ((bx)(bl)) ((cx)(cl)) ((dx)(dl)) ((di)(dil)) ((si)(sil)) ((bp)(bpl)) ((sp)(spl)) ((r8w)(r8l))
  ((r9w)(r9l)) ((r10w)(r10l)) ((r11w)(r11l)) ((r12w)(r12l)) ((r13w)(r13l)) ((r14w)(r14l))
  ((r15w)(r15l)) ((eax)(al)) ((ebx)(bl)) ((ecx)(cl)) ((edx)(dl)) ((edi)(dl)) ((esi)(sil))
  ((ebp)(bpl)) ((esp)(spl)) ((r8d)(r8l)) ((r9d)(r9l)) ((r10d)(r10l)) ((r11d)(r11l))
  ((r12d)(r12l)) ((r13d)(r13l)) ((r14d)(r14l)) ((r15d)(r15l)) ((rax)(al)) ((rbx)(bl))
  ((rcx)(cl)) ((rdx)(dl)) ((rdi)(dil)) ((rsi)(sil)) ((rbp)(bpl)) ((rsp)(spl)) ((r8)(r8l))
  ((r9)(r9l)) ((r10)(r10l)) ((r11)(r11l)) ((r12)(r12l)) ((r13)(r13l)) ((r14)(r14l))
  ((r15)(r15l)) (ignore)))

(constrain op-lower-8 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-8 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-8 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #1 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #1 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-16 (\ r (`(function (register) register)r)))

(function reg-lower-16 (reg) (switch = reg
  ((ax)(ax)) ((bx)(bx)) ((cx)(cx)) ((dx)(dx)) ((di)(di)) ((si)(si)) ((bp)(bp)) ((sp)(sp))
  ((r8w)(r8w)) ((r9w)(r9w)) ((r10w)(r10w)) ((r11w)(r11w)) ((r12w)(r12w)) ((r13w)(r13w))
  ((r14w)(r14w)) ((r15w)(r15w)) ((eax)(ax)) ((ebx)(bx)) ((ecx)(cx)) ((edx)(dx)) ((edi)(di))
  ((esi)(si)) ((ebp)(bp)) ((esp)(sp)) ((r8d)(r8w)) ((r9d)(r9w)) ((r10d)(r10w)) ((r11d)(r11w))
  ((r12d)(r12w)) ((r13d)(r13w)) ((r14d)(r14w)) ((r15d)(r15w)) ((rax)(ax)) ((rbx)(bx))
  ((rcx)(cx)) ((rdx)(dx)) ((rdi)(di)) ((rsi)(si)) ((rbp)(bp)) ((rsp)(sp)) ((r8)(r8w))
  ((r9)(r9w)) ((r10)(r10w)) ((r11)(r11w)) ((r12)(r12w)) ((r13)(r13w)) ((r14)(r14w))
  ((r15)(r15w)) (ignore)))

(constrain op-lower-16 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-16 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-16 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #2 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #2 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-32 (\ r (`(function (register) register)r)))

(function reg-lower-32 (reg) (switch = reg
  ((eax)(eax)) ((ebx)(ebx)) ((ecx)(ecx)) ((edx)(edx)) ((edi)(edi)) ((esi)(esi)) ((ebp)(ebp))
  ((esp)(esp)) ((r8d)(r8d)) ((r9d)(r9d)) ((r10d)(r10d)) ((r11d)(r11d)) ((r12d)(r12d))
  ((r13d)(r13d)) ((r14d)(r14d)) ((r15d)(r15d)) ((rax)(eax)) ((rbx)(ebx)) ((rcx)(ecx))
  ((rdx)(edx)) ((rdi)(edi)) ((rsi)(esi)) ((rbp)(ebp)) ((rsp)(esp)) ((r8)(r8d)) ((r9)(r9d))
  ((r10)(r10d)) ((r11)(r11d)) ((r12)(r12d)) ((r13)(r13d)) ((r14)(r14d)) ((r15)(r15d))
  (ignore)))

(constrain op-lower-32 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-32 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-32 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #4 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #4 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-64 (\ r (`(function (register) register)r)))

(function reg-lower-64 (reg) (switch = reg
  ((rax)(rax)) ((rbx)(rbx)) ((rcx)(rcx)) ((rdx)(rdx)) ((rdi)(rdi)) ((rsi)(rsi)) ((rbp)(rbp))
  ((rsp)(rsp)) ((r8)(r8)) ((r9)(r9)) ((r10)(r10)) ((r11)(r11)) ((r12)(r12)) ((r13)(r13))
  ((r14)(r14)) ((r15)(r15)) (ignore)))

(constrain op-lower-64 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-64 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-64 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #8 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #8 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain print-instr-code (\ r (with-vars (a) (`(function (instr-code ,a) ())r)r)))

(function print-instr-code (code handler)
  [print-str (stdout) (switch = code
    ((label) (" label)) ((x86-lea) (" lea)) ((x86-mov) (" mov)) ((x86-jmp) (" jmp))
    ((x86-movzx) (" movzx)) ((x86-push) (" push)) ((x86-sub) (" sub)) ((x86-add) (" add))
    ((x86-pop) (" pop)) ((x86-leave) (" leave)) ((x86-ret) (" ret)) ((x86-je) (" je))
    ((x86-or) (" or)) ((x86-call) (" call)) ((x86-mul) (" mul)) ((x86-shl) (" shl))
    ((x86-shr) (" shr)) ((x86-and) (" and)) ((x86-not) (" not)) ((x86-xor) (" xor))
    ((x86-div) (" div)) ((x86-setz) (" setz)) ((x86-setc) (" setc)) (ignore)) handler])

(constrain print-register (\ r (with-vars (a) (`(function (register ,a) ())r)r)))

(function print-register (reg handler)
  [print-str (stdout) (switch = reg
    ((none)(" (lparen)none(rparen))) ((al)(" al)) ((cl)(" cl)) ((dl)(" dl)) ((bl)(" bl))
    ((ah)(" ah)) ((ch)(" ch)) ((dh)(" dh)) ((bh)(" bh)) ((spl)(" spl)) ((bpl)(" bpl))
    ((sil)(" sil)) ((dil)(" dil)) ((r8l)(" r8l)) ((r9l)(" r9l)) ((r10l)(" r10l))
    ((r11l)(" r11l)) ((r12l)(" r12l)) ((r13l)(" r13l)) ((r14l)(" r14l)) ((r15l)(" r15l))  
    ((ax)(" ax)) ((cx)(" cx)) ((dx)(" dx)) ((bx)(" bx)) ((sp)(" sp)) ((bp)(" bp))
    ((si)(" si)) ((di)(" di)) ((r8w)(" r8w)) ((r9w)(" r9w)) ((r10w)(" r10w)) ((r11w)(" r11w))
    ((r12w)(" r12w)) ((r13w)(" r13w)) ((r14w)(" r14w)) ((r15w)(" r15w)) ((eax)(" eax))
    ((ecx)(" ecx)) ((edx)(" edx)) ((ebx)(" ebx)) ((esp)(" esp)) ((ebp)(" ebp))
    ((esi)(" esi)) ((edi)(" edi)) ((r8d)(" r8d)) ((r9d)(" r9d)) ((r10d)(" r10d))
    ((r11d)(" r11d)) ((r12d)(" r12d)) ((r13d)(" r13d)) ((r14d)(" r14d)) ((r15d)(" r15d))  
    ((rax)(" rax)) ((rcx)(" rcx)) ((rdx)(" rdx)) ((rbx)(" rbx)) ((rsp)(" rsp))
    ((rbp)(" rbp)) ((rsi)(" rsi)) ((rdi)(" rdi)) ((r8)(" r8)) ((r9)(" r9)) ((r10)(" r10))
    ((r11)(" r11)) ((r12)(" r12)) ((r13)(" r13)) ((r14)(" r14)) ((r15)(" r15))  
    ((rip)(" rip)) (ignore)) handler])

(constrain print-operand (\ r (with-vars (a) (`(function (operand ,a) ())r)r)))

(function print-operand (op handler)
  (switch = (@ op-type op)
    ((register-operand)
      [print-register (@ op-register op) handler])
    ((immediate-operand)
      [print-uint (stdout) (@ op-immediate op) handler])
    ((memory-operand) (do
      [print-char (stdout) (lbracket) handler]
      (if [not= (@ op-base op) (none)]
        [print-register (@ op-base op) handler]
        (ignore))
      (if (and [not= (@ op-base op) (none)] [not= (@ op-index op) (none)])
        [print-str (stdout) ("(space)+(space)) handler]
        (ignore))
      (if [not= (@ op-index op) (none)] (do
        [print-register (@ op-index op) handler]
        [print-str (stdout) (" *) handler]
        [print-uint (stdout) (@ op-scale op) handler])
        (ignore))
      (if (and (or [not= (@ op-base op) (none)] [not= (@ op-index op) (none)])
          [not= (@ op-disp-size op) #0])
        [print-str (stdout) ("(space)+(space)) handler]
        (ignore))
      (if [not= (@ op-disp-size op) #0]
        [print-uint (stdout) (@ op-disp op) handler]
        (ignore))
      [print-char (stdout) (rbracket) handler]))
    ((none-operand)
      [print-str (stdout) ("(lparen)none(rparen)) handler])
    (ignore)))

(constrain print-instr (\ r (with-vars (a) (`(function (instr ,a) ())r)r)))

(function print-instr (instr handler) (do
  [print-instr-code (@ instr-code instr) handler]
  (if [nil? (@ instr-operands instr)] (ignore) (do
    [print-str (stdout) ("(space)) handler]
    [print-operand [@car (@ instr-operands instr)] handler]
    (foreach (op [@cdr (@ instr-operands instr)]) (do
      [print-str (stdout) (" ,(space)) handler]
      [print-operand op handler]))))))

(constrain mem-write (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function mem-write (mem idx bytes cnt)
  (let (end [+ $idx cnt])
  (loop write-bytes (bytes bytes)
    (if [= $idx end] (ignore) (do
      [setb [+ mem $idx] [getb bytes]]
      [set+ idx #1]
      {write-bytes [+ bytes #1]})))))

(constrain write-instr
  (\ r (with-vars (a b c d e f) (`(function (,a (ref ,b) ,c ,d operand operand operand operand buffer ,f) ,e)r)r)))

(function write-instr (bin pos opcode opcode-size opcode.reg-op modrm.reg-op modrm.rm-op imm-op buf handler)
  (substitute (.. buf handler)
    (let (modrm.rm-op-code [land
      (if [= (@ op-type modrm.rm-op) (register-operand)] (@ op-register modrm.rm-op)
      (if [= (@ op-type modrm.rm-op) (memory-operand)] (@ op-base modrm.rm-op) (ignore))) #7])
    
    (let (modrm.reg-op-code [land (@ op-register modrm.reg-op) #7])
    
    (let (opcode [+ opcode
      (if [= (@ op-type opcode.reg-op) (register-operand)] [land (@ op-register opcode.reg-op) #7] #0)])
    
    (let (has-modrm? (or [not= (@ op-type modrm.reg-op) (none-operand)] [not= (@ op-type modrm.rm-op) (none-operand)]))
    
    (let (modrm.mod
      (if [= (@ op-type modrm.rm-op) (register-operand)] #3
      (if (or [= (@ op-disp-size modrm.rm-op) #0] [= (@ op-base modrm.rm-op) (none)] [= (@ op-base modrm.rm-op) (rip)]) #0
      (if [= (@ op-disp-size modrm.rm-op) #1] #1
      (if [= (@ op-disp-size modrm.rm-op) #4] #2 (ignore))))))
    
    (let (has-sib? (and [= (@ op-type modrm.rm-op) (memory-operand)]
      (or [not= (@ op-index modrm.rm-op) (none)] [= (@ op-base modrm.rm-op) (esp)]
        (and [= (@ op-base modrm.rm-op) (ebp)] [= (@ op-disp-size modrm.rm-op) #0]))))
    
    (let (modrm.rm
      (if [= (@ op-type modrm.rm-op) (register-operand)] modrm.rm-op-code
      (if has-sib? #4
      (if [= (@ op-base modrm.rm-op) (none)] #5
      (if [= (@ op-base modrm.rm-op) (rip)] #5
        modrm.rm-op-code)))))
    
    (let (modrm.reg modrm.reg-op-code)
            
    (let (sib.scale (switch = (@ op-scale modrm.rm-op) (#1 #0) (#2 #1) (#4 #2) (#8 #3) (ignore)))
    
    (let (sib.index (if [= (@ op-index modrm.rm-op) (none)] #4 (@ op-index modrm.rm-op)))
    
    (let (sib.base (if (or [= (@ op-base modrm.rm-op) (none)]) #5 modrm.rm-op-code))
    
    (let (has-rex? (or [= [max (@ op-size modrm.reg-op) [max (@ op-size modrm.rm-op) (@ op-size opcode.reg-op)]] #8]
      (and [= (@ op-type modrm.rm-op) (memory-operand)] (or
        (and [not= (@ op-base modrm.rm-op) (none)] [= [register-size (@ op-base modrm.rm-op)] #8])
        (and [not= (@ op-index modrm.rm-op) (none)] [= [register-size (@ op-index modrm.rm-op)] #8])
        [= (@ op-disp-size modrm.rm-op) #8]))))
    
    (let (rex.w (or [= (@ op-size modrm.reg-op) #8] [= (@ op-size modrm.rm-op) #8] [= (@ op-size opcode.reg-op) #8]))
    
    (let (rex.r (if (and [= (@ op-type modrm.reg-op) (register-operand)] [land (@ op-register modrm.reg-op) #8]) #1 #0))
    
    (let (rex.x (if (and [= (@ op-type modrm.rm-op) (memory-operand)] [not= (@ op-index modrm.rm-op) (none)]
      [land (@ op-index modrm.rm-op) #8]) #1 #0))
    
    (let (rex.b (if (or (and [= (@ op-type modrm.rm-op) (memory-operand)] [not= (@ op-base modrm.rm-op) (none)]
      [land (@ op-base modrm.rm-op) #8]) (and [= (@ op-type modrm.rm-op) (register-operand)] [not= (@ op-register modrm.rm-op) (none)]
      [land (@ op-register modrm.rm-op) #8]) (and [= (@ op-type opcode.reg-op) (register-operand)]
      [not= (@ op-register opcode.reg-op) (none)] [land (@ op-register opcode.reg-op) #8])) #1 #0))
    
    (let (has-oso? [= [max (@ op-size modrm.reg-op) (@ op-size modrm.rm-op)] #2])
    
    (let (has-aso? (or
        (and [not= (@ op-base modrm.rm-op) (none)] [= [register-size (@ op-base modrm.rm-op)] #2])
        (and [not= (@ op-index modrm.rm-op) (none)] [= [register-size (@ op-index modrm.rm-op)] #2])
        [= (@ op-disp-size modrm.rm-op) #2]))
    
    (let (instr-start-pos $pos) (do
    
    (if has-oso? [mem-write bin pos (storage _ (hex 66)) #1] (ignore))
    
    (if has-aso? [mem-write bin pos (storage _ (hex 67)) #1] (ignore))
    
    (if has-rex?
      [mem-write bin pos (storage _
        [lor [<< #4 #4]
        [lor [<< rex.w #3]
        [lor [<< rex.r #2]
        [lor [<< rex.x #1]
        [lor [<< rex.b #0]
          #0]]]]]) #1] (ignore))
          
    [mem-write bin pos (storage _ opcode) opcode-size]
    
    (if has-modrm? (do
      [mem-write bin pos (storage _
        [lor [<< modrm.mod #6]
        [lor [<< modrm.reg #3]
        [lor [<< modrm.rm #0]
          #0]]]) #1]
      
      (if has-sib?
        [mem-write bin pos (storage _
          [lor [<< sib.scale #6]
          [lor [<< sib.index #3]
          [lor [<< sib.base #0]
            #0]]]) #1] (ignore)))
            
      (ignore))
    
    (let (disp-pos $pos) (do
    
    (if [= (@ op-type modrm.rm-op) (memory-operand)]
      [mem-write bin pos (storage _ (@ op-disp modrm.rm-op)) (@ op-disp-size modrm.rm-op)]
      (ignore))
    
    (let (imm-pos $pos) (do
    
    (if [= (@ op-type imm-op) (immediate-operand)]
      [mem-write bin pos (storage _ (@ op-immediate imm-op)) (@ op-size imm-op)]
      (ignore))
    
    (let (instr-size [- $pos instr-start-pos]) (do
    
    (if [= (@ op-type modrm.rm-op) (memory-operand)]
      [prepend (values (buffer-storage ..) disp-pos (@ op-disp-size modrm.rm-op) instr-start-pos instr-size)
        (& op-locations modrm.rm-op) ..]
      (ignore))
    
    (if [= (@ op-type imm-op) (immediate-operand)]
      [prepend (values (buffer-storage ..) imm-pos (@ op-size imm-op) instr-start-pos instr-size) (& op-locations imm-op) ..]
      (ignore))
    
    (true)))))))))))))))))))))))))))))

(constrain write-mr-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mr-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #2] (let
        (op1 [@car (@ instr-operands n)])
        (op2 [@cadr (@ instr-operands n)])
      (if (and [land mask #1] [= (@ op-size op1) #1] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #1] [= (@ op-type op2) (register-operand)])
        [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
      (if (and [land mask #2] [= (@ op-size op1) #2] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #2] [= (@ op-type op2) (register-operand)])
        [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
      (if (and [land mask #4] [= (@ op-size op1) #4] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #4] [= (@ op-type op2) (register-operand)])
        [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
      (if (and [land mask #8] [= (@ op-size op1) #8] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #8] [= (@ op-type op2) (register-operand)])
        [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
        (false)))))))))

(constrain write-rm-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-rm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #2] (let
        (op1 [@car (@ instr-operands n)])
        (op2 [@cadr (@ instr-operands n)])
      (if (and [land mask #1] [= (@ op-size op1) #1] [= (@ op-type op1) (register-operand)]
              [= (@ op-size op2) #1] (or [= (@ op-type op2) (memory-operand)] [= (@ op-type op2) (register-operand)]))
        [write-instr bin pos (hex 8A) [>> mask #4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
      (if (and [land mask #2] [= (@ op-size op1) #2] [= (@ op-type op1) (register-operand)]
          [= (@ op-size op2) #2] (or [= (@ op-type op2) (memory-operand)] [= (@ op-type op2) (register-operand)]))
        [write-instr bin pos (hex 8B) [>> mask #4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
      (if (and [land mask #4] [= (@ op-size op1) #4] [= (@ op-type op1) (register-operand)]
          [= (@ op-size op2) #4] (or [= (@ op-type op2) (memory-operand)] [= (@ op-type op2) (register-operand)]))
        [write-instr bin pos (hex 8B) [>> mask #4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
      (if (and [land mask #8] [= (@ op-size op1) #8] [= (@ op-type op1) (register-operand)]
          [= (@ op-size op2) #8] (or [= (@ op-type op2) (memory-operand)] [= (@ op-type op2) (register-operand)]))
        [write-instr bin pos (hex 8B) [>> mask #4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
        (false)))))))))

(constrain write-mi-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mi-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #2] (let
        (op1 [@car (@ instr-operands n)])
        (op2 [@cadr (@ instr-operands n)])
      (if (and [= (@ op-size op1) #1] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
              [= (@ op-size op2) #1] [= (@ op-type op2) (immediate-operand)])
        [write-instr bin pos (hex 80) [>> mask #4] [make-none-op ..] opcode.reg-op op1 op2 ..]
      (if (and [= (@ op-size op1) #2] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #2] [= (@ op-type op2) (immediate-operand)])
        [write-instr bin pos (hex 81) [>> mask #4] [make-none-op ..] opcode.reg-op op1 op2 ..]
      (if (and [= (@ op-size op1) #4] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #4] [= (@ op-type op2) (immediate-operand)])
        [write-instr bin pos (hex 81) [>> mask #4] [make-none-op ..] opcode.reg-op op1 op2 ..]
      (if (and [= (@ op-size op1) #8] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)])
          [= (@ op-size op2) #4] [= (@ op-type op2) (immediate-operand)])
        [write-instr bin pos (hex 81) [>> mask #4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (false)))))))))

(constrain write-mm-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #3] (let
        (op1 [@car (@ instr-operands n)])
        (op2 [@cadr (@ instr-operands n)])
        (op3 [@caddr (@ instr-operands n)])
      (if (and [land mask #1] [= (@ op-size op1) #1] [= (@ op-type op1) (memory-operand)]
          [= (@ op-size op2) #1] [= (@ op-type op2) (memory-operand)]) (do
        [write-instr bin pos (hex 8A) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
        [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
      (if (and [land mask #2] [= (@ op-size op1) #2] [= (@ op-type op1) (memory-operand)]
          [= (@ op-size op2) #2] [= (@ op-type op2) (memory-operand)]) (do
        [write-instr bin pos (hex 8B) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
        [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
      (if (and [land mask #4] [= (@ op-size op1) #4] [= (@ op-type op1) (memory-operand)]
          [= (@ op-size op2) #4] [= (@ op-type op2) (memory-operand)]) (do
        [write-instr bin pos (hex 8B) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
        [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
      (if (and [land mask #8] [= (@ op-size op1) #8] [= (@ op-type op1) (memory-operand)]
          [= (@ op-size op2) #8] [= (@ op-type op2) (memory-operand)]) (do
        [write-instr bin pos (hex 8B) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
        [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
        (false)))))))))

(constrain write-m-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-m-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #1] (let
        (op1 [@car (@ instr-operands n)])
      (if (and [land mask #1] [= (@ op-size op1) #1] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)]))
        [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
      (if (and [land mask #2] [= (@ op-size op1) #2] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)]))
        [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
      (if (and [land mask #4] [= (@ op-size op1) #4] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)]))
        [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
      (if (and [land mask #8] [= (@ op-size op1) #8] (or [= (@ op-type op1) (memory-operand)] [= (@ op-type op1) (register-operand)]))
        [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (false)))))))))

(constrain write-d-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-d-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (and [>= [length (@ instr-operands n)] #1] (let
        (op1 [@car (@ instr-operands n)])
      (if (and [land mask #1] [= (@ op-size op1) #1] [= (@ op-type op1) (immediate-operand)])
        [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
      (if (and [land mask #2] [= (@ op-size op1) #2] [= (@ op-type op1) (immediate-operand)])
        [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
      (if (and [land mask #4] [= (@ op-size op1) #4] [= (@ op-type op1) (immediate-operand)])
        [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
      (if (and [land mask #8] [= (@ op-size op1) #8] [= (@ op-type op1) (immediate-operand)])
        [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
        (false)))))))))

(storage unsupported-instruction-error (ignore))

(constrain assemble (\ r (with-vars (a b e) (`(function ((list instr) ,a (ref ,b) buffer ,e) ())r)r)))

(function assemble (instrs bin pos buf handler)
  (substitute (.. buf handler) (do
    [set pos #0]
    (foreach (n instrs) (do
      (let (instr-bndg (@ instr-binding n))
        (if [not= instr-bndg null-binding] (do
          (setf bndg-storage instr-bndg (instruction-storage))
          (setf bndg-offset instr-bndg $pos)
          (setf st-value (@ bndg-context instr-bndg) $pos))
          (ignore)))
      
      (switch = (@ instr-code n)
        ((label) (ignore))
        
        ((x86-push) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-pop) (or
          [write-m-instr (hex 1E) (ignore) (hex 8F) (hex 8F) (hex 8F) [make-reg-op (x86-/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-mov) (let
            (op1 [@car (@ instr-operands n)])
            (op2 [@cadr (@ instr-operands n)]) (or
          [write-mr-instr (hex 1F) (hex 88) (hex 89) (hex 89) (hex 89) n bin pos ..]
          [write-rm-instr (hex 1F) (hex 8A) (hex 8B) (hex 8B) (hex 8B) n bin pos ..]
          [write-mm-instr (hex 1F) (hex 88) (hex 89) (hex 89) (hex 89) n bin pos ..]
          (if (and [= (@ op-size op1) #8] [= (@ op-type op1) (register-operand)]
              [= (@ op-size op2) #8] [= (@ op-type op2) (immediate-operand)])
            [write-instr bin pos (hex B8) #1 op1 [make-none-op ..] [make-none-op ..] op2 ..]
          (let (op3 [@caddr (@ instr-operands n)])
          (if (and [= (@ op-size op1) #8] [= (@ op-type op1) (memory-operand)]
              [= (@ op-size op2) #8] [= (@ op-type op2) (immediate-operand)]) (do
            [write-instr bin pos (hex B8) #1 op3 [make-none-op ..] [make-none-op ..] op2 ..]
            [write-instr bin pos (hex 89) #1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
            {handler (storage _ unsupported-instruction-error n)}))))))
        
        ((x86-lea) (let
            (op1 [@car (@ instr-operands n)])
            (op2 [@cadr (@ instr-operands n)])
          (if (and [= (@ op-size op1) #2] [= (@ op-type op1) (register-operand)]
              [= (@ op-type op2) (memory-operand)])
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
          (if (and [= (@ op-size op1) #4] [= (@ op-type op1) (register-operand)]
              [= (@ op-type op2) (memory-operand)])
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
          (if (and [= (@ op-size op1) #8] [= (@ op-type op1) (register-operand)]
              [= (@ op-type op2) (memory-operand)])
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
          (let (op3 [@caddr (@ instr-operands n)])
          (if (and [= (@ op-size op1) #2] [= (@ op-type op1) (memory-operand)]
              [= (@ op-type op2) (memory-operand)]) (do
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
            [write-instr bin pos (hex 89) #1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
          (if (and [= (@ op-size op1) #4] [= (@ op-type op1) (memory-operand)]
              [= (@ op-type op2) (memory-operand)]) (do
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
            [write-instr bin pos (hex 89) #1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
          (if (and [= (@ op-size op1) #8] [= (@ op-type op1) (memory-operand)]
              [= (@ op-type op2) (memory-operand)]) (do
            [write-instr bin pos (hex 8D) #1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
            [write-instr bin pos (hex 89) #1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
            {handler (storage _ unsupported-instruction-error n)})))))))))
        
        ((x86-jmp) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/4) ..] n bin pos ..]
          [write-d-instr (hex 17) (hex EB) (hex E9) (hex E9) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))

        ((x86-sub) (or
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/5) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-add) (or
          [write-mr-instr (hex 1F) (hex 00) (hex 01) (hex 01) (hex 01) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-or) (or
          [write-mm-instr (hex 1F) (hex 08) (hex 09) (hex 09) (hex 09) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-call) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/2) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-je) (or
          [write-d-instr (hex 24) (ignore) (ignore) (hex 840F) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-leave)
          [write-instr bin pos (hex C9) #1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        
        ((x86-ret)
          [write-instr bin pos (hex C3) #1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        
        {handler (storage _ unsupported-instruction-error n)}))))))

(storage shstrtab ("(nul).shstrtab(nul).text(nul).strtab(nul).symtab(nul).bss(nul).rela.text(nul)))

(constrain measure-strtab (\ r (with-vars (a) (`(function ((list instr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-strtab (generated-expressions undefined-bindings static-bindings)
  (let (undefined-bindings-len (fold (acc #0) (sym undefined-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (static-bindings-len (fold (acc #0) (sym static-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (generated-expressions-len (fold (acc #0) (e generated-expressions)
        [+ acc (let (instr-bndg (@ instr-binding e)) (if [not= instr-bndg null-binding]
          (let (label-str (@ bndg-name instr-bndg))
            (if [not= label-str null-string] [+ [strlen label-str] #1] #0))
          #0))]))
    [+ #1 [+ undefined-bindings-len [+ static-bindings-len generated-expressions-len]]]))

(constrain measure-symtab (\ r (with-vars (a) (`(function ((list instr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-symtab (generated-expressions undefined-bindings static-bindings)
  (let (generated-expressions-len
        (fold (acc #0) (e generated-expressions) [+ acc (if [not= (@ instr-binding e) null-binding] #1 #0)]))
    [+ #1 [+ generated-expressions-len [+ [length undefined-bindings] [length static-bindings]]]]))

(constrain max-elf-size (\ r (with-vars (a) (`(function ((list instr) (list reloc) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function max-elf-size (generated-expressions relocations undefined-bindings static-bindings)
  [+ (elf64-ehdr) [+ [* (elf64-shdr) (write-elf-sh-count)] [+ [pad-size [strvlen $shstrtab] (write-elf-alignment)]
    [+ [pad-size [* (write-elf-max-instr-len) [* [length generated-expressions] #2]] (write-elf-alignment)]
    [+ [pad-size [measure-strtab generated-expressions undefined-bindings static-bindings] (write-elf-alignment)]
    [+ [* (elf64-sym) [measure-symtab generated-expressions undefined-bindings static-bindings]]
    [* (elf64-rela) [length relocations]]]]]]]])

(ignore
  Takes assembly code and a list of symbols as constructs an object file.
  generated-expressions is a list of assembly expressions. symbols is a list of the static
  symbols used in the assembly expressions. reg is the buffer into which the generated
  object code should be put. Returns a pair containing a reference to the generated object
  code and the size of the generated object code.)

(constrain write-elf (\ r (with-vars (a b c d) (`(function ((list instr) (list reloc) (list bndg-aug) (list bndg-aug) ,a buffer ,c)
  (values ,b ,d))r)r)))

(function write-elf (generated-expressions relocations undefined-bindings static-bindings outs reg handler)
  (let (temp-buf [create-buffer #0 handler])
    (fallthrough
      (do
        (let (pos (storage _ #0))
        (let (bin [buffer-alloc [max-elf-size generated-expressions relocations undefined-bindings static-bindings] reg cleanup])
        
        (let (ehdr [buffer-alloc (elf64-ehdr) temp-buf cleanup]) (do
        (setf ei-mag0 (& e-ident ehdr) (elfmag0))
        (setf ei-mag1 (& e-ident ehdr) (elfmag1))
        (setf ei-mag2 (& e-ident ehdr) (elfmag2))
        (setf ei-mag3 (& e-ident ehdr) (elfmag3))
        (setf ei-class (& e-ident ehdr) (elfclass64))
        (setf ei-data (& e-ident ehdr) (elfdata2lsb))
        (setf ei-version (& e-ident ehdr) #1)
        (setf ei-osabi (& e-ident ehdr) (elfosabi-sysv))
        (setf ei-abiversion (& e-ident ehdr) #0)
    
        (until (i #7) [= i (ei-nident)] [+ i #1] [setb (loc(byte)i(& e-ident ehdr)) #0])
    
        (setf e-type ehdr (et-rel))
        (setf e-machine ehdr (em-x86-64))
        (setf e-version ehdr #1)
        (setf e-entry ehdr #0)
        (setf e-phoff ehdr #0)
        (setf e-shoff ehdr (elf64-ehdr))
        (setf e-flags ehdr #0)
        (setf e-ehsize ehdr (elf64-ehdr))
        (setf e-phentsize ehdr #0)
        (setf e-phnum ehdr #0)
        (setf e-shentsize ehdr (elf64-shdr))
        (setf e-shnum ehdr (write-elf-sh-count))
        (setf e-shstrndx ehdr #1)
        [mem-write bin pos ehdr (elf64-ehdr)]
        
        (let (strtab-len [measure-strtab generated-expressions undefined-bindings static-bindings])
        (let (sym-count [measure-symtab generated-expressions undefined-bindings static-bindings])
    
        (let (syms [buffer-alloc [* sym-count (elf64-sym)] temp-buf cleanup])
        (let (sym-ptr (storage _ syms)) (do
        (ignore Mandatory undefined symbol)
        (setf st-name $sym-ptr #0)
        (setf st-value $sym-ptr #0)
        (setf st-size $sym-ptr #0)
        (setf st-info $sym-ptr #0)
        (setf st-other $sym-ptr #0)
        (setf st-shndx $sym-ptr (shn-undef))
        [set+ sym-ptr (elf64-sym)]
    
        (let (strtab-padded-len [pad-size strtab-len (write-elf-alignment)])
        (let (strtab [buffer-alloc strtab-padded-len temp-buf cleanup])
        (let (strtabptr (storage _ strtab)) (do
        [setb $strtabptr #0]
        [set+ strtabptr #1]
    
        (let (bss-ptr (storage _ #0)) (do
    
        (foreach (sym static-bindings) (do
          (if [= (@ bndg-scope sym) (local-scope)] (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore))
          [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]]))
    
        (foreach (e generated-expressions)
          (let (instr-bndg (@ instr-binding e))
            (if (and [not= instr-bndg null-binding] [= (@ bndg-scope instr-bndg) (local-scope)]) (do
              (if [not= (@ bndg-name instr-bndg) null-string]
                (do
                  [strcpy $strtabptr (@ bndg-name instr-bndg)]
                  (setf st-name $sym-ptr [- $strtabptr strtab])
                  [set+ strtabptr [+[strlen(@ bndg-name instr-bndg)]#1]])
                (setf st-name $sym-ptr #0))
          
              (setf st-value $sym-ptr #0)
              (setf st-size $sym-ptr #0)
              (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
              (setf st-other $sym-ptr #0)
              (setf st-shndx $sym-ptr #2)
              (setf bndg-context instr-bndg $sym-ptr)
              [set+ sym-ptr (elf64-sym)])
              (ignore))))
    
        (let (local-symbol-count [/[- $sym-ptr syms](elf64-sym)]) (do
        
        (ignore Reset bss-ptr to #0 and fill in the gaps between the local symbols.)
        [set bss-ptr #0]
        
        (foreach (sym static-bindings) (do
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (defined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore))
          [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]]))
    
        (foreach (sym undefined-bindings)
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (undefined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr #0)
            (setf st-size $sym-ptr #0)
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr (shn-undef))
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore)))
    
        (foreach (e generated-expressions)
          (let (instr-bndg (@ instr-binding e))
            (if (and [not= instr-bndg null-binding] [= (@ bndg-scope instr-bndg) (global-scope)]) (do
              (if [not= (@ bndg-name instr-bndg) null-string]
                (do
                  [strcpy $strtabptr (@ bndg-name instr-bndg)]
                  (setf st-name $sym-ptr [- $strtabptr strtab])
                  [set+ strtabptr [+[strlen(@ bndg-name instr-bndg)]#1]])
                (setf st-name $sym-ptr #0))
          
              (setf st-value $sym-ptr #0)
              (setf st-size $sym-ptr #0)
              (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
              (setf st-other $sym-ptr #0)
              (setf st-shndx $sym-ptr #2)
              (setf bndg-context instr-bndg $sym-ptr)
              [set+ sym-ptr (elf64-sym)])
              (ignore))))
    
        (let (text-len (storage _ (ignore)))
        (let (max-text-sec-len [pad-size [* (write-elf-max-instr-len) [length generated-expressions]] (write-elf-alignment)])
        (let (max-rela-sec-len [* [length relocations] (elf64-rela)])
        
        (let (text [buffer-alloc max-text-sec-len temp-buf cleanup])
        (let (relas [buffer-alloc max-rela-sec-len temp-buf cleanup])
        (let (rela-ptr (storage _ relas)) (do
        
        [assemble generated-expressions text text-len reg handler]
        
        (foreach (reloc relocations)
          (foreach (loca (@ op-locations (@ reloc-operand reloc)))
            (bind (operand-pos operand-size instr-pos instr-size) loca (do
              (setf r-offset $rela-ptr operand-pos)
              (setf r-info $rela-ptr (elf64-r-info [/[- (@ bndg-context(@ reloc-binding reloc)) syms](elf64-sym)] (@ reloc-type reloc)))
              (setf r-addend $rela-ptr
                [(@ reloc-addend-func reloc) (@ reloc-context reloc) operand-pos operand-size instr-pos instr-size])
              [set+ rela-ptr (elf64-rela)]))))
        
        (ignore Mandatory undefined section)
        (let (undef-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name undef-shdr #0)
        (setf sh-type undef-shdr (sht-null))
        (setf sh-flags undef-shdr #0)
        (setf sh-addr undef-shdr #0)
        (setf sh-offset undef-shdr #0)
        (setf sh-size undef-shdr #0)
        (setf sh-link undef-shdr (shn-undef))
        (setf sh-info undef-shdr #0)
        (setf sh-addralign undef-shdr #0)
        (setf sh-entsize undef-shdr #0)
        [mem-write bin pos undef-shdr (elf64-shdr)]
    
        (let (shstrtab-padded-len [pad-size [strvlen $shstrtab] (write-elf-alignment)])
        (let (shstrtab-padded [buffer-alloc shstrtab-padded-len temp-buf cleanup]) (do
        [memcpy shstrtab-padded $shstrtab [strvlen $shstrtab]]
    
        (let (shstrtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name shstrtab-shdr #1)
        (setf sh-type shstrtab-shdr (sht-strtab))
        (setf sh-flags shstrtab-shdr #0)
        (setf sh-addr shstrtab-shdr #0)
        (setf sh-offset shstrtab-shdr [+ (elf64-ehdr) [* (write-elf-sh-count) (elf64-shdr)]])
        (setf sh-size shstrtab-shdr [strvlen $shstrtab])
        (setf sh-link shstrtab-shdr (shn-undef))
        (setf sh-info shstrtab-shdr #0)
        (setf sh-addralign shstrtab-shdr #0)
        (setf sh-entsize shstrtab-shdr #0)
        [mem-write bin pos shstrtab-shdr (elf64-shdr)]
    
        (let (text-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name text-shdr [+ (@ sh-name shstrtab-shdr) [+ [strlen(" .shstrtab)] #1]])
        (setf sh-type text-shdr (sht-progbits))
        (setf sh-flags text-shdr [lor (shf-alloc) (shf-execinstr)])
        (setf sh-addr text-shdr #0)
        (setf sh-offset text-shdr [+ (@ sh-offset shstrtab-shdr) shstrtab-padded-len])
        (setf sh-size text-shdr $text-len)
        (setf sh-link text-shdr (shn-undef))
        (setf sh-info text-shdr #0)
        (setf sh-addralign text-shdr #1)
        (setf sh-entsize text-shdr #0)
        [mem-write bin pos text-shdr (elf64-shdr)]
    
        (let (strtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name strtab-shdr [+ (@ sh-name text-shdr) [+ [strlen(" .text)] #1]])
        (setf sh-type strtab-shdr (sht-strtab))
        (setf sh-flags strtab-shdr #0)
        (setf sh-addr strtab-shdr #0)
        (setf sh-offset strtab-shdr [+ (@ sh-offset text-shdr) max-text-sec-len])
        (setf sh-size strtab-shdr strtab-len)
        (setf sh-link strtab-shdr (shn-undef))
        (setf sh-info strtab-shdr #0)
        (setf sh-addralign strtab-shdr #0)
        (setf sh-entsize strtab-shdr #0)
        [mem-write bin pos strtab-shdr (elf64-shdr)]
    
        (let (symtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name symtab-shdr [+ (@ sh-name strtab-shdr) [+ [strlen(" .strtab)] #1]])
        (setf sh-type symtab-shdr (sht-symtab))
        (setf sh-flags symtab-shdr #0)
        (setf sh-addr symtab-shdr #0)
        (setf sh-offset symtab-shdr [+ (@ sh-offset strtab-shdr) strtab-padded-len])
        (setf sh-size symtab-shdr [* sym-count (elf64-sym)])
        (setf sh-link symtab-shdr #3)
        (setf sh-info symtab-shdr local-symbol-count)
        (setf sh-addralign symtab-shdr #0)
        (setf sh-entsize symtab-shdr (elf64-sym))
        [mem-write bin pos symtab-shdr (elf64-shdr)]
    
        (let (bss-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name bss-shdr [+ (@ sh-name symtab-shdr) [+ [strlen(" .symtab)] #1]])
        (setf sh-type bss-shdr (sht-nobits))
        (setf sh-flags bss-shdr [lor (shf-write) (shf-alloc)])
        (setf sh-addr bss-shdr #0)
        (setf sh-offset bss-shdr [+ (@ sh-offset symtab-shdr) (@ sh-size symtab-shdr)])
        (setf sh-size bss-shdr $bss-ptr)
        (setf sh-link bss-shdr (shn-undef))
        (setf sh-info bss-shdr #0)
        (setf sh-addralign bss-shdr (word-size))
        (setf sh-entsize bss-shdr #0)
        [mem-write bin pos bss-shdr (elf64-shdr)]
    
        (let (rela-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name rela-shdr [+ (@ sh-name bss-shdr) [+ [strlen(" .bss)] #1]])
        (setf sh-type rela-shdr (sht-rela))
        (setf sh-flags rela-shdr #0)
        (setf sh-addr rela-shdr #0)
        (setf sh-offset rela-shdr [+ (@ sh-offset bss-shdr) #0])
        (setf sh-size rela-shdr [- $rela-ptr relas])
        (setf sh-link rela-shdr #4)
        (setf sh-info rela-shdr #2)
        (setf sh-addralign rela-shdr #0)
        (setf sh-entsize rela-shdr (elf64-rela))
        [mem-write bin pos rela-shdr (elf64-shdr)]
    
        [mem-write bin pos shstrtab-padded shstrtab-padded-len]
        [mem-write bin pos text max-text-sec-len]
        [mem-write bin pos strtab strtab-padded-len]
        [mem-write bin pos syms [* sym-count (elf64-sym)]]
        [mem-write bin pos relas [- $rela-ptr relas]]
        
        (storage _ no-error bin $pos)))))))))))))))))))))))))))))))))))))))))))
        
      (cleanup err (do [destroy-buffer temp-buf return-cont] err))
      
      (return-cont err (if [= (@0 err) no-error] (values (use-storage outs) (@1 err) (@2 err)) {handler err})))))

(ignore
  Converts the offsets of the static bindings associated with L2 source code that has now
  been loaded into addresses. asms is a list of assembly expressions containing bindings
  that need to be converted. bindings is a list of augmented bindings corresponding to the
  assembly expressions that also need to be converted.)

(constrain binding-offsets-to-addresses (\ r (`(function ((list instr) (list bndg-aug) obj) ())r)))

(function binding-offsets-to-addresses (asms static-bindings obj) (do
  (foreach (sym static-bindings)
    (if (and [= (@ bndg-storage sym) (absolute-storage)] [= (@ bndg-state sym) (defined-state)])
      [set+ (& bndg-offset sym) [segment obj (" .bss)]]
      (ignore)))
  
  (foreach (l asms)
    (let (instr-bndg (@ instr-binding l))
      (if [not= instr-bndg null-binding]
        [set+ (& bndg-offset instr-bndg) [segment obj (" .text)]]
        (ignore))))))

