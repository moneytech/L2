(ignore The constants to be used in x86-64-assembler.l2)

(function instr-mod (l r) [=# #6 r])

(function instr-reg (l r) [=# #3 r])

(function instr-rm (l r) [=# #0 r])

(function instr-base (l r) [=# #0 r])

(function instr-index (l r) [=# #3 r])

(function instr-ss (l r) [=# #6 r])

(function rex-w (l r) [=# #3 r])

(function rex-r (l r) [=# #2 r])

(function rex-x (l r) [=# #1 r])

(function rex-b (l r) [=# #0 r])

(function write-elf-sh-count (l r) [=# #7 r])

(function write-elf-alignment (l r) [=# #8 r])

(function write-elf-max-instr-len (l r) [=# #15 r])

(function write-elf-max-instr-fields (l r) [=# #2 r])

(ignore A representation of an object code relocation.)

  (function relocation (l r) [=# #32 r])

  (function reloc-type (l r) [property #0 #8 (\ r (` reloc r)) (\ s r (` reloc-type r)) l r])

  (function reloc-operand (l r) [property #8 #8 (\ r (` reloc r)) (\ s r (` operand r)) l r])

  (function reloc-binding (l r) [property #16 #8 (\ r (` reloc r)) (\ s r (` bndg-aug r)) l r])

  (function reloc-addend (l r) [property #24 #8 (\ r (` reloc r)) (\ s r (with-vars (a b c) (`(function (,b ,c instr) ,a)r)r)) l r])

(ignore A representation of an instruction.)

  (function instruction (l r) [=# #24 r])

  (function instr-code (l r) [property #0 #8 (\ r (` instr r)) (\ s r (` instr-code r)) l r])
  
  (function instr-operands (l r) [property #8 #8 (\ r (` instr r)) (\ s r (` (list operand) r)) l r])
  
  (function instr-binding (l r) [property #16 #8 (\ r (` instr r)) (\ s r (` bndg-aug r)) l r])

(ignore x86-64 instruction codes.)
  
  (function label (l r) [=## #33 (\ r (` instr-code r)) r])

  (function x86-lea (l r) [=## #17 (\ r (` instr-code r)) r])

  (function x86-mov (l r) [=## #18 (\ r (` instr-code r)) r])

  (function x86-jmp (l r) [=## #19 (\ r (` instr-code r)) r])
  
  (function x86-movzx (l r) [=## #20 (\ r (` instr-code r)) r])

  (function x86-push (l r) [=## #21 (\ r (` instr-code r)) r])

  (function x86-sub (l r) [=## #23 (\ r (` instr-code r)) r])

  (function x86-add (l r) [=## #24 (\ r (` instr-code r)) r])

  (function x86-pop (l r) [=## #25 (\ r (` instr-code r)) r])

  (function x86-leave (l r) [=## #26 (\ r (` instr-code r)) r])

  (function x86-ret (l r) [=## #27 (\ r (` instr-code r)) r])

  (function x86-je (l r) [=## #29 (\ r (` instr-code r)) r])

  (function x86-or (l r) [=## #30 (\ r (` instr-code r)) r])

  (function x86-call (l r) [=## #32 (\ r (` instr-code r)) r])
  
  (function x86-mul (l r) [=## #38 (\ r (` instr-code r)) r])
  
  (function x86-shl (l r) [=## #39 (\ r (` instr-code r)) r])
  
  (function x86-shr (l r) [=## #40 (\ r (` instr-code r)) r])
  
  (function x86-and (l r) [=## #41 (\ r (` instr-code r)) r])
  
  (function x86-not (l r) [=## #42 (\ r (` instr-code r)) r])
  
  (function x86-xor (l r) [=## #44 (\ r (` instr-code r)) r])
  
  (function x86-div (l r) [=## #47 (\ r (` instr-code r)) r])
  
  (function x86-setz (l r) [=## #48 (\ r (` instr-code r)) r])
  
  (function x86-setc (l r) [=## #49 (\ r (` instr-code r)) r])

(ignore A representation of an operand.)
  
  (function operand (l r) [=# #64 r])
  
  (function op-type (l r) [property #0 #8 (\ r (` operand r)) (\ s r (` operand-type r)) l r])
  
  (function op-size (l r) [property #8 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-locations (l r) [property #16 #8 (\ r (` operand r)) (\ s r (with-vars (a b) (`(list (values ,a ,b))r)r)) l r])

(ignore Only for type(s) (register-operand))

  (function op-register (l r) [property #24 #8 (\ r (` operand r)) (\ s r (` register r)) l r])

(ignore Only for type(s) (immediate-operand))

  (function op-immediate (l r) [property #24 #8 (\ r (` operand r)) (\ s r [var r]) l r])

(ignore Only for type(s) (memory-operand))

  (function op-base (l r) [property #24 #8 (\ r (` operand r)) (\ s r (` register r)) l r])
  
  (function op-index (l r) [property #32 #8 (\ r (` operand r)) (\ s r (` register r)) l r])
  
  (function op-scale (l r) [property #40 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-disp (l r) [property #48 #8 (\ r (` operand r)) (\ s r [var r]) l r])
  
  (function op-disp-size (l r) [property #56 #8 (\ r (` operand r)) (\ s r [var r]) l r])

(ignore x86-64 operand types.)

  (function register-operand (l r) [=## #0 (\ r (` operand-type r)) r])
  
  (function immediate-operand (l r) [=## #1 (\ r (` operand-type r)) r])
  
  (function memory-operand (l r) [=## #2 (\ r (` operand-type r)) r])

(ignore x86-64 registers.)
  
  (function r/m8 (l r) [=# [<< #1 #5] r])
  
  (function r/m16 (l r) [=# [<< #1 #6] r])
  
  (function r/m32 (l r) [=# [<< #1 #7] r])
  
  (function r/m64 (l r) [=# [<< #1 #8] r])

  (function al (l r) [=## [lor #0(r/m8)] (\ r (` register r)) r])

  (function cl (l r) [=## [lor #1(r/m8)] (\ r (` register r)) r])

  (function dl (l r) [=## [lor #2(r/m8)] (\ r (` register r)) r])

  (function bl (l r) [=## [lor #3(r/m8)] (\ r (` register r)) r])

  (function ah (l r) [=## [lor #4(r/m8)] (\ r (` register r)) r])

  (function ch (l r) [=## [lor #5(r/m8)] (\ r (` register r)) r])

  (function dh (l r) [=## [lor #6(r/m8)] (\ r (` register r)) r])

  (function bh (l r) [=## [lor #7(r/m8)] (\ r (` register r)) r])
  
  (function spl (l r) [=## [lor #4(r/m8)] (\ r (` register r)) r])

  (function bpl (l r) [=## [lor #5(r/m8)] (\ r (` register r)) r])

  (function sil (l r) [=## [lor #6(r/m8)] (\ r (` register r)) r])

  (function dil (l r) [=## [lor #7(r/m8)] (\ r (` register r)) r])

  (function r8l (l r) [=## [lor #8(r/m8)] (\ r (` register r)) r])

  (function r9l (l r) [=## [lor #9(r/m8)] (\ r (` register r)) r])

  (function r10l (l r) [=## [lor #10(r/m8)] (\ r (` register r)) r])

  (function r11l (l r) [=## [lor #11(r/m8)] (\ r (` register r)) r])

  (function r12l (l r) [=## [lor #12(r/m8)] (\ r (` register r)) r])

  (function r13l (l r) [=## [lor #13(r/m8)] (\ r (` register r)) r])

  (function r14l (l r) [=## [lor #14(r/m8)] (\ r (` register r)) r])

  (function r15l (l r) [=## [lor #15(r/m8)] (\ r (` register r)) r])
  
  (function ax (l r) [=## [lor #0(r/m16)] (\ r (` register r)) r])

  (function cx (l r) [=## [lor #1(r/m16)] (\ r (` register r)) r])

  (function dx (l r) [=## [lor #2(r/m16)] (\ r (` register r)) r])

  (function bx (l r) [=## [lor #3(r/m16)] (\ r (` register r)) r])

  (function sp (l r) [=## [lor #4(r/m16)] (\ r (` register r)) r])

  (function bp (l r) [=## [lor #5(r/m16)] (\ r (` register r)) r])

  (function si (l r) [=## [lor #6(r/m16)] (\ r (` register r)) r])

  (function di (l r) [=## [lor #7(r/m16)] (\ r (` register r)) r])
  
  (function r8w (l r) [=## [lor #8(r/m16)] (\ r (` register r)) r])

  (function r9w (l r) [=## [lor #9(r/m16)] (\ r (` register r)) r])

  (function r10w (l r) [=## [lor #10(r/m16)] (\ r (` register r)) r])

  (function r11w (l r) [=## [lor #11(r/m16)] (\ r (` register r)) r])

  (function r12w (l r) [=## [lor #12(r/m16)] (\ r (` register r)) r])

  (function r13w (l r) [=## [lor #13(r/m16)] (\ r (` register r)) r])

  (function r14w (l r) [=## [lor #14(r/m16)] (\ r (` register r)) r])

  (function r15w (l r) [=## [lor #15(r/m16)] (\ r (` register r)) r])
  
  (function eax (l r) [=## [lor #0(r/m32)] (\ r (` register r)) r])

  (function ecx (l r) [=## [lor #1(r/m32)] (\ r (` register r)) r])

  (function edx (l r) [=## [lor #2(r/m32)] (\ r (` register r)) r])

  (function ebx (l r) [=## [lor #3(r/m32)] (\ r (` register r)) r])

  (function esp (l r) [=## [lor #4(r/m32)] (\ r (` register r)) r])

  (function ebp (l r) [=## [lor #5(r/m32)] (\ r (` register r)) r])

  (function esi (l r) [=## [lor #6(r/m32)] (\ r (` register r)) r])

  (function edi (l r) [=## [lor #7(r/m32)] (\ r (` register r)) r])
  
  (function r8d (l r) [=## [lor #8(r/m32)] (\ r (` register r)) r])

  (function r9d (l r) [=## [lor #9(r/m32)] (\ r (` register r)) r])

  (function r10d (l r) [=## [lor #10(r/m32)] (\ r (` register r)) r])

  (function r11d (l r) [=## [lor #11(r/m32)] (\ r (` register r)) r])

  (function r12d (l r) [=## [lor #12(r/m32)] (\ r (` register r)) r])

  (function r13d (l r) [=## [lor #13(r/m32)] (\ r (` register r)) r])

  (function r14d (l r) [=## [lor #14(r/m32)] (\ r (` register r)) r])

  (function r15d (l r) [=## [lor #15(r/m32)] (\ r (` register r)) r])
  
  (function rax (l r) [=## [lor #0(r/m64)] (\ r (` register r)) r])

  (function rcx (l r) [=## [lor #1(r/m64)] (\ r (` register r)) r])

  (function rdx (l r) [=## [lor #2(r/m64)] (\ r (` register r)) r])

  (function rbx (l r) [=## [lor #3(r/m64)] (\ r (` register r)) r])

  (function rsp (l r) [=## [lor #4(r/m64)] (\ r (` register r)) r])

  (function rbp (l r) [=## [lor #5(r/m64)] (\ r (` register r)) r])

  (function rsi (l r) [=## [lor #6(r/m64)] (\ r (` register r)) r])

  (function rdi (l r) [=## [lor #7(r/m64)] (\ r (` register r)) r])

  (function r8 (l r) [=## [lor #8(r/m64)] (\ r (` register r)) r])

  (function r9 (l r) [=## [lor #9(r/m64)] (\ r (` register r)) r])

  (function r10 (l r) [=## [lor #10(r/m64)] (\ r (` register r)) r])

  (function r11 (l r) [=## [lor #11(r/m64)] (\ r (` register r)) r])

  (function r12 (l r) [=## [lor #12(r/m64)] (\ r (` register r)) r])

  (function r13 (l r) [=## [lor #13(r/m64)] (\ r (` register r)) r])

  (function r14 (l r) [=## [lor #14(r/m64)] (\ r (` register r)) r])

  (function r15 (l r) [=## [lor #15(r/m64)] (\ r (` register r)) r])
  
  (function rip (l r) [=## #16 (\ r (` register r)) r])
  
  (function n/a (l r) [=## #17 (\ r (` register r)) r])

(ignore Usage (make-instrN opcode (ops ...) buf handler))

(function make-instrN (l r)
  [llllst (` invoke r) (` make-instruction r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(constrain make-instruction (\ r (with-vars (b) (`(function (instr-code (list operand) buffer ,b) instr)r)r)))

(function make-instruction (code operands reg handler)
  (let (u [buffer-alloc (instruction) reg handler]) (do
    (setf instr-code u code)
    (setf instr-operands u operands)
    (setf instr-binding u null-binding)
    u)))

(constrain make-relocation (\ r (with-vars (a b) (`(function (reloc-type operand bndg-aug ,a buffer ,b) reloc)r)r)))

(function make-relocation (type operand binding addend buf handler)
  (substitute (.. buf handler)
    (let (r [buffer-alloc (relocation) ..]) (do
      (setf reloc-type r type)
      (setf reloc-operand r operand)
      (setf reloc-binding r binding)
      (setf reloc-addend r addend)
      r))))

(constrain make-reg-op (\ r (with-vars (a) (`(function (register buffer ,a) operand)r)r)))

(function make-reg-op (reg buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (register-operand))
      (setf op-size op
        (if [land reg(r/m8)] #1
        (if [land reg(r/m16)] #2
        (if [land reg(r/m32)] #4
        (if [land reg(r/m64)] #8
          (ignore))))))
      (setf op-register op reg)
      (setf op-locations op nil)
      op))))

(constrain make-imm-op (\ r (with-vars (a b c) (`(function (,b ,c buffer ,a) operand)r)r)))

(function make-imm-op (op-size imm buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (immediate-operand))
      (setf op-size op op-size)
      (setf op-immediate op imm)
      (setf op-locations op nil)
      op))))

(constrain make-mem-op (\ r (with-vars (a b c d e) (`(function (,a register register ,b ,c ,d buffer ,e) operand)r)r)))

(function make-mem-op (op-size base index scale disp disp-size buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (memory-operand))
      (setf op-size op op-size)
      (setf op-base op base)
      (setf op-index op index)
      (setf op-scale op scale)
      (setf op-disp op disp)
      (setf op-disp-size op disp-size)
      (setf op-locations op nil)
      op))))

(constrain reg-lower-8 (\ r (`(function (register) register)r)))

(function reg-lower-8 (reg) (switch = reg
  ((ah)(ah)) ((bh)(bh)) ((ch)(ch)) ((dh)(dh)) ((al)(al)) ((bl)(bl)) ((cl)(cl)) ((dl)(dl))
  ((dil)(dil)) ((sil)(sil)) ((bpl) (bpl)) ((spl)(spl)) ((r8l)(r8l)) ((r9l)(r9l)) ((r10l)(r10l))
  ((r11l)(r11l)) ((r12l)(r12l)) ((r13l)(r13l)) ((r14l)(r14l)) ((r15l)(r15l)) ((ax)(al))
  ((bx)(bl)) ((cx)(cl)) ((dx)(dl)) ((di)(dil)) ((si)(sil)) ((bp)(bpl)) ((sp)(spl)) ((r8w)(r8l))
  ((r9w)(r9l)) ((r10w)(r10l)) ((r11w)(r11l)) ((r12w)(r12l)) ((r13w)(r13l)) ((r14w)(r14l))
  ((r15w)(r15l)) ((eax)(al)) ((ebx)(bl)) ((ecx)(cl)) ((edx)(dl)) ((edi)(dl)) ((esi)(sil))
  ((ebp)(bpl)) ((esp)(spl)) ((r8d)(r8l)) ((r9d)(r9l)) ((r10d)(r10l)) ((r11d)(r11l))
  ((r12d)(r12l)) ((r13d)(r13l)) ((r14d)(r14l)) ((r15d)(r15l)) ((rax)(al)) ((rbx)(bl))
  ((rcx)(cl)) ((rdx)(dl)) ((rdi)(dil)) ((rsi)(sil)) ((rbp)(bpl)) ((rsp)(spl)) ((r8)(r8l))
  ((r9)(r9l)) ((r10)(r10l)) ((r11)(r11l)) ((r12)(r12l)) ((r13)(r13l)) ((r14)(r14l))
  ((r15)(r15l)) (ignore)))

(constrain op-lower-8 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-8 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-8 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #1 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #1 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-16 (\ r (`(function (register) register)r)))

(function reg-lower-16 (reg) (switch = reg
  ((ax)(ax)) ((bx)(bx)) ((cx)(cx)) ((dx)(dx)) ((di)(di)) ((si)(si)) ((bp)(bp)) ((sp)(sp))
  ((r8w)(r8w)) ((r9w)(r9w)) ((r10w)(r10w)) ((r11w)(r11w)) ((r12w)(r12w)) ((r13w)(r13w))
  ((r14w)(r14w)) ((r15w)(r15w)) ((eax)(ax)) ((ebx)(bx)) ((ecx)(cx)) ((edx)(dx)) ((edi)(di))
  ((esi)(si)) ((ebp)(bp)) ((esp)(sp)) ((r8d)(r8w)) ((r9d)(r9w)) ((r10d)(r10w)) ((r11d)(r11w))
  ((r12d)(r12w)) ((r13d)(r13w)) ((r14d)(r14w)) ((r15d)(r15w)) ((rax)(ax)) ((rbx)(bx))
  ((rcx)(cx)) ((rdx)(dx)) ((rdi)(di)) ((rsi)(si)) ((rbp)(bp)) ((rsp)(sp)) ((r8)(r8w))
  ((r9)(r9w)) ((r10)(r10w)) ((r11)(r11w)) ((r12)(r12w)) ((r13)(r13w)) ((r14)(r14w))
  ((r15)(r15w)) (ignore)))

(constrain op-lower-16 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-16 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-16 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #2 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #2 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-32 (\ r (`(function (register) register)r)))

(function reg-lower-32 (reg) (switch = reg
  ((eax)(eax)) ((ebx)(ebx)) ((ecx)(ecx)) ((edx)(edx)) ((edi)(edi)) ((esi)(esi)) ((ebp)(ebp))
  ((esp)(esp)) ((r8d)(r8d)) ((r9d)(r9d)) ((r10d)(r10d)) ((r11d)(r11d)) ((r12d)(r12d))
  ((r13d)(r13d)) ((r14d)(r14d)) ((r15d)(r15d)) ((rax)(eax)) ((rbx)(ebx)) ((rcx)(ecx))
  ((rdx)(edx)) ((rdi)(edi)) ((rsi)(esi)) ((rbp)(ebp)) ((rsp)(esp)) ((r8)(r8d)) ((r9)(r9d))
  ((r10)(r10d)) ((r11)(r11d)) ((r12)(r12d)) ((r13)(r13d)) ((r14)(r14d)) ((r15)(r15d))
  (ignore)))

(constrain op-lower-32 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-32 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-32 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #4 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #4 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-64 (\ r (`(function (register) register)r)))

(function reg-lower-64 (reg) (switch = reg
  ((rax)(rax)) ((rbx)(rbx)) ((rcx)(rcx)) ((rdx)(rdx)) ((rdi)(rdi)) ((rsi)(rsi)) ((rbp)(rbp))
  ((rsp)(rsp)) ((r8)(r8)) ((r9)(r9)) ((r10)(r10)) ((r11)(r11)) ((r12)(r12)) ((r13)(r13))
  ((r14)(r14)) ((r15)(r15)) (ignore)))

(constrain op-lower-64 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-64 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-64 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #8 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #8 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain mem-write (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function mem-write (mem idx bytes cnt)
  (let (end [+ $idx cnt])
  (loop write-bytes (bytes bytes)
    (if [= $idx end] (ignore) (do
      [setb [+ mem $idx] [getb bytes]]
      [set+ idx #1]
      {write-bytes [+ bytes #1]})))))

(constrain write-mr-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a (ref ,b) ,c ,d ,e ,f ,g ,h ,i) ())r)r)))

(function write-mr-instr (bin pos opcode opcode-size reg rm m rexw oso)
  (let (mod (if m #2 #3))
  (let (modrm [lor [<< mod (instr-mod)] [lor [<< [land reg (hex 7)] (instr-reg)] [<< [land rm (hex 7)] (instr-rm)]]])
  (let (has-sib (and m (or [= rm (rsp)] [= rm (r12)])))
  (let (sib (if has-sib [lor [<< #4 (instr-index)] [lor [<< [land rm (hex 7)] (instr-base)] [<< #0 (instr-ss)]]] (ignore)))
  (let (rex [<< #4 #4])
  (let (rex (if rexw [lor rex [<< #1 (rex-w)]] rex))
  (let (rex (if [land reg (hex 8)] [lor rex [<< #1 (rex-r)]] rex))
  (let (rex [lor rex [<< #0 (rex-x)]])
  (let (rex (if [land rm (hex 8)] [lor rex [<< #1 (rex-b)]] rex)) (do
  (if oso [mem-write bin pos (storage _ (hex 66)) #1] (ignore))
  [mem-write bin pos (storage _ rex) #1]
  [mem-write bin pos (storage _ opcode) opcode-size]
  [mem-write bin pos (storage _ modrm) #1]
  (if has-sib [mem-write bin pos (storage _ sib) #1] (ignore)))))))))))))

(constrain write-static-value (\ r (with-vars (a b c d e g) (`(function (,a (ref ,b) ,c ,d ,e buffer ,g) ())r)r)))

(function write-static-value (bin pos expr bytes symtab buf handler)
  (substitute (.. buf handler) (do
    [prepend (values (buffer-storage ..) $pos bytes) (& op-locations expr) ..]
    [mem-write bin pos (storage _(@ expr-value expr)) bytes])))

(constrain write-o-instr (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function write-o-instr (bin pos opcode reg)
  (let (rd [land (hex 7) reg])
  (let (opcoderd [+ opcode rd])
  (let (rex [<< #4 #4])
  (let (rex [lor rex [<< #0 (rex-w)]])
  (let (rex [lor rex [<< #0 (rex-r)]])
  (let (rex [lor rex [<< #0 (rex-x)]]) (do
  (if [land reg (hex 8)]
    (let (rex [lor rex [<< #1 (rex-b)]]) [mem-write bin pos (storage _ rex) #1])
    (ignore))
  [mem-write bin pos (storage _ opcoderd) #1]))))))))

(constrain assemble (\ r (with-vars (a b c e) (`(function ((list instr) ,a (ref ,b) ,c buffer ,e) ())r)r)))

(ignore(function assemble (generated-expressions bin pos symtab buf handler)
  (substitute (.. buf handler) (do
    [set pos #0]
    (foreach (n generated-expressions) (do
      (let (instr-bndg (@ instr-binding n))
        (if [not= instr-bndg null-binding] (do
          (setf bndg-storage instr-bndg (instruction-storage))
          (setf bndg-offset instr-bndg $pos)
          (setf st-value (@ bndg-context instr-bndg) $pos))
          (ignore)))
          
      (switch = (@ instr-code n)
        ((label) (ignore))
          
        ((leaq-mdb-to-reg)
          (let (opcode (hex 8D))
          (let (reg (@ instr-code [@caddr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (true) (false)]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))))
          
        ((movq-reg-to-mdb)
          (let (opcode (hex 89))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          (let (rm (@ instr-code [@caddr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (true) (false)]
          [write-static-value bin pos [@cadr (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movb-reg-to-mdb)
          (let (opcode (hex 88))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          (let (rm (@ instr-code [@caddr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (false)]
          [write-static-value bin pos [@cadr (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movw-reg-to-mdb)
          (let (opcode (hex 89))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          (let (rm (@ instr-code [@caddr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (true)]
          [write-static-value bin pos [@cadr (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movl-reg-to-mdb)
          (let (opcode (hex 89))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          (let (rm (@ instr-code [@caddr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (false)]
          [write-static-value bin pos [@cadr (@ expr-arguments n)] #4 symtab ..])))))
        
        ((jmp-rel)
          (let (opcode (hex E9)) (do
          [mem-write bin pos (storage _ opcode) #1]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))
          
        ((movq-mdb-to-reg)
          (let (opcode (hex 8B))
          (let (reg (@ instr-code [@caddr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (true) (false)]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movb-mdb-to-reg)
          (let (opcode (hex 8A))
          (let (reg (@ instr-code [@caddr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (false)]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movw-mdb-to-reg)
          (let (opcode (hex 8B))
          (let (reg (@ instr-code [@caddr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (true)]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))))
        
        ((movl-mdb-to-reg)
          (let (opcode (hex 8B))
          (let (reg (@ instr-code [@caddr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (true) (false) (false)]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..])))))
        
        ((pushq-reg)
          (let (opcode (hex 50))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          [write-o-instr bin pos opcode reg])))
          
        ((movq-reg-to-reg)
          (let (opcode (hex 8B))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
          
        ((subq-imm-to-reg)
          (let (opcode (hex 81))
          (let (reg #5)
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]
          [mem-write bin pos (& expr-value [@car (@ expr-arguments n)]) #4])))))
          
        ((addq-imm-to-reg)
          (let (opcode (hex 81))
          (let (reg #0)
          (let (rm (@ instr-code [@cadr (@ expr-arguments n)])) (do
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]
          [mem-write bin pos (& expr-value [@car (@ expr-arguments n)]) #4])))))
          
        ((popq-reg)
          (let (opcode (hex 58))
          (let (reg (@ instr-code [@car (@ expr-arguments n)]))
          [write-o-instr bin pos opcode reg])))
          
        ((leave) [mem-write bin pos (storage opcode (hex C9)) #1])
          
        ((ret) [mem-write bin pos (storage opcode (hex C3)) #1])
          
        ((jmp-to-reg)
          (let (opcode (hex FF))
          (let (reg #4)
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (false) (false)]))))
          
        ((je-rel) (do
          [mem-write bin pos (storage opcode1 (hex 0F)) #1]
          [mem-write bin pos (storage opcode2 (hex 84)) #1]
          [write-static-value bin pos [@car (@ expr-arguments n)] #4 symtab ..]))
          
        ((orq-reg-to-reg)
          (let (opcode (hex 0B))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((xorq-reg-to-reg)
          (let (opcode (hex 33))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((andq-reg-to-reg)
          (let (opcode (hex 23))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((addq-reg-to-reg)
          (let (opcode (hex 03))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((subq-reg-to-reg)
          (let (opcode (hex 2B))
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((mulq-reg)
          (let (opcode (hex F7))
          (let (reg (hex 04))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((setz-reg)
          (let (opcode (hex 940F))
          (let (reg (hex 00))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #2 reg rm (false) (false) (false)]))))
        
        ((setc-reg)
          (let (opcode (hex 920F))
          (let (reg (hex 00))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #2 reg rm (false) (false) (false)]))))
        
        ((divq-reg)
          (let (opcode (hex F7))
          (let (reg (hex 06))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((notq-reg)
          (let (opcode (hex F7))
          (let (reg (hex 02))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((shlq-cl-to-reg)
          (let (opcode (hex D3))
          (let (reg (hex 04))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((shrq-cl-to-reg)
          (let (opcode (hex D3))
          (let (reg (hex 05))
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (true) (false)]))))
        
        ((movq-imm-to-reg)
          (let (opcode (hex B8))
          (let (imm-expr [@car (@ expr-arguments n)])
          (let (reg (@ instr-code [@cadr (@ expr-arguments n)]))
          (let (rd [land (hex 7) reg])
          (let (opcoderd [+ opcode rd])
          (let (rex [<< #4 #4])
          (let (rex [lor rex [<< #1 (rex-w)]])
          (let (rex [lor rex [<< #0 (rex-r)]])
          (let (rex [lor rex [<< #0 (rex-x)]])
          (let (rex (if [land reg (hex 8)] [lor rex [<< #1 (rex-b)]] rex)) (do
          [mem-write bin pos (storage _ rex) #1]
          [mem-write bin pos (storage _ opcoderd) #1]
          [write-static-value bin pos imm-expr #8 symtab ..]))))))))))))
          
        ((call-reg)
          (let (opcode (hex FF))
          (let (reg #2)
          (let (rm (@ instr-code [@car (@ expr-arguments n)]))
          [write-mr-instr bin pos opcode #1 reg rm (false) (false) (false)]))))
        
        (ignore))))))))

(storage shstrtab ("(nul).shstrtab(nul).text(nul).strtab(nul).symtab(nul).bss(nul).rela.text(nul)))

(constrain measure-strtab (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-strtab (generated-expressions undefined-bindings static-bindings)
  (let (undefined-bindings-len (fold (acc #0) (sym undefined-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (static-bindings-len (fold (acc #0) (sym static-bindings)
        [+ acc (if [not= (@ bndg-name sym) null-string]
          [+ [strlen(@ bndg-name sym)] #1]
          #0)]))
      (generated-expressions-len (fold (acc #0) (e generated-expressions)
        [+ acc (let (instr-bndg (@ instr-binding e)) (if [not= instr-bndg null-binding]
          (let (label-str (@ bndg-name instr-bndg))
            (if [not= label-str null-string] [+ [strlen label-str] #1] #0))
          #0))]))
    [+ #1 [+ undefined-bindings-len [+ static-bindings-len generated-expressions-len]]]))

(constrain measure-symtab (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function measure-symtab (generated-expressions undefined-bindings static-bindings)
  (let (generated-expressions-len
        (fold (acc #0) (e generated-expressions) [+ acc (if [not= (@ instr-binding e) null-binding] #1 #0)]))
    [+ #1 [+ generated-expressions-len [+ [length undefined-bindings] [length static-bindings]]]]))

(constrain max-elf-size (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) (list bndg-aug)) ,a)r)r)))

(function max-elf-size (generated-expressions undefined-bindings static-bindings)
  [+ (elf64-ehdr) [+ [* (elf64-shdr) (write-elf-sh-count)] [+ [pad-size [strvlen $shstrtab] (write-elf-alignment)]
    [+ [pad-size [* (write-elf-max-instr-len) [length generated-expressions]] (write-elf-alignment)]
    [+ [pad-size [measure-strtab generated-expressions undefined-bindings static-bindings] (write-elf-alignment)]
    [+ [* (elf64-sym) [measure-symtab generated-expressions undefined-bindings static-bindings]]
    [* (elf64-rela) [* (write-elf-max-instr-fields) [length generated-expressions]]]]]]]]])

(ignore
  Takes assembly code and a list of symbols as constructs an object file.
  generated-expressions is a list of assembly expressions. symbols is a list of the static
  symbols used in the assembly expressions. reg is the buffer into which the generated
  object code should be put. Returns a pair containing a reference to the generated object
  code and the size of the generated object code.)

(constrain write-elf (\ r (with-vars (a b c d) (`(function ((list expr) (list reloc) (list bndg-aug) (list bndg-aug) ,a buffer ,c)
  (values ,b ,d))r)r)))

(function write-elf (generated-expressions relocations undefined-bindings static-bindings outs reg handler)
  (let (temp-buf [create-buffer #0 handler])
    (fallthrough
      (do
        (let (pos (storage _ #0))
        (let (bin [buffer-alloc [max-elf-size generated-expressions undefined-bindings static-bindings] reg cleanup])
        
        (let (ehdr [buffer-alloc (elf64-ehdr) temp-buf cleanup]) (do
        (setf ei-mag0 (& e-ident ehdr) (elfmag0))
        (setf ei-mag1 (& e-ident ehdr) (elfmag1))
        (setf ei-mag2 (& e-ident ehdr) (elfmag2))
        (setf ei-mag3 (& e-ident ehdr) (elfmag3))
        (setf ei-class (& e-ident ehdr) (elfclass64))
        (setf ei-data (& e-ident ehdr) (elfdata2lsb))
        (setf ei-version (& e-ident ehdr) #1)
        (setf ei-osabi (& e-ident ehdr) (elfosabi-sysv))
        (setf ei-abiversion (& e-ident ehdr) #0)
    
        (until (i #7) [= i (ei-nident)] [+ i #1] [setb (loc(byte)i(& e-ident ehdr)) #0])
    
        (setf e-type ehdr (et-rel))
        (setf e-machine ehdr (em-x86-64))
        (setf e-version ehdr #1)
        (setf e-entry ehdr #0)
        (setf e-phoff ehdr #0)
        (setf e-shoff ehdr (elf64-ehdr))
        (setf e-flags ehdr #0)
        (setf e-ehsize ehdr (elf64-ehdr))
        (setf e-phentsize ehdr #0)
        (setf e-phnum ehdr #0)
        (setf e-shentsize ehdr (elf64-shdr))
        (setf e-shnum ehdr (write-elf-sh-count))
        (setf e-shstrndx ehdr #1)
        [mem-write bin pos ehdr (elf64-ehdr)]
        
        (let (strtab-len [measure-strtab generated-expressions undefined-bindings static-bindings])
        (let (sym-count [measure-symtab generated-expressions undefined-bindings static-bindings])
    
        (let (syms [buffer-alloc [* sym-count (elf64-sym)] temp-buf cleanup])
        (let (sym-ptr (storage _ syms)) (do
        (ignore Mandatory undefined symbol)
        (setf st-name $sym-ptr #0)
        (setf st-value $sym-ptr #0)
        (setf st-size $sym-ptr #0)
        (setf st-info $sym-ptr #0)
        (setf st-other $sym-ptr #0)
        (setf st-shndx $sym-ptr (shn-undef))
        [set+ sym-ptr (elf64-sym)]
    
        (let (strtab-padded-len [pad-size strtab-len (write-elf-alignment)])
        (let (strtab [buffer-alloc strtab-padded-len temp-buf cleanup])
        (let (strtabptr (storage _ strtab)) (do
        [setb $strtabptr #0]
        [set+ strtabptr #1]
    
        (let (bss-ptr (storage _ #0)) (do
    
        (foreach (sym static-bindings) (do
          (if [= (@ bndg-scope sym) (local-scope)] (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore))
          [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]]))
    
        (foreach (e generated-expressions)
          (let (instr-bndg (@ instr-binding e))
            (if (and [not= instr-bndg null-binding] [= (@ bndg-scope instr-bndg) (local-scope)]) (do
              (if [not= (@ bndg-name instr-bndg) null-string]
                (do
                  [strcpy $strtabptr (@ bndg-name instr-bndg)]
                  (setf st-name $sym-ptr [- $strtabptr strtab])
                  [set+ strtabptr [+[strlen(@ bndg-name instr-bndg)]#1]])
                (setf st-name $sym-ptr #0))
          
              (setf st-value $sym-ptr #0)
              (setf st-size $sym-ptr #0)
              (setf st-info $sym-ptr (elf64-st-info (stb-local) (stt-notype)))
              (setf st-other $sym-ptr #0)
              (setf st-shndx $sym-ptr #2)
              (setf bndg-context instr-bndg $sym-ptr)
              [set+ sym-ptr (elf64-sym)])
              (ignore))))
    
        (let (local-symbol-count [/[- $sym-ptr syms](elf64-sym)]) (do
        
        (ignore Reset bss-ptr to #0 and fill in the gaps between the local symbols.)
        [set bss-ptr #0]
        
        (foreach (sym static-bindings) (do
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (defined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr $bss-ptr)
            (setf bndg-offset sym $bss-ptr)
            (setf st-size $sym-ptr (@ bndg-size sym))
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr #5)
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore))
          [set+ bss-ptr [pad-size (@ bndg-size sym) (word-size)]]))
    
        (foreach (sym undefined-bindings)
          (if (and [= (@ bndg-scope sym) (global-scope)] [= (@ bndg-state sym) (undefined-state)]) (do
            (if [not= (@ bndg-name sym) null-string]
              (do
                [strcpy $strtabptr (@ bndg-name sym)]
                (setf st-name $sym-ptr [- $strtabptr strtab])
                [set+ strtabptr [+[strlen(@ bndg-name sym)]#1]])
              (setf st-name $sym-ptr #0))
        
            (setf st-value $sym-ptr #0)
            (setf st-size $sym-ptr #0)
            (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
            (setf st-other $sym-ptr #0)
            (setf st-shndx $sym-ptr (shn-undef))
            (setf bndg-context sym $sym-ptr)
            [set+ sym-ptr (elf64-sym)])
            (ignore)))
    
        (foreach (e generated-expressions)
          (let (instr-bndg (@ instr-binding e))
            (if (and [not= instr-bndg null-binding] [= (@ bndg-scope instr-bndg) (global-scope)]) (do
              (if [not= (@ bndg-name instr-bndg) null-string]
                (do
                  [strcpy $strtabptr (@ bndg-name instr-bndg)]
                  (setf st-name $sym-ptr [- $strtabptr strtab])
                  [set+ strtabptr [+[strlen(@ bndg-name instr-bndg)]#1]])
                (setf st-name $sym-ptr #0))
          
              (setf st-value $sym-ptr #0)
              (setf st-size $sym-ptr #0)
              (setf st-info $sym-ptr (elf64-st-info (stb-global) (stt-notype)))
              (setf st-other $sym-ptr #0)
              (setf st-shndx $sym-ptr #2)
              (setf bndg-context instr-bndg $sym-ptr)
              [set+ sym-ptr (elf64-sym)])
              (ignore))))
    
        (let (text-len (storage _ (ignore)))
        (let (max-text-sec-len [pad-size [* (write-elf-max-instr-len) [length generated-expressions]] (write-elf-alignment)])
        (let (max-rela-sec-len [* [length relocations] (elf64-rela)])
        
        (let (text [buffer-alloc max-text-sec-len temp-buf cleanup])
        (let (relas [buffer-alloc max-rela-sec-len temp-buf cleanup])
        (let (rela-ptr (storage _ relas)) (do
        
        [assemble generated-expressions text text-len syms reg handler]
        
        (foreach (reloc relocations)
          (foreach (loca (@ op-locations (@ reloc-operand reloc)))
            (bind (offset size) loca (do
              (setf r-offset $rela-ptr offset)
              (setf r-info $rela-ptr (elf64-r-info [/[- (@ bndg-context(@ reloc-binding reloc)) syms](elf64-sym)] (@ reloc-type reloc)))
              (setf r-addend $rela-ptr (@ reloc-addend reloc))
              [set+ rela-ptr (elf64-rela)]))))
        
        (ignore Mandatory undefined section)
        (let (undef-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name undef-shdr #0)
        (setf sh-type undef-shdr (sht-null))
        (setf sh-flags undef-shdr #0)
        (setf sh-addr undef-shdr #0)
        (setf sh-offset undef-shdr #0)
        (setf sh-size undef-shdr #0)
        (setf sh-link undef-shdr (shn-undef))
        (setf sh-info undef-shdr #0)
        (setf sh-addralign undef-shdr #0)
        (setf sh-entsize undef-shdr #0)
        [mem-write bin pos undef-shdr (elf64-shdr)]
    
        (let (shstrtab-padded-len [pad-size [strvlen $shstrtab] (write-elf-alignment)])
        (let (shstrtab-padded [buffer-alloc shstrtab-padded-len temp-buf cleanup]) (do
        [memcpy shstrtab-padded $shstrtab [strvlen $shstrtab]]
    
        (let (shstrtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name shstrtab-shdr #1)
        (setf sh-type shstrtab-shdr (sht-strtab))
        (setf sh-flags shstrtab-shdr #0)
        (setf sh-addr shstrtab-shdr #0)
        (setf sh-offset shstrtab-shdr [+ (elf64-ehdr) [* (write-elf-sh-count) (elf64-shdr)]])
        (setf sh-size shstrtab-shdr [strvlen $shstrtab])
        (setf sh-link shstrtab-shdr (shn-undef))
        (setf sh-info shstrtab-shdr #0)
        (setf sh-addralign shstrtab-shdr #0)
        (setf sh-entsize shstrtab-shdr #0)
        [mem-write bin pos shstrtab-shdr (elf64-shdr)]
    
        (let (text-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name text-shdr [+ (@ sh-name shstrtab-shdr) [+ [strlen(" .shstrtab)] #1]])
        (setf sh-type text-shdr (sht-progbits))
        (setf sh-flags text-shdr [lor (shf-alloc) (shf-execinstr)])
        (setf sh-addr text-shdr #0)
        (setf sh-offset text-shdr [+ (@ sh-offset shstrtab-shdr) shstrtab-padded-len])
        (setf sh-size text-shdr $text-len)
        (setf sh-link text-shdr (shn-undef))
        (setf sh-info text-shdr #0)
        (setf sh-addralign text-shdr #1)
        (setf sh-entsize text-shdr #0)
        [mem-write bin pos text-shdr (elf64-shdr)]
    
        (let (strtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name strtab-shdr [+ (@ sh-name text-shdr) [+ [strlen(" .text)] #1]])
        (setf sh-type strtab-shdr (sht-strtab))
        (setf sh-flags strtab-shdr #0)
        (setf sh-addr strtab-shdr #0)
        (setf sh-offset strtab-shdr [+ (@ sh-offset text-shdr) max-text-sec-len])
        (setf sh-size strtab-shdr strtab-len)
        (setf sh-link strtab-shdr (shn-undef))
        (setf sh-info strtab-shdr #0)
        (setf sh-addralign strtab-shdr #0)
        (setf sh-entsize strtab-shdr #0)
        [mem-write bin pos strtab-shdr (elf64-shdr)]
    
        (let (symtab-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name symtab-shdr [+ (@ sh-name strtab-shdr) [+ [strlen(" .strtab)] #1]])
        (setf sh-type symtab-shdr (sht-symtab))
        (setf sh-flags symtab-shdr #0)
        (setf sh-addr symtab-shdr #0)
        (setf sh-offset symtab-shdr [+ (@ sh-offset strtab-shdr) strtab-padded-len])
        (setf sh-size symtab-shdr [* sym-count (elf64-sym)])
        (setf sh-link symtab-shdr #3)
        (setf sh-info symtab-shdr local-symbol-count)
        (setf sh-addralign symtab-shdr #0)
        (setf sh-entsize symtab-shdr (elf64-sym))
        [mem-write bin pos symtab-shdr (elf64-shdr)]
    
        (let (bss-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name bss-shdr [+ (@ sh-name symtab-shdr) [+ [strlen(" .symtab)] #1]])
        (setf sh-type bss-shdr (sht-nobits))
        (setf sh-flags bss-shdr [lor (shf-write) (shf-alloc)])
        (setf sh-addr bss-shdr #0)
        (setf sh-offset bss-shdr [+ (@ sh-offset symtab-shdr) (@ sh-size symtab-shdr)])
        (setf sh-size bss-shdr $bss-ptr)
        (setf sh-link bss-shdr (shn-undef))
        (setf sh-info bss-shdr #0)
        (setf sh-addralign bss-shdr (word-size))
        (setf sh-entsize bss-shdr #0)
        [mem-write bin pos bss-shdr (elf64-shdr)]
    
        (let (rela-shdr [buffer-alloc (elf64-shdr) temp-buf cleanup]) (do
        (setf sh-name rela-shdr [+ (@ sh-name bss-shdr) [+ [strlen(" .bss)] #1]])
        (setf sh-type rela-shdr (sht-rela))
        (setf sh-flags rela-shdr #0)
        (setf sh-addr rela-shdr #0)
        (setf sh-offset rela-shdr [+ (@ sh-offset bss-shdr) #0])
        (setf sh-size rela-shdr [- $rela-ptr relas])
        (setf sh-link rela-shdr #4)
        (setf sh-info rela-shdr #2)
        (setf sh-addralign rela-shdr #0)
        (setf sh-entsize rela-shdr (elf64-rela))
        [mem-write bin pos rela-shdr (elf64-shdr)]
    
        [mem-write bin pos shstrtab-padded shstrtab-padded-len]
        [mem-write bin pos text max-text-sec-len]
        [mem-write bin pos strtab strtab-padded-len]
        [mem-write bin pos syms [* sym-count (elf64-sym)]]
        [mem-write bin pos relas [- $rela-ptr relas]]
        
        (storage _ no-error bin $pos)))))))))))))))))))))))))))))))))))))))))))
        
      (cleanup err (do [destroy-buffer temp-buf return-cont] err))
      
      (return-cont err (if [= (@0 err) no-error] (values (use-storage outs) (@1 err) (@2 err)) {handler err})))))

(ignore
  Converts the offsets of the static bindings associated with L2 source code that has now
  been loaded into addresses. asms is a list of assembly expressions containing bindings
  that need to be converted. bindings is a list of augmented bindings corresponding to the
  assembly expressions that also need to be converted.)

(constrain binding-offsets-to-addresses (\ r (`(function ((list expr) (list bndg-aug) obj) ())r)))

(function binding-offsets-to-addresses (asms static-bindings obj) (do
  (foreach (sym static-bindings)
    (if (and [= (@ bndg-storage sym) (absolute-storage)] [= (@ bndg-state sym) (defined-state)])
      [set+ (& bndg-offset sym) [segment obj (" .bss)]]
      (ignore)))
  
  (foreach (l asms)
    (let (instr-bndg (@ instr-binding l))
      (if [not= instr-bndg null-binding]
        [set+ (& bndg-offset instr-bndg) [segment obj (" .text)]]
        (ignore))))))

