(;; Compiles a program into a list of assembly expressions. bindings is a reference to a
  list into which the augmented bindings of the generated code will be put.)

(constrain compile-program
  (\ r (with-vars (a) (`(function ((list expr) (ref (list bndg-aug)) (ref (list bndg-aug)) buffer ,a) (list expr))r)r)))

(function compile-program (exprs undefined-bindings static-bindings buf handler)
  (substitute (.. buf handler) (do
    [set static-bindings nil]
    [set undefined-bindings nil]
    (let (global-bindings [global-binding-augs-of exprs ..]) (do
      (foreach (expr exprs) (do
        [visit-expressions vfind-multiple-definitions (storage _ expr) (values handler)]
        [containment-analysis expr]
        [classify-program-bindings expr]
        [link-symbols expr (true) undefined-bindings global-bindings nil ..]
        (;;[infer-types expr ..])
        [escape-analysis expr (true)]
        [layout-frames expr static-bindings ..]))))
    [generate-program exprs ..])))

(;; Loads a program into memory and returns a handle to it. program is a program expression.
  expr-buf is the buffer into which the results of compilation will be put. obj-buf is the
  buffer into which the object code will be put. Return value is an object.)

(constrain load-program (\ r (with-vars (a) (`(function ((list expr) buffer ,a) obj)r)r)))

(function load-program (exprs buf handler)
  (let (static-bindings (storage _ (undefined)))
  (let (undefined-bindings (storage _ (undefined)))
  (let (asms [compile-program exprs undefined-bindings static-bindings buf handler])
  (let (objdest (storage _ (undefined)))
  (let (objdest-sz (storage _ (undefined))) (do
  [write-elf asms $undefined-bindings $static-bindings objdest objdest-sz buf handler]
  (let (obj [load $objdest $objdest-sz buf handler]) (do
  [binding-offsets-to-addresses asms $static-bindings obj]
  obj)))))))))

(;; Behavior is the same as load-program, but with the following addition: bndgs is a list
  of object bindings, and after the loading is done, the undefined bindings of the loaded
  program will take on the addresses supplied in the list. The handler continuation is
  followed, and the error buffer referenced by err set to the pair (undefined-symbol-error,
  <missing binding name>) if there is an undefined binding in the program that is not defined
  in bndgs.)

(constrain load-program-and-mutate (\ r (with-vars (a) (`(function ((list expr) (list bndg-aug) buffer ,a) obj)r)r)))

(function load-program-and-mutate (exprs bndgs buf handler)
  (let (obj [load-program exprs buf handler])
  (let (temp-reg [create-buffer #0 handler])
  (let (ms [mutable-bindings obj temp-reg handler]) (do
    (foreach (d ms)
      (if [nil? (find (x bndgs) [str= (@ bndg-name d) (@ bndg-name x)])]
        (do
          (let (missing-bndg-name (@ bndg-name d)) (do
          [destroy-buffer temp-reg handler]
          {handler (storage _ undefined-symbol-error missing-bndg-name)})))
        (undefined)))
    
    [destroy-buffer temp-reg handler]
    [mutate-bindings obj bndgs]
    obj)))))

(constrain read-to-buffer (\ r (with-vars (a b d) (`(function (string ,a buffer ,b) ,d)r)r)))

(function read-to-buffer (fn size-out buf handler)
  (let (fd [open fn handler])
    (fallthrough
      (do
        [set size-out [size fd close-file]]
        (let (src-buf [buffer-alloc $size-out buf close-file]) (do
        [read fd src-buf $size-out close-file]
        (storage _ no-error src-buf))))
        
      (close-file err (do
        [close fd handler]
        (if [= (@0 err) no-error] (@1 err) {handler err}))))))

(;; Reads a list of expressions from a given file. fn is a string containing the filename.
  buf is the buffer into which the constructed expressions will be put. Return value is a
  list of expressions.)

(constrain read-expressions (\ r (with-vars (a) (`(function (string buffer ,a) (list expr))r)r)))

(function read-expressions (fn buf handler)
  (substitute (.. buf handler)
    (let (src-sz (storage _ (undefined)))
    (let (src-buf [read-to-buffer fn src-sz ..])
    (let (pos (storage _ #0))
      (loop cons-expr (expressions nil)
        (if [after-leading-space src-buf $src-sz pos]
          {cons-expr [cons [build-expression [build-fragment src-buf $src-sz pos ..] null-expr ..] expressions ..]}
          [reverse expressions ..])))))))

(;; Takes a list of L2 and object file names, loads their contents into memory, and links
  them together. The global symbols of the object code are then added to the list of
  bindings.)

(constrain evaluate-files (\ r (with-vars (a) (`(function ((list string) (list string) (ref (list bndg-aug)) buffer ,a) ())r)r)))

(function evaluate-files (source-fns object-fns bindings buf handler)
  (substitute (.. buf handler)
    (let (objects1 (fold (objects nil) (src source-fns)
      (let (obj [load-program [generate-metaprogram [read-expressions src ..] bindings ..] ..])
        (do [append-list bindings [immutable-bindings obj ..]] [cons obj objects ..]))))
    
    (let (objects2 (fold (objects objects1) (src object-fns)
      (let (obj-sz (storage _ (undefined)))
      (let (obj-buf (storage _ [read-to-buffer src obj-sz ..]))
      (let (obj [load $obj-buf $obj-sz ..])
        (do [append-list bindings [immutable-bindings obj ..]] [cons obj objects ..]))))))
      
    (foreach (obj objects2) [mutate-bindings obj $bindings])))))

(;; Takes a list of L2 source files and compiles them into object files. programs is a
  list of strings containing paths to L2 source files. bndgs is a list of bindings
  pointing to the macros to be used during the meta-expression expansions. expr-buf
  is the buffer into which constructed expressions will be put. obj-buf is the buffer
  into which object code will be put.)

(constrain compile-files (\ r (with-vars (a) (`(function ((list string) (list bndg-aug) buffer ,a) ())r)r)))

(function compile-files (file-names bndgs buf handler)
  (substitute (.. buf handler)
    (let (file-exprss [reverse (reverse-map (infn file-names)
        [reverse (reverse-map (e [read-expressions infn ..])
          (let (f (storage _ e))
            (do [pre-visit-expressions vgenerate-metas f (values bndgs ..)] $f)) ..) ..] ..) ..])
      (do
        (let (all-exprs [reverse-flatten file-exprss ..])
        (let (undefined-bindings (storage _ nil))
        (let (global-bindings [global-binding-augs-of all-exprs ..]) (do
          (foreach (expr all-exprs) [link-symbols expr (true) undefined-bindings global-bindings nil ..])
          [infer-types all-exprs ..]
          (foreach (expr all-exprs) [pre-visit-expressions vunlink-symbols (storage _ expr) (values global-bindings)])
          (foreach (expr all-exprs) [pre-visit-expressions vunlink-symbols (storage _ expr) (values $undefined-bindings)])))))
        
        (foreach (infn file-names) (exprs file-exprss)
          (let (undefined-bindings (storage _ (undefined)))
          (let (static-bindings (storage _ (undefined)))
          (let (asms [compile-program exprs undefined-bindings static-bindings buf handler])
          (let (objdest (storage _ (undefined)))
          (let (objdest-sz (storage _ (undefined))) (do
          [write-elf asms $undefined-bindings $static-bindings objdest objdest-sz buf handler]
          (let (outfn [buffer-alloc [+ [strlen infn] #1] buf handler]) (do
          [strcpy outfn infn]
          [strcpy [strrchr outfn (char .)] (" .o)]
          (let (fd [create outfn handler]) (do
          [print fd $objdest $objdest-sz handler]
          [close fd handler])))))))))))))))

(storage arguments-error (undefined))

(storage no-error (undefined))

(;; This is where program execution starts. The following code essentially loads up and
  executes the code specified in the command line arguments and then compiles the
  separately specified code using the already loaded up functions as macros. It also
  prints out the error messages if there are any.)

(fallthrough
    (let (buf [create-buffer #0 exit-cont])
    (fallthrough
        (do
          (let (source-fns [@cdr[argv buf handler]])
          (let (dash-list-ref (locate (arg (storage _ source-fns)) [str= arg (" -)]))
          (if [nil? $dash-list-ref] {handler (storage _ arguments-error)}
          (let (object-fns [@cdr $dash-list-ref]) (do
          (;; Cut the source filenames list short.)
          [set dash-list-ref nil]
          (;; These are all the bindings necessary for metaprogramming. Their
            definitions can be found in list.l2 and lexer.l2.)
          (let (bndgs (storage _ (substitute (.. buf handler) (list
            ([make-binding (" -!-)(tkn-char(char !))..]
            [make-binding (" -!-)(tkn-char(char !))..]
            [make-binding (" -"-)(tkn-char(char "))..]
            [make-binding (" -#-)(tkn-char(char #))..]
            [make-binding (" -$-)(tkn-char(char $))..]
            [make-binding (" -%-)(tkn-char(char %))..]
            [make-binding (" -&-)(tkn-char(char &))..]
            [make-binding (" -'-)(tkn-char(char '))..]
            [make-binding (" -*-)(tkn-char(char *))..]
            [make-binding (" -+-)(tkn-char(char +))..]
            [make-binding (" -,-)(tkn-char(char ,))..]
            [make-binding (" ---)(tkn-char(char -))..]
            [make-binding (" -.-)(tkn-char(char .))..]
            [make-binding (" -/-)(tkn-char(char /))..]
            [make-binding (" -0-)(tkn-char(char 0))..]
            [make-binding (" -1-)(tkn-char(char 1))..]
            [make-binding (" -2-)(tkn-char(char 2))..]
            [make-binding (" -3-)(tkn-char(char 3))..]
            [make-binding (" -4-)(tkn-char(char 4))..]
            [make-binding (" -5-)(tkn-char(char 5))..]
            [make-binding (" -6-)(tkn-char(char 6))..]
            [make-binding (" -7-)(tkn-char(char 7))..]
            [make-binding (" -8-)(tkn-char(char 8))..]
            [make-binding (" -9-)(tkn-char(char 9))..]
            [make-binding (" -:-)(tkn-char(char :))..]
            [make-binding (" -;-)(tkn-char(char ;))..]
            [make-binding (" -<-)(tkn-char(char <))..]
            [make-binding (" -=-)(tkn-char(char =))..]
            [make-binding (" ->-)(tkn-char(char >))..]
            [make-binding (" -?-)(tkn-char(char ?))..]
            [make-binding (" -@-)(tkn-char(char @))..]
            [make-binding (" -A-)(tkn-char(char A))..]
            [make-binding (" -B-)(tkn-char(char B))..]
            [make-binding (" -C-)(tkn-char(char C))..]
            [make-binding (" -D-)(tkn-char(char D))..]
            [make-binding (" -E-)(tkn-char(char E))..]
            [make-binding (" -F-)(tkn-char(char F))..]
            [make-binding (" -G-)(tkn-char(char G))..]
            [make-binding (" -H-)(tkn-char(char H))..]
            [make-binding (" -I-)(tkn-char(char I))..]
            [make-binding (" -J-)(tkn-char(char J))..]
            [make-binding (" -K-)(tkn-char(char K))..]
            [make-binding (" -L-)(tkn-char(char L))..]
            [make-binding (" -M-)(tkn-char(char M))..]
            [make-binding (" -N-)(tkn-char(char N))..]
            [make-binding (" -O-)(tkn-char(char O))..]
            [make-binding (" -P-)(tkn-char(char P))..]
            [make-binding (" -Q-)(tkn-char(char Q))..]
            [make-binding (" -R-)(tkn-char(char R))..]
            [make-binding (" -S-)(tkn-char(char S))..]
            [make-binding (" -T-)(tkn-char(char T))..]
            [make-binding (" -U-)(tkn-char(char U))..]
            [make-binding (" -V-)(tkn-char(char V))..]
            [make-binding (" -W-)(tkn-char(char W))..]
            [make-binding (" -X-)(tkn-char(char X))..]
            [make-binding (" -Y-)(tkn-char(char Y))..]
            [make-binding (" -Z-)(tkn-char(char Z))..]
            [make-binding (" -\-)(tkn-char(char \))..]
            [make-binding (" -^-)(tkn-char(char ^))..]
            [make-binding (" -_-)(tkn-char(char _))..]
            [make-binding (" -`-)(tkn-char(char `))..]
            [make-binding (" -a-)(tkn-char(char a))..]
            [make-binding (" -b-)(tkn-char(char b))..]
            [make-binding (" -c-)(tkn-char(char c))..]
            [make-binding (" -d-)(tkn-char(char d))..]
            [make-binding (" -e-)(tkn-char(char e))..]
            [make-binding (" -f-)(tkn-char(char f))..]
            [make-binding (" -g-)(tkn-char(char g))..]
            [make-binding (" -h-)(tkn-char(char h))..]
            [make-binding (" -i-)(tkn-char(char i))..]
            [make-binding (" -j-)(tkn-char(char j))..]
            [make-binding (" -k-)(tkn-char(char k))..]
            [make-binding (" -l-)(tkn-char(char l))..]
            [make-binding (" -m-)(tkn-char(char m))..]
            [make-binding (" -n-)(tkn-char(char n))..]
            [make-binding (" -o-)(tkn-char(char o))..]
            [make-binding (" -p-)(tkn-char(char p))..]
            [make-binding (" -q-)(tkn-char(char q))..]
            [make-binding (" -r-)(tkn-char(char r))..]
            [make-binding (" -s-)(tkn-char(char s))..]
            [make-binding (" -t-)(tkn-char(char t))..]
            [make-binding (" -u-)(tkn-char(char u))..]
            [make-binding (" -v-)(tkn-char(char v))..]
            [make-binding (" -w-)(tkn-char(char w))..]
            [make-binding (" -x-)(tkn-char(char x))..]
            [make-binding (" -y-)(tkn-char(char y))..]
            [make-binding (" -z-)(tkn-char(char z))..]
            [make-binding (" -|-)(tkn-char(char |))..]
            [make-binding (" -~-)(tkn-char(char ~))..]
            [make-binding (" @fst) @car ..]
            [make-binding (" @rst) @cdr ..]
            [make-binding (" lst) cons ..]
            [make-binding (" token?) i/f:token? ..]
            [make-binding (" emt?) nil? ..]
            [make-binding (" emt) nil ..]
            [make-binding (" char=) i/f:char= ..]
            [make-binding (" var=) vbl= ..]
            [make-binding (" var?) vbl? ..]
            [make-binding (" var) vbl ..])..)))) (do
          
          (;; Evaluate the metaprogram)
          [evaluate-files source-fns object-fns bndgs buf handler]
          (;; Compile the program in the metaprogram's environment)
          [compile-files source-fns $bndgs buf handler]
          (storage _ no-error)))))))))
        
        (handler err (substitute (.. cleanup) (do
          (switch = (@0 err)
            (multiple-definition-error (do
              [print-str (stdout) (" The definition of(space)) ..]
              [print-str (stdout) (@1 err) ..]
              [print-str (stdout) (" (space)erroneously occured multiple times.(lf)) ..]))
              
            (undefined-symbol-error (do
              [print-str (stdout) (" Undefined symbol:(space)) ..]
              [print-str (stdout) (@1 err) ..]
              [print-str (stdout) (" .(lf)) ..]))
            
            (special-form-error (if [not= (@2 err) null-fragment]
              (do
                [print-str (stdout) (" The subexpression(space)) ..]
                [print-fragment (@2 err) ..]
                [print-str (stdout) (" (space)does not satisfy the requirements of the expression(space)) ..]
                [print-fragment (@1 err) ..]
                [print-str (stdout) (" .(lf)) ..])
              (do
                [print-str (stdout) (" The expression(space)) ..]
                [print-fragment (@1 err) ..]
                [print-str (stdout) (" (space)has an incorrect number of subexpressions.(lf)) ..])))
            
            (unexpected-char-error (do
              [print-str (stdout) (" Unexpectedly read(space)) ..]
              [print-char (stdout) (@1 err) ..]
              [print-str (stdout) (" (space)at(space)) ..]
              [print-uint (stdout) (@2 err) ..]
              [print-str (stdout) (" .(lf)) ..]))
            
            (file-access-error (if [not= (@1 err) null-string]
              (do
                [print-str (stdout) (" Inaccessable file:(space)) ..]
                [print-str (stdout) (@1 err) ..]
                [print-str (stdout) (" .(lf)) ..])
              [print-str (stdout) (" Inaccessable file.) ..]))
            
            (arguments-error [print-str (stdout)
              (" Bad command line arguments.(lf)
                 Usage: l2evaluate src1.l2 ... - obj1.o ...(lf)
                 Outcome: Loads the functions in the source and object files into memory, then preprocesses(lf)
                 the source files using the functions in memory, and then compiles the source files into object(lf)
                 files.(lf)) ..])
            
            (memory-access-error [print-str (stdout) (" Memory access error.(lf)) ..])
            
            (object-error [print-str (stdout) (" Bad object file supplied.(lf)) ..])
            
            (unification-error (do
              [print-str (stdout) (" Cannot solve the following equation:(lf)) ..]
              [print-fragment (@1 err) ..]
              [print-str (stdout) (" (space)=(space)) ..]
              [print-fragment (@2 err) ..]
              [print-str (stdout) (" (lf)The above equation was generated from the following expression:(lf)) ..]
              [print-expression (@3 err) ..]
              [print-str (stdout) (" (lf)) ..]))
              
            (undefined))
            
          err)))
  
        (cleanup err (do [destroy-buffer buf exit-cont] err))))
  
  (exit-cont err [exit (if [= (@0 err) no-error] #0 #1)]))

